{"version":3,"sources":["node_modules/browser-pack/_prelude.js","scripts/AssociationEditor.js","item-mirror.js","scripts/FragmentEditor.js","scripts/ItemDriver.js","scripts/ItemMirror.js","scripts/SyncDriver.js","scripts/XooMLConfig.js","scripts/XooMLDriver.js","scripts/XooMLExceptions.js","scripts/XooMLUtil.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","AssociationEditor","options","self","this","element","_fromElement","commonData","XooMLExceptions","missingParameter","_fromOptions","dataElems","uri","elem","ID","getAttribute","_ID_ATTR","displayText","_DISPLAY_TEXT_ATTR","associatedXooMLFragment","_ASSOCIATED_XOOML_FRAGMENT_ATTR","associatedXooMLDriver","_ASSOCIATED_XOOML_DRIVER_ATTR","associatedSyncDriver","_ASSOCIATED_SYNC_DRIVER_ATTR","associatedItemDriver","_ASSOCIATED_ITEM_DRIVER_ATTR","associatedItem","_ASSOCIATED_ITEM_ATTR","localItem","_LOCAL_ITEM_ATTR","isGrouping","JSON","parse","_IS_GROUPING_ATTR","namespace","getElementsByTagName","_NAMESPACE_ELEMENT_NAME","namespaceURI","attributes","name","localName","getAttributeNS","data","textContent","nullArgument","XooMLUtil","generateGUID","_ELEMENT_NAME","prototype","toElement","associationElem","document","createElementNS","Object","keys","forEach","key","setAttribute","nsElem","attrName","setAttributeNS","appendChild","./XooMLExceptions","./XooMLUtil",2,"FragmentEditor","text","_fromString","associations","displayName","schemaLocation","schemaVersion","itemDriver","itemDescribed","syncDriver","xooMLDriver","GUIDGeneratedOnLastWrite","assoc","guid","parser","DOMParser","doc","parseFromString","children","associationElems","fragmentNamespaceElement","_SCHEMA_VERSION_ATTR","_SCHEMA_LOCATION_ATTR","_ITEM_DESCRIBED_ATTR","_DISPLAY_NAME_ATTR","_ITEM_DRIVER_ATTR","_SYNC_DRIVER_ATTR","_XOOML_DRIVER_ATTR","_GUID_ATTR","_ASSOCIATION_ELEMENT_NAME","_ASSOCIATION_ID_ATTR","_ITEM_MIRROR_NS","updateID","fragmentElem","attrValue","id","toString","serializer","XMLSerializer","serializeToString","./AssociationEditor",3,"ItemDriver","callback","clientInterface","authResponse","auth2","getAuthInstance","currentUser","get","getAuthResponse","_AUTH_HEADER","Authorization","access_token","_DRIVE_FILE_API","_FOLDER_MIMETYPE","XooMLConfig","isGroupingItem","$","url","headers","then","resp","mimeType","fail","createGroupingItem","parentURI","title","post","body","parents","createNonGroupingItem","path","file","_dropboxClient","writeFile","error","stat","_showDropboxError","deleteGroupingItem","remove","deleteNonGroupingItem","copyItem","fromPath","toPath","copy","moveItem","move","getURL","makeUrl","publicURL","listItems","query","request","client","drive","files","list","maxResults","q","execute","items","filter","item","xooMLFragmentFileName","map","checkExisted","result","status","isRemoved","./XooMLConfig",4,"ItemMirror","loadXooMLDriver","driver","_xooMLDriver","getXooMLFragment","processXooML","fragmentString","createFromItemDriver","createFromXML","_fragment","_itemDriver","_syncDriver","SyncDriver","refresh","_groupingItemURI","buildFragment","setXooMLFragment","checkCallback","isObject","invalidType","xooMLFragmentURI","_xooMLDriverClient","_itemDriverClient","_creator","creator","groupingItemURI","_newItemMirrorOptions","fragmentURI","XooMLDriver","getDisplayName","setDisplayName","getSchemaVersion","getSchemaLocation","getURIforItemDescribed","getAssociationDisplayText","GUID","setAssociationDisplayText","getAssociationLocalItem","getAssociationAssociatedItem","getFragmentNamespaceAttribute","attributeName","ns","setFragmentNamespaceAttribute","attributeValue","addFragmentNamespaceAttribute","invalidState","removeFragmentNamespaceAttribute","hasFragmentNamespace","listFragmentNamespaceAttributes","getFragmentNamespaceData","setFragmentNamespaceData","createItemMirrorForAssociatedGroupingItem","xooMLOptions","itemOptions","syncOptions","driverURI","utilityURI","isAssociationAssociatedItemGrouping","itemMirror","createAssociation","association","saveOutFragment","save","isFunction","itemURI","isAssociationPhantom","copyAssociation","moveAssociation","deleteAssociation","deleteContent","isPhantom","_unsafeWrite","postDelete","isGUID","upgradeAssociation","renameAssociationLocalItem","newName","postSave","rename","postMove","postWrite","postRefresh","listAssociations","getAssociationNamespaceAttribute","setAssociationNamespaceAttribute","addAssociationNamespaceAttribute","removeAssociationNamespaceAttribute","hasAssociationNamespace","listAssociationNamespaceAttributes","getAssociationNamespaceData","setAssociationNamespaceData","_sync","sync","resetFragment","content","itemMirrorNotCurrent","getCreator","postSync","_isURL","URL","exec","window","./FragmentEditor","./ItemDriver","./SyncDriver","./XooMLDriver",5,"_itemMirror","_localItemCompare","b","processItems","itemAssociations","xooMLContent","xooMLAssociations","xooMLIdx","synchronized","_fragmentEditor","sort","itemLocals","xooMLLocals","itemIdx","search","lastIndexOf","slice",6,"maxFileLength","createAssociationSimple","createAssociationLinkNonGrouping","localItemRequested","createAssociationLinkGrouping","xooMLDriverURI","createAssociationCreate","itemName",7,"_parentURI","_fragmentURI","_readFile","ajax","dataType","xml_text","_searchXooML","folderID","xoomlItem","console","warn","log","xmlString","updateFile","gapi","method","params","uploadType","response","insertFile","fileData","boundary","delimiter","close_delim","reader","FileReader","readAsBinaryString","onload","contentType","type","metadata","kind","base64Data","btoa","multipartRequestBody","stringify","Content-Type","blob","Blob","fileName","checkExists",8,"notImplemented","xooMLUException","itemUException","nonUpgradeableAssociationException","invalidArgument","itemAlreadyExists",9,"_TYPES","[object Boolean]","[object Number]","[object String]","[object Function]","[object Array]","[object Date]","[object RegExp]","[object Object]","[object Error]","hasOptions","checkedOptions","checkedOption","isRequiredOption","missingOptionalParamCount","hasOwnProperty","getType","isArray","value","isString","isBoolean","replace","c","Math","random","v","obj","String","endsWith","string","suffix","indexOf","clone","Date","setTime","getTime","Array","len","attr"],"mappings":"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","file":"item-mirror.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\r\n * AssociationEditor is a minimal interface to represent a XooML2\r\n * association. This object is used together with FragmentEditor to\r\n * fully reprsent a XooML fragment as javascript object. It can be\r\n * converted seamlessly between an object and XML.\r\n *\r\n * Note that upon construction, this doesn't actually create an\r\n * association, merely a /representation/ of an association.\r\n *\r\n * There are two ways to construct an AssociationEditor:\r\n * 1. Through a valid Association XML Element\r\n * 2. By specifying all data through an object\r\n *\r\n * For ItemMirror core developers only. Enable protected to see.\r\n *\r\n * @class AssociationEditor\r\n * @constructor\r\n *\r\n * @param {Object} options The options specified for the constructor\r\n *  @param {Element} options.element A DOM element that correctly\r\n *  represents an association as specified by the XooML schema.\r\n *  @param {Object} options.commonData An object that specifies the\r\n *  data for an association. Look at the private constructor\r\n *  `_fromOptions` for more details\r\n *\r\n * @protected\r\n */\r\n\r\n\r\n'use strict'\r\n\r\nvar XooMLExceptions = require('./XooMLExceptions');\r\nvar XooMLUtil = require('./XooMLUtil');\r\n\r\n var _ELEMENT_NAME = \"association\",\r\n     _NAMESPACE_ELEMENT_NAME = \"associationNamespaceElement\",\r\n     _ID_ATTR = \"ID\",\r\n     _DISPLAY_TEXT_ATTR = \"displayText\",\r\n     _ASSOCIATED_XOOML_FRAGMENT_ATTR = \"associatedXooMLFragment\",\r\n     _ASSOCIATED_XOOML_DRIVER_ATTR = \"associatedXooMLDriver\",\r\n     _ASSOCIATED_SYNC_DRIVER_ATTR = \"associatedSyncDriver\",\r\n     _ASSOCIATED_ITEM_DRIVER_ATTR = \"associatedItemDriver\",\r\n     _ASSOCIATED_ITEM_ATTR = \"associatedItem\",\r\n     _LOCAL_ITEM_ATTR = \"localItem\",\r\n     _IS_GROUPING_ATTR = \"isGrouping\";\r\n\r\n  function AssociationEditor(options) {\r\n    var self = this;\r\n\r\n    if (options.element) {\r\n      _fromElement(options.element, self);\r\n    } else if (options.commonData) {\r\n      _fromOptions(options.commonData, self);\r\n    } else {\r\n      throw new Error(XooMLExceptions.missingParameter);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts the object into an association element, which can then\r\n   * be converted to a string or added to the DOM.\r\n   *\r\n   * @method toElement\r\n   *\r\n   * @return {Element} A DOM element that can be further manipulated\r\n   * with DOM methods\r\n   *\r\n   * @protected\r\n   */\r\n  AssociationEditor.prototype.toElement = function() {\r\n    var self = this,\r\n        // The We use a null namespace to leave it blank, otherwise it\r\n        // sets it as XHTML and won't serialize attribute names properly.\r\n        // The namespace will be inherited by the fragment it resides in.\r\n        associationElem = document.createElementNS(null, _ELEMENT_NAME);\r\n\r\n    // common data\r\n    Object.keys(self.commonData).forEach( function(key) {\r\n      if ( self.commonData[key] ) {// Don't set null attributes\r\n        associationElem.setAttribute(key, self.commonData[key]);\r\n      }\r\n    });\r\n\r\n    // namespace data\r\n    Object.keys(self.namespace).forEach( function(uri) {\r\n      var nsElem = document.createElementNS(uri, _NAMESPACE_ELEMENT_NAME);\r\n      // Attributes\r\n      Object.keys(self.namespace[uri].attributes).forEach( function(attrName) {\r\n        nsElem.setAttributeNS(uri, attrName, self.namespace[ uri ].attributes[ attrName ]);\r\n      });\r\n      // Data\r\n      nsElem.textContent = self.namespace[ uri ].data;\r\n\r\n      associationElem.appendChild(nsElem);\r\n    });\r\n\r\n    return associationElem;\r\n  };\r\n\r\n  /**\r\n   * Takes an association element in XML and then converts that into\r\n   * an AssociationEditor object. Intended to be one of the ways the\r\n   * object is constructed\r\n   *\r\n   * @method _fromElement\r\n   *\r\n   * @param {Element} element The XML element that represents an association.\r\n   */\r\n  function _fromElement(element, self) {\r\n    var dataElems, i, uri, elem;\r\n    // Sets all common data attributes\r\n    self.commonData = {\r\n      ID: element.getAttribute(_ID_ATTR),\r\n      displayText: element.getAttribute(_DISPLAY_TEXT_ATTR),\r\n      associatedXooMLFragment: element.getAttribute(_ASSOCIATED_XOOML_FRAGMENT_ATTR),\r\n      associatedXooMLDriver: element.getAttribute(_ASSOCIATED_XOOML_DRIVER_ATTR),\r\n      associatedSyncDriver: element.getAttribute(_ASSOCIATED_SYNC_DRIVER_ATTR),\r\n      associatedItemDriver: element.getAttribute(_ASSOCIATED_ITEM_DRIVER_ATTR),\r\n      associatedItem: element.getAttribute(_ASSOCIATED_ITEM_ATTR),\r\n      localItem: element.getAttribute(_LOCAL_ITEM_ATTR),\r\n      // We use JSON.parse to get the value as a boolean, not as a string\r\n      isGrouping: JSON.parse(element.getAttribute(_IS_GROUPING_ATTR))\r\n    };\r\n\r\n    self.namespace = {};\r\n\r\n    dataElems = element.getElementsByTagName(_NAMESPACE_ELEMENT_NAME);\r\n    for (i = 0; i < dataElems.length; i += 1) {\r\n      elem = dataElems[i];\r\n      uri = elem.namespaceURI;\r\n\r\n      /**\r\n       * The information for a given namespace. Includes both the\r\n       * data, and the attributes. Namespaces URIs must be unique or\r\n       * they will overwrite data from another namespace\r\n       * @property namespace.URI\r\n       * @type Object\r\n       */\r\n      self.namespace[ uri ] = {};\r\n      self.namespace[ uri ].attributes = {};\r\n\r\n      for (i = 0; i < elem.attributes.length; i += 1) {\r\n        // We have to filter out the special namespace attribute We\r\n        // let the namespace methods handle the namespace, and we\r\n        // don't deal with it\r\n        if (elem.attributes[i].name !== \"xmlns\") {\r\n          /**\r\n           * The attributes of the current namespace, with each attribute\r\n           * having a corresponding value.\r\n           * @property namespace.URI.attributes\r\n           * @type Object\r\n           */\r\n          self.namespace[ uri ].attributes[ elem.attributes[i].localName ] =\r\n            elem.getAttributeNS(uri, elem.attributes[i].localName );\r\n        }\r\n      }\r\n\r\n    /**\r\n     * This is the namespace data stored within the namespace\r\n     * element. Anything can be put here, and it will be stored as a\r\n     * string. ItemMirror will not do anything with the data here and\r\n     * doesn't interact with it at all. It is the responsibility of\r\n     * other applications to properly store information here.\r\n     * @property namespace.URI.data\r\n     * @type String\r\n     */\r\n      self.namespace[ uri ].data = elem.textContent;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Constructs an association with data from an object\r\n   * @method _fromOptions\r\n   *\r\n   * @param {Object} commonData Common data that is used by the\r\n   * itemMirror library, and is app agnostic\r\n   *  @param {String} commonData.displayText Display text for the\r\n   *  association\r\n   *  @param {String} commonData.associatedXooMLFragment URI of the\r\n   *  associated XooML fragment for the association\r\n   *  @param {String} commonData.associatedItem URI of the associated item\r\n   *  @param {String} commonData.associatedXooMLDriver The associated\r\n   *  XooML driver for the association\r\n   *  @param {String} commonData.associatedItemDriver The associated\r\n   *  item driver for the association\r\n   *  @param {String} commonData.associatedSyncDriver The associated\r\n   *  sync driver of the association\r\n   *  @param {String} commonData.localItem The name/id of the\r\n   *  association\r\n   *  @param {Boolean} comnmonData.isGrouping Whether or not the\r\n   *  association is a grouping item\r\n   *  @param {String} commonData.readOnlyURLtoXooMLfragment Used in\r\n   *  cases where the owner wishes for the XooML fragment representing\r\n   *  an item to be public\r\n   * @protected\r\n   * @private\r\n   */\r\n  function _fromOptions(commonData, self) {\r\n    if (!commonData) {\r\n      throw XooMLExceptions.nullArgument;\r\n    }\r\n\r\n    // Properties from the common data\r\n    /**\r\n     * Common Data of the association that is accessible to all applications\r\n     * @property commonData\r\n     * @type Object\r\n     */\r\n    self.commonData = {\r\n      /**\r\n       * Text that describes the association\r\n       * @property commonData.displayText\r\n       * @type String\r\n       */\r\n      displayText: commonData.displayText || null,\r\n\r\n      /**\r\n       * The associated XooML fragment of the association\r\n       * @property commonData.associatedXooMLFragment\r\n       * @type String\r\n       */\r\n      associatedXooMLFragment: commonData.associatedXooMLFragment || null,\r\n\r\n      /**\r\n       * The associated XooML driver of the association\r\n       * @property commonData.associatedXooMLDriver\r\n       * @type String\r\n       */\r\n      associatedXooMLDriver: commonData.associatedXooMLDriver || null,\r\n\r\n      /**\r\n       * The associated sync driver of the association\r\n       * @property commonData.associatedSyncDriver\r\n       * @type String\r\n       */\r\n      associatedSyncDriver: commonData.associatedSyncDriver || null,\r\n\r\n      /**\r\n       * The associated item driver of the association\r\n       * @property commonData.associatedItemDriver\r\n       * @type String\r\n       */\r\n      associatedItemDriver: commonData.associatedItemDriver || null,\r\n\r\n      /**\r\n       * The associated item of the association\r\n       * @property commonData.associatedItem\r\n       * @type String\r\n       */\r\n      associatedItem: commonData.associatedItem || null,\r\n\r\n      /**\r\n       * The local item of the association\r\n       * @property commonData.localItem\r\n       * @type String\r\n       */\r\n      localItem: commonData.localItem || null,\r\n\r\n      /**\r\n       * Whether or not the item is a grouping item\r\n       * @property commonData.isGrouping\r\n       * @type Boolean\r\n       */\r\n      isGrouping: commonData.isGrouping || false,\r\n\r\n      /**\r\n       * The GUID of the association\r\n       * @property commonData.ID\r\n       * @type String\r\n       */\r\n      // GUID is generated upon construction\r\n      ID: XooMLUtil.generateGUID()\r\n    };\r\n\r\n    /**\r\n     * Data for the namespaces. Stored as a key pair value, with each\r\n     * namespace referencing the namespace association element for the\r\n     * corresponding namespace.\r\n     *\r\n     * @property namespace\r\n     * @type Object\r\n     */\r\n    self.namespace = {};\r\n    /**\r\n     * The attributes of the current namespace, with each attribute\r\n     * having a corresponding value.\r\n     * @property namespace.URI.attributes\r\n     * @type Object\r\n     */\r\n\r\n    /**\r\n     * This is the namespace data stored within the namespace\r\n     * element. Anything can be put here, and it will be stored as a\r\n     * string. ItemMirror will not do anything with the data here and\r\n     * doesn't interact with it at all. It is the responsibility of\r\n     * other applications to properly store information here.\r\n     *\r\n     * @property namespace.URI.data\r\n     * @type String\r\n     */\r\n  }\r\n\r\nmodule.exports = AssociationEditor;","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\r\n * AssociationEditor is a minimal interface to represent a XooML2\r\n * association. This object is used together with FragmentEditor to\r\n * fully reprsent a XooML fragment as javascript object. It can be\r\n * converted seamlessly between an object and XML.\r\n *\r\n * Note that upon construction, this doesn't actually create an\r\n * association, merely a /representation/ of an association.\r\n *\r\n * There are two ways to construct an AssociationEditor:\r\n * 1. Through a valid Association XML Element\r\n * 2. By specifying all data through an object\r\n *\r\n * For ItemMirror core developers only. Enable protected to see.\r\n *\r\n * @class AssociationEditor\r\n * @constructor\r\n *\r\n * @param {Object} options The options specified for the constructor\r\n *  @param {Element} options.element A DOM element that correctly\r\n *  represents an association as specified by the XooML schema.\r\n *  @param {Object} options.commonData An object that specifies the\r\n *  data for an association. Look at the private constructor\r\n *  `_fromOptions` for more details\r\n *\r\n * @protected\r\n */\r\n\r\n\r\n'use strict'\r\n\r\nvar XooMLExceptions = require('./XooMLExceptions');\r\nvar XooMLUtil = require('./XooMLUtil');\r\n\r\n var _ELEMENT_NAME = \"association\",\r\n     _NAMESPACE_ELEMENT_NAME = \"associationNamespaceElement\",\r\n     _ID_ATTR = \"ID\",\r\n     _DISPLAY_TEXT_ATTR = \"displayText\",\r\n     _ASSOCIATED_XOOML_FRAGMENT_ATTR = \"associatedXooMLFragment\",\r\n     _ASSOCIATED_XOOML_DRIVER_ATTR = \"associatedXooMLDriver\",\r\n     _ASSOCIATED_SYNC_DRIVER_ATTR = \"associatedSyncDriver\",\r\n     _ASSOCIATED_ITEM_DRIVER_ATTR = \"associatedItemDriver\",\r\n     _ASSOCIATED_ITEM_ATTR = \"associatedItem\",\r\n     _LOCAL_ITEM_ATTR = \"localItem\",\r\n     _IS_GROUPING_ATTR = \"isGrouping\";\r\n\r\n  function AssociationEditor(options) {\r\n    var self = this;\r\n\r\n    if (options.element) {\r\n      _fromElement(options.element, self);\r\n    } else if (options.commonData) {\r\n      _fromOptions(options.commonData, self);\r\n    } else {\r\n      throw new Error(XooMLExceptions.missingParameter);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts the object into an association element, which can then\r\n   * be converted to a string or added to the DOM.\r\n   *\r\n   * @method toElement\r\n   *\r\n   * @return {Element} A DOM element that can be further manipulated\r\n   * with DOM methods\r\n   *\r\n   * @protected\r\n   */\r\n  AssociationEditor.prototype.toElement = function() {\r\n    var self = this,\r\n        // The We use a null namespace to leave it blank, otherwise it\r\n        // sets it as XHTML and won't serialize attribute names properly.\r\n        // The namespace will be inherited by the fragment it resides in.\r\n        associationElem = document.createElementNS(null, _ELEMENT_NAME);\r\n\r\n    // common data\r\n    Object.keys(self.commonData).forEach( function(key) {\r\n      if ( self.commonData[key] ) {// Don't set null attributes\r\n        associationElem.setAttribute(key, self.commonData[key]);\r\n      }\r\n    });\r\n\r\n    // namespace data\r\n    Object.keys(self.namespace).forEach( function(uri) {\r\n      var nsElem = document.createElementNS(uri, _NAMESPACE_ELEMENT_NAME);\r\n      // Attributes\r\n      Object.keys(self.namespace[uri].attributes).forEach( function(attrName) {\r\n        nsElem.setAttributeNS(uri, attrName, self.namespace[ uri ].attributes[ attrName ]);\r\n      });\r\n      // Data\r\n      nsElem.textContent = self.namespace[ uri ].data;\r\n\r\n      associationElem.appendChild(nsElem);\r\n    });\r\n\r\n    return associationElem;\r\n  };\r\n\r\n  /**\r\n   * Takes an association element in XML and then converts that into\r\n   * an AssociationEditor object. Intended to be one of the ways the\r\n   * object is constructed\r\n   *\r\n   * @method _fromElement\r\n   *\r\n   * @param {Element} element The XML element that represents an association.\r\n   */\r\n  function _fromElement(element, self) {\r\n    var dataElems, i, uri, elem;\r\n    // Sets all common data attributes\r\n    self.commonData = {\r\n      ID: element.getAttribute(_ID_ATTR),\r\n      displayText: element.getAttribute(_DISPLAY_TEXT_ATTR),\r\n      associatedXooMLFragment: element.getAttribute(_ASSOCIATED_XOOML_FRAGMENT_ATTR),\r\n      associatedXooMLDriver: element.getAttribute(_ASSOCIATED_XOOML_DRIVER_ATTR),\r\n      associatedSyncDriver: element.getAttribute(_ASSOCIATED_SYNC_DRIVER_ATTR),\r\n      associatedItemDriver: element.getAttribute(_ASSOCIATED_ITEM_DRIVER_ATTR),\r\n      associatedItem: element.getAttribute(_ASSOCIATED_ITEM_ATTR),\r\n      localItem: element.getAttribute(_LOCAL_ITEM_ATTR),\r\n      // We use JSON.parse to get the value as a boolean, not as a string\r\n      isGrouping: JSON.parse(element.getAttribute(_IS_GROUPING_ATTR))\r\n    };\r\n\r\n    self.namespace = {};\r\n\r\n    dataElems = element.getElementsByTagName(_NAMESPACE_ELEMENT_NAME);\r\n    for (i = 0; i < dataElems.length; i += 1) {\r\n      elem = dataElems[i];\r\n      uri = elem.namespaceURI;\r\n\r\n      /**\r\n       * The information for a given namespace. Includes both the\r\n       * data, and the attributes. Namespaces URIs must be unique or\r\n       * they will overwrite data from another namespace\r\n       * @property namespace.URI\r\n       * @type Object\r\n       */\r\n      self.namespace[ uri ] = {};\r\n      self.namespace[ uri ].attributes = {};\r\n\r\n      for (i = 0; i < elem.attributes.length; i += 1) {\r\n        // We have to filter out the special namespace attribute We\r\n        // let the namespace methods handle the namespace, and we\r\n        // don't deal with it\r\n        if (elem.attributes[i].name !== \"xmlns\") {\r\n          /**\r\n           * The attributes of the current namespace, with each attribute\r\n           * having a corresponding value.\r\n           * @property namespace.URI.attributes\r\n           * @type Object\r\n           */\r\n          self.namespace[ uri ].attributes[ elem.attributes[i].localName ] =\r\n            elem.getAttributeNS(uri, elem.attributes[i].localName );\r\n        }\r\n      }\r\n\r\n    /**\r\n     * This is the namespace data stored within the namespace\r\n     * element. Anything can be put here, and it will be stored as a\r\n     * string. ItemMirror will not do anything with the data here and\r\n     * doesn't interact with it at all. It is the responsibility of\r\n     * other applications to properly store information here.\r\n     * @property namespace.URI.data\r\n     * @type String\r\n     */\r\n      self.namespace[ uri ].data = elem.textContent;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Constructs an association with data from an object\r\n   * @method _fromOptions\r\n   *\r\n   * @param {Object} commonData Common data that is used by the\r\n   * itemMirror library, and is app agnostic\r\n   *  @param {String} commonData.displayText Display text for the\r\n   *  association\r\n   *  @param {String} commonData.associatedXooMLFragment URI of the\r\n   *  associated XooML fragment for the association\r\n   *  @param {String} commonData.associatedItem URI of the associated item\r\n   *  @param {String} commonData.associatedXooMLDriver The associated\r\n   *  XooML driver for the association\r\n   *  @param {String} commonData.associatedItemDriver The associated\r\n   *  item driver for the association\r\n   *  @param {String} commonData.associatedSyncDriver The associated\r\n   *  sync driver of the association\r\n   *  @param {String} commonData.localItem The name/id of the\r\n   *  association\r\n   *  @param {Boolean} comnmonData.isGrouping Whether or not the\r\n   *  association is a grouping item\r\n   *  @param {String} commonData.readOnlyURLtoXooMLfragment Used in\r\n   *  cases where the owner wishes for the XooML fragment representing\r\n   *  an item to be public\r\n   * @protected\r\n   * @private\r\n   */\r\n  function _fromOptions(commonData, self) {\r\n    if (!commonData) {\r\n      throw XooMLExceptions.nullArgument;\r\n    }\r\n\r\n    // Properties from the common data\r\n    /**\r\n     * Common Data of the association that is accessible to all applications\r\n     * @property commonData\r\n     * @type Object\r\n     */\r\n    self.commonData = {\r\n      /**\r\n       * Text that describes the association\r\n       * @property commonData.displayText\r\n       * @type String\r\n       */\r\n      displayText: commonData.displayText || null,\r\n\r\n      /**\r\n       * The associated XooML fragment of the association\r\n       * @property commonData.associatedXooMLFragment\r\n       * @type String\r\n       */\r\n      associatedXooMLFragment: commonData.associatedXooMLFragment || null,\r\n\r\n      /**\r\n       * The associated XooML driver of the association\r\n       * @property commonData.associatedXooMLDriver\r\n       * @type String\r\n       */\r\n      associatedXooMLDriver: commonData.associatedXooMLDriver || null,\r\n\r\n      /**\r\n       * The associated sync driver of the association\r\n       * @property commonData.associatedSyncDriver\r\n       * @type String\r\n       */\r\n      associatedSyncDriver: commonData.associatedSyncDriver || null,\r\n\r\n      /**\r\n       * The associated item driver of the association\r\n       * @property commonData.associatedItemDriver\r\n       * @type String\r\n       */\r\n      associatedItemDriver: commonData.associatedItemDriver || null,\r\n\r\n      /**\r\n       * The associated item of the association\r\n       * @property commonData.associatedItem\r\n       * @type String\r\n       */\r\n      associatedItem: commonData.associatedItem || null,\r\n\r\n      /**\r\n       * The local item of the association\r\n       * @property commonData.localItem\r\n       * @type String\r\n       */\r\n      localItem: commonData.localItem || null,\r\n\r\n      /**\r\n       * Whether or not the item is a grouping item\r\n       * @property commonData.isGrouping\r\n       * @type Boolean\r\n       */\r\n      isGrouping: commonData.isGrouping || false,\r\n\r\n      /**\r\n       * The GUID of the association\r\n       * @property commonData.ID\r\n       * @type String\r\n       */\r\n      // GUID is generated upon construction\r\n      ID: XooMLUtil.generateGUID()\r\n    };\r\n\r\n    /**\r\n     * Data for the namespaces. Stored as a key pair value, with each\r\n     * namespace referencing the namespace association element for the\r\n     * corresponding namespace.\r\n     *\r\n     * @property namespace\r\n     * @type Object\r\n     */\r\n    self.namespace = {};\r\n    /**\r\n     * The attributes of the current namespace, with each attribute\r\n     * having a corresponding value.\r\n     * @property namespace.URI.attributes\r\n     * @type Object\r\n     */\r\n\r\n    /**\r\n     * This is the namespace data stored within the namespace\r\n     * element. Anything can be put here, and it will be stored as a\r\n     * string. ItemMirror will not do anything with the data here and\r\n     * doesn't interact with it at all. It is the responsibility of\r\n     * other applications to properly store information here.\r\n     *\r\n     * @property namespace.URI.data\r\n     * @type String\r\n     */\r\n  }\r\n\r\nmodule.exports = AssociationEditor;\n},{\"./XooMLExceptions\":8,\"./XooMLUtil\":9}],2:[function(require,module,exports){\n/**\r\n * Constructs a FragmentWrapper for a XooML fragment. In the following cases.\r\n *\r\n * 1. XooMLFragment String is passed in and is used as the XooMLFragment\r\n * 2. XooMLFragment Element is passed in and is used as the XooMLFragment.\r\n * 2. Associations, XooMLDriver, ItemDriver, SyncDriver,\r\n * groupingItemURI are given and used to create a new XooMLFragment with\r\n * the given data.\r\n *\r\n * The FragmentWrapper is merely a representation of a XooML fragment,\r\n * and is used by an itemMirror that actually handles the details of\r\n * creating deleting and modifying associations.\r\n *\r\n * For ItemMirror core developers only. Enable protected to see.\r\n *\r\n * @class FragmentEditor\r\n * @constructor\r\n *\r\n * @param {Object} options Data to construct a new FragmentWrapper with\r\n *  @param {String} options.text Unparsed XML directly from a storage\r\n *  platform.\r\n *  @param {Element} options.element XML Element representing a XooML\r\n *                   fragment. Required for case 1.\r\n *  @param {AssociationEditor[]} options.associations List of associations for\r\n *          the newly constructed XooMLFragment in case 2. <br/>__optional__\r\n *  @param {Object} options.commonData Common data for the\r\n *  fragment. Look at the constructor for more details. Required for case 2\r\n *  @param {String} options.groupingItemURI The URI for the grouping\r\n *  item of the fragment. Required for case 2.\r\n *\r\n * @protected\r\n **/\r\n\r\n\r\n'use strict'\r\n\r\nvar XooMLExceptions = require('./XooMLExceptions');\r\nvar XooMLUtil = require('./XooMLUtil');\r\nvar AssociationEditor = require('./AssociationEditor');\r\n\r\n  var _ELEMENT_NAME = \"fragment\",\r\n      _ASSOCIATION_ELEMENT_NAME = \"association\",\r\n      _ASSOCIATION_ID_ATTR = \"ID\",\r\n      _NAMESPACE_ELEMENT_NAME = \"fragmentNamespaceElement\",\r\n      _SCHEMA_VERSION_ATTR = \"schemaVersion\",\r\n      _SCHEMA_LOCATION_ATTR = \"schemaLocation\",\r\n      _ITEM_DESCRIBED_ATTR = \"itemDescribed\",\r\n      _DISPLAY_NAME_ATTR = \"displayName\",\r\n      _ITEM_DRIVER_ATTR = \"itemDriver\",\r\n      _SYNC_DRIVER_ATTR = \"syncDriver\",\r\n      _XOOML_DRIVER_ATTR = \"xooMLDriver\",\r\n      _GUID_ATTR = \"GUIDGeneratedOnLastWrite\",\r\n      _ITEM_MIRROR_NS = \"http://kftf.ischool.washington.edu/xmlns/xooml\";\r\n\r\n  function FragmentEditor(options) {\r\n    var self = this;\r\n\r\n    if (options.text) {\r\n      _fromString(options.text, self);\r\n    } else if (options.element) {\r\n      _fromElement(options.element, self);\r\n    } else if (options.commonData) {\r\n      _fromOptions(options.commonData, options.associations, self);\r\n    } else {\r\n      throw new Error(XooMLExceptions.missingParameter);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the GUID of the Fragment\r\n   *\r\n   * @method updateID\r\n   * @return {String} The new GUID of the fragment\r\n   * @private\r\n   * @protected\r\n   */\r\n  FragmentEditor.prototype.updateID = function() {\r\n    var guid = XooMLUtil.generateGUID();\r\n    this.commonData.GUIDGeneratedOnLastWrite = guid;\r\n    return guid;\r\n  };\r\n\r\n  /**\r\n   * Converts a FragmentEditor object into an XML element, which can\r\n   * then be serialized and saved as a string, or further manipulated\r\n   * with DOM methods\r\n   * @method toElement\r\n   * @return {Element} The XooML fragment as an XML element\r\n   * @protected\r\n   */\r\n  FragmentEditor.prototype.toElement = function() {\r\n    var self = this,\r\n        fragmentElem = document.createElementNS(_ITEM_MIRROR_NS, _ELEMENT_NAME);\r\n\r\n    // common data\r\n    Object.keys(self.commonData).forEach( function(attrName) {\r\n      var attrValue = self.commonData[attrName];\r\n      if (attrValue) { // Don't set null attributes\r\n        fragmentElem.setAttribute(attrName, attrValue);\r\n      }\r\n    });\r\n\r\n    // namespace data\r\n    Object.keys(self.namespace).forEach( function(uri) {\r\n      var nsElem = document.createElementNS(uri, _NAMESPACE_ELEMENT_NAME);\r\n      // Attributes\r\n      Object.keys(self.namespace[uri].attributes).forEach( function(attrName) {\r\n        nsElem.setAttributeNS(uri, attrName, self.namespace[ uri ].attributes[ attrName ]);\r\n      });\r\n\r\n      nsElem.textContent = self.namespace[ uri ].data;\r\n\r\n      fragmentElem.appendChild(nsElem);\r\n    });\r\n\r\n    // associations\r\n    Object.keys(self.associations).forEach( function(id) {\r\n      fragmentElem.appendChild( self.associations[id].toElement() );\r\n    });\r\n\r\n    return fragmentElem;\r\n  };\r\n\r\n  /**\r\n   * Returns the XML of a fragment as a string, _not_ the string\r\n   * version of the object. This is used for persisting the fragment\r\n   * across multiple platforms\r\n   * @method toString\r\n   * @return {String} Fragment XML\r\n   */\r\n  FragmentEditor.prototype.toString = function() {\r\n    var serializer = new XMLSerializer();\r\n    return serializer.serializeToString( this.toElement() );\r\n  };\r\n\r\n  /**\r\n   * Constructs a fragmentEditor based on data passed into the\r\n   * parameters\r\n   *\r\n   * @method _fromOptions\r\n   *\r\n   * @param {Object} commonData An object containing common data for the association\r\n   *  @param {String} commonData.schemaVersion The version of the schema <br/> __required__\r\n   *  @param {String} commonData.schemaLocation The location of the schema\r\n   *  @param {String} commonData.itemDescribed URI pointing to item for which the\r\n   *  XooML fragment is metadata.\r\n   *  @param {String} commonData.displayName Display name of the fragment\r\n   *  @param {String} commonData.itemDriver The URI of the item driver for the fragment\r\n   *  @param {String} commonData.syncDriver The URI of the sync driver for the fragment\r\n   *  @param {String} commonData.xooMLDriver The URI of the XooML driver for the fragment\r\n   *  @param {String} commonData.GUIDGeneratedOnLastWrite The GUID generated the last time the fragment was written\r\n   * @param {AssociationEditor[]} associations An array of associations that the fragment has\r\n   * @param {String} namespace The namespace URI that an app will use for it's own private data\r\n   * @param {FragmentEditor} self\r\n   *\r\n   * @private\r\n   */\r\n  function _fromOptions(commonData, associations, self) {\r\n    if (!commonData) {\r\n      throw XooMLExceptions.nullArgument;\r\n    }\r\n\r\n    // Properties from the common data\r\n    /**\r\n     * Common Data of the association that is accessible to all applications\r\n     * @property commonData\r\n     * @type Object\r\n     */\r\n    self.commonData = {\r\n      /**\r\n       * Text that describes the fragment\r\n       * @property commonData.displayName\r\n       * @type String\r\n       */\r\n      displayName: commonData.displayName || null,\r\n\r\n      /**\r\n       * The schema location for the fragment\r\n       * @property commonData.schemaLocation\r\n       * @type String\r\n       */\r\n      schemaLocation: commonData.schemaLocation || null,\r\n\r\n      /**\r\n       * The schema version for the fragment\r\n       * @property commonData.schemaVersion\r\n       * @type String\r\n       */\r\n      schemaVersion: commonData.schemaVersion || null,\r\n\r\n      /**\r\n       * The item driver URI for the fragment\r\n       * @property commonData.itemDriver\r\n       * @type String\r\n       */\r\n      itemDriver: commonData.itemDriver || null,\r\n\r\n      /**\r\n       * The item described for the fragment. This is a URI that\r\n       * points to grouping item from wich the itemMirror was created\r\n       * @property commonData.\r\n       * @type String\r\n       */\r\n      itemDescribed: commonData.itemDescribed || null,\r\n\r\n      /**\r\n       * The sync driver URI for the fragment\r\n       * @property commonData.syncDriver\r\n       * @type String\r\n       */\r\n      syncDriver: commonData.syncDriver || null,\r\n\r\n      /**\r\n       * The XooML driver URI for the fragment\r\n       * @property commonData.xooMLDriver\r\n       * @type String\r\n       */\r\n      xooMLDriver: commonData.xooMLDriver || null,\r\n\r\n      /**\r\n       * The unique GUID for the fragment that is updated after every\r\n       * write\r\n       * @property commonData.GUIDGeneratedOnLastWrite\r\n       * @type String\r\n       */\r\n      GUIDGeneratedOnLastWrite: XooMLUtil.generateGUID()\r\n    };\r\n\r\n    /**\r\n     * The associations of the fragment. Each association is accessed\r\n     * by referencing it's ID, which then gives the corresponding\r\n     * AssociationEditor object for manipulating that association.\r\n     * @property associations\r\n     * @type Object\r\n     */\r\n    // Takes the association array and turns it into an associative\r\n    // array accessed by the GUID of an association\r\n    self.associations = {};\r\n    associations.forEach( function(assoc) {\r\n      var guid = assoc.commonData.ID;\r\n      self.associations[guid] = assoc;\r\n    });\r\n\r\n\r\n    /**\r\n     * The namespace data of the fragment. Holds both the URI as well\r\n     * as the namespace specific data for the fragment\r\n     * @property namespace\r\n     * @type Object\r\n     */\r\n    self.namespace = {};\r\n      /**\r\n       * The namespace URI for the fragment. Used to set namespace data\r\n       * for both the fragment and it's associations\r\n       * @property namespace.uri\r\n       * @type String\r\n       */\r\n\r\n      /**\r\n       * The attributes of the namespace. This is app specific data\r\n       * that is set for the fragment. Each key pair in the object\r\n       * represents an attribute name and it's corresponding value\r\n       * @property namespace.attributes\r\n       * @type Object\r\n       */\r\n  }\r\n\r\n  /**\r\n   * Takes a fragment in the form of a string and then parses that\r\n   * into XML. From there it converts that element into an object\r\n   * using the _fromElement method\r\n   * \r\n   * @method _fromString\r\n   *\r\n   * @param {String} text The text representing the fragment. Should\r\n   * be obtained directly from a storage platform like dropbox or a\r\n   * local filesystem\r\n   * @param {String} namespace The URI of the namespace that will\r\n   * initially be used for the fragment when handling any namespace\r\n   * data\r\n   * @param {FragmentEditor} self\r\n   */\r\n  function _fromString(text, namespace, self) {\r\n    var parser = new DOMParser();\r\n    var doc = parser.parseFromString(text, \"application/xml\");\r\n    _fromElement(doc.children[0], namespace, self);\r\n  }\r\n\r\n  /**\r\n   * Takes a fragment element in XML and then converts that into a\r\n   * FragmentEditor object. Intended to be one of the ways the object\r\n   * is constructed\r\n   *\r\n   * @method _fromElement\r\n   *\r\n   * @param {Element} element The XML element that represents an association.\r\n   * @param {FragmentEditor} self\r\n   * @private\r\n   */\r\n  function _fromElement(element, self) {\r\n    var dataElems, i, associationElems, guid, elem, uri;\r\n    // Sets all common data attributes\r\n    self.commonData = {\r\n      fragmentNamespaceElement: element.getAttribute(_NAMESPACE_ELEMENT_NAME),\r\n      schemaVersion: element.getAttribute(_SCHEMA_VERSION_ATTR),\r\n      schemaLocation: element.getAttribute(_SCHEMA_LOCATION_ATTR),\r\n      itemDescribed: element.getAttribute(_ITEM_DESCRIBED_ATTR),\r\n      displayName: element.getAttribute(_DISPLAY_NAME_ATTR),\r\n      itemDriver: element.getAttribute(_ITEM_DRIVER_ATTR),\r\n      syncDriver: element.getAttribute(_SYNC_DRIVER_ATTR),\r\n      xooMLDriver: element.getAttribute(_XOOML_DRIVER_ATTR),\r\n      GUIDGeneratedOnLastWrite: element.getAttribute(_GUID_ATTR)\r\n    };\r\n\r\n    /**\r\n     * The namespace object is an associated array with each key being\r\n     * a namespace URI. These can thene be used to modify fragment\r\n     * namespace attributes and data\r\n     * @property namespace\r\n     * @type Object\r\n     */\r\n    self.namespace = {};\r\n\r\n    dataElems = element.getElementsByTagName(_NAMESPACE_ELEMENT_NAME);\r\n    for (i = 0; i < dataElems.length; i += 1) {\r\n      elem = dataElems[i];\r\n      uri = elem.namespaceURI;\r\n\r\n      /**\r\n       * The information for a given namespace. Includes both the\r\n       * data, and the attributes. Namespaces URIs must be unique or\r\n       * they will overwrite data from another namespace\r\n       * @property namespace.URI\r\n       * @type Object\r\n       */\r\n      self.namespace[ uri ] = {};\r\n      self.namespace[ uri ].attributes = {};\r\n\r\n      for (i = 0; i < elem.attributes.length; i += 1) {\r\n        // We have to filter out the special namespace attribute We\r\n        // let the namespace methods handle the namespace, and we\r\n        // don't deal with it\r\n        if (elem.attributes[i].name !== \"xmlns\") {\r\n          /**\r\n           * The attributes of the current namespace, with each attribute\r\n           * having a corresponding value.\r\n           * @property namespace.URI.attributes\r\n           * @type Object\r\n           */\r\n          self.namespace[ uri ].attributes[ elem.attributes[i].localName ] =\r\n            elem.getAttributeNS(uri, elem.attributes[i].localName);\r\n        }\r\n      }\r\n\r\n    /**\r\n     * This is the namespace data stored within the namespace\r\n     * element. Anything can be put here, and it will be stored as a\r\n     * string. ItemMirror will not do anything with the data here and\r\n     * doesn't interact with it at all. It is the responsibility of\r\n     * other applications to properly store information here.\r\n     * @property namespace.URI.data\r\n     * @type String\r\n     */\r\n      self.namespace[ uri ].data = elem.textContent;\r\n    }\r\n\r\n    // associations\r\n    self.associations = {};\r\n    associationElems = element.getElementsByTagName(_ASSOCIATION_ELEMENT_NAME);\r\n    for (i = 0; i < associationElems.length; i += 1) {\r\n      guid = associationElems[i].getAttribute(_ASSOCIATION_ID_ATTR);\r\n      self.associations[guid] = new AssociationEditor({\r\n        element: associationElems[i]\r\n      });\r\n    }\r\n  }\r\n\r\nmodule.exports = FragmentEditor;\n},{\"./AssociationEditor\":1,\"./XooMLExceptions\":8,\"./XooMLUtil\":9}],3:[function(require,module,exports){\n/**\r\n * An item utility interacts with the item storage and is responsible for\r\n * creating and deleting items. This is an implementation of item utility\r\n * using Dropbox as the item storage.\r\n *\r\n * For ItemMirror core developers only. Enable protected to see.\r\n *\r\n * @class ItemDriver\r\n * @constructor\r\n *\r\n * @param {Object} options Data to construct a new ItemU with\r\n * @param {String} options.utilityURI URI of the utility\r\n * @param {Object} options.dropboxClient Authenticated dropbox client\r\n *\r\n * @protected\r\n */\r\n\r\n'use strict'\r\n\r\nvar XooMLConfig = require('./XooMLConfig');\r\nvar AssociationEditor = require('./AssociationEditor');\r\n\r\n  /**\r\n   * Constructs a ItemDriver for reading/writing Item Storage\r\n   *\r\n   * @method ItemDriver\r\n   *\r\n   * @param {Object} options Options passed for construction\r\n   * @param {Function} callback The function to call after completion\r\n   *\r\n   * @protected\r\n   */\r\n  function ItemDriver(options, callback) {\r\n    var self = this;\r\n\r\n    // client (google drive in this case)\r\n    if (!options.clientInterface) {\r\n      throw new Error('Client parameter missing');\r\n    }\r\n    this.clientInterface = options.clientInterface;\r\n\r\n    var authResponse = this.clientInterface.auth2.getAuthInstance()\r\n      .currentUser.get()\r\n      .getAuthResponse();\r\n\r\n    // These are the same across multple files, and so should be put in a common configuration somewhere\r\n    this._AUTH_HEADER = { Authorization: 'Bearer ' + authResponse.access_token };\r\n    this._DRIVE_FILE_API = 'https://www.googleapis.com/drive/v2/files/';\r\n\r\n    self._FOLDER_MIMETYPE = 'application/vnd.google-apps.folder';\r\n\r\n    return callback(false, self);\r\n  }\r\n\r\n  ItemDriver.prototype.isGroupingItem = function (id, callback) {\r\n    var self = this;\r\n\r\n    // do a simple get request, and see if it's a folder\r\n    $.get({\r\n      url: self._DRIVE_FILE_API + id,\r\n      headers: self._AUTH_HEADER\r\n    }).then(function(resp) {\r\n      // This is the specific mimetype that google counts as a 'folder'\r\n      callback(false, self._FOLDER_MIMETYPE === resp.mimeType);\r\n    }).fail(function() {\r\n      callback('No response from GET: ' + id);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Creates a grouping item at the location\r\n   * @method createGroupingItem\r\n   * @param {String} path the path to the location that the grouping item will be created\r\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\r\n   *\r\n   * @protected\r\n   */\r\n  ItemDriver.prototype.createGroupingItem = function (parentURI, title, callback) {\r\n    var self = this;\r\n\r\n    $.post({\r\n      url: self._DRIVE_FILE_API,\r\n      headers: self._AUTH_HEADER,\r\n      body: {\r\n        mimeType: self._FOLDER_MIMETYPE,\r\n        title: title,\r\n        parents: [parentURI]\r\n      }\r\n    }).then(function(resp) {\r\n      // Callback with ID of the newly created folder so we have a reference\r\n      callback(false, resp.id);\r\n    }).fail(function() {\r\n      callback('Failed to make POST request for new grouping item. Check network requests for more deatils');\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Creates or uploads a non-grouping item at the location\r\n   * @method createNonGroupingItem\r\n   * @param {String} path the path to the location that the non-grouping item will be created\r\n   * @param {String} file the contents to be written to the non-grouping item\r\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\r\n   *\r\n   * @protected\r\n   */\r\n  ItemDriver.prototype.createNonGroupingItem = function (path, file, callback) {\r\n    var self = this;\r\n\r\n    self._dropboxClient.writeFile(path, file, function (error, stat) {\r\n      if (error) {\r\n        return self._showDropboxError(error, callback);\r\n      }\r\n      return callback(false, stat);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Deletes a grouping item at the location\r\n   * @method deleteGroupingItem\r\n   * @param {String} path the path to the location that the grouping item is located\r\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\r\n   *\r\n   * @protected\r\n   */\r\n  ItemDriver.prototype.deleteGroupingItem = function (path, callback) {\r\n    var self = this;\r\n\r\n    self._dropboxClient.remove(path, function (error, stat) {\r\n      if (error) {\r\n        return self._showDropboxError(error, callback);\r\n      }\r\n      return callback(false, stat);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Deletes a non-grouping item at the location\r\n   * @method deleteNonGroupingItem\r\n   * @param {String} path the path to the location that the non-grouping item is located\r\n   * @param {String} name the name of the non-grouping item\r\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\r\n   *\r\n   * @protected\r\n   */\r\n  ItemDriver.prototype.deleteNonGroupingItem = function (path, callback) {\r\n    var self = this;\r\n\r\n    self._dropboxClient.remove(path, function (error, stat) {\r\n      if (error) {\r\n        return self._showDropboxError(error, callback);\r\n      }\r\n      return callback(false, stat);\r\n    });\r\n  };\r\n  \r\n    /**\r\n   * Copies an item in the fashion of moveItem\r\n   * @method copyItem\r\n   * @param {String} fromPath the path to the file you want copied\r\n   * @param {String} toPath the GroupingItem path you want the fromPath file copied to\r\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\r\n   *\r\n   * @protected\r\n   */\r\n  self.copyItem = function (fromPath, toPath, callback) {\r\n    var self = this;\r\n    \r\n    self._dropboxClient.copy(fromPath, toPath, function(error){\r\n      if (error) {\r\n        return self._showDropboxError(error, callback);\r\n      }\r\n      return callback(false);\r\n    });\r\n  };\r\n  \r\n  /**\r\n   * Moves an item\r\n   * @method moveItem\r\n   * @param {String} fromPath the path to the file you want moved\r\n   * @param {String} toPath the GroupingItem path you want the fromPath file moved\r\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\r\n   *\r\n   * @protected\r\n   */\r\n  ItemDriver.prototype.moveItem = function (fromPath, toPath, callback) {\r\n    var self = this;\r\n    \r\n    self._dropboxClient.move(fromPath, toPath, function(error){\r\n      if (error) {\r\n        return self._showDropboxError(error, callback);\r\n      }\r\n      return callback(false);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Get publicly readable download url for a non-grouping item from Dropbox website.\r\n   * @method getURL\r\n   * @param {String} path the path to the location that the non-grouping item is located\r\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\r\n   *\r\n   * @protected\r\n  */\r\n  ItemDriver.prototype.getURL = function (path, callback){\r\n    var self = this;\r\n    \r\n    self._dropboxClient.makeUrl(path, null, function (error, publicURL){\r\n        if (error) {\r\n          return self._showDropboxError(error, callback);\r\n        }\r\n         return callback(false, publicURL.url);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Lists the items under the grouping item\r\n   * @method listItems\r\n   * @param {String} path the path to the grouping item\r\n   * @param {Function} callback(output) Function to be called when self function is finished with it's operation. Output is an array of AssociationEditors.\r\n   *\r\n   * @protected\r\n   */\r\n  ItemDriver.prototype.listItems = function (parentURI, callback) {\r\n    var self = this;\r\n\r\n    var query = '\\'' + parentURI + '\\' in ' + 'parents';\r\n    var request = this.clientInterface.client.drive.files.list({\r\n      'maxResults': 1000,\r\n      'q': query\r\n    });\r\n    request.execute(function(resp) {\r\n      if (resp.error) {\r\n        return callback('Error: Bad Response / Request');  \r\n      }\r\n\r\n      var items = resp.items.filter(function(item) {\r\n        return item.title !== XooMLConfig.xooMLFragmentFileName;\r\n      })\r\n      .map(function(item) {\r\n        return new AssociationEditor({\r\n          commonData: {\r\n            // Change this to be the ID of the XooML.xml file eventually\r\n            // Will need another parameter for that\r\n            associatedXooMLFragment: null, \r\n            associatedItem: item.id,\r\n            associatedItemDriver: 'GoogleItemDriver',\r\n            associatedXooMLDriver: 'GoogleXooMLDriver',\r\n            associatedSyncDriver: 'MirrorSyncDriver', \r\n            isGrouping: item.mimeType === self._FOLDER_MIMETYPE,\r\n            localItem: item.id,\r\n            displayText: item.title\r\n          }\r\n        });\r\n      });\r\n\r\n      callback(false, items);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Check if the item is existed\r\n   * @method checkExisted\r\n   * @param {String} path the path to the location that the item is located\r\n   * @param {String} name the name of the item\r\n   * @param {Function} callback(result) Function to be called when self function is finished with it's operation. Result is the bollean value for whether existed.\r\n   *\r\n   * @protected\r\n   */\r\n  ItemDriver.prototype.checkExisted = function(path, callback){\r\n    var self = this, result;\r\n\r\n    self._dropboxClient.stat(path, function (error,stat){\r\n      if (error) {\r\n        return self._showDropboxError(error, callback);\r\n      }\r\n      result = !(error !== null && error.status === 404) || (error === null && stat.isRemoved);\r\n\r\n      return callback(false, result);\r\n    });\r\n  };\r\n\r\nmodule.exports = ItemDriver;\n},{\"./AssociationEditor\":1,\"./XooMLConfig\":6}],4:[function(require,module,exports){\n/**\r\n * ItemMirror represents an Item according to the XooML2 specification.\r\n *\r\n * It can be instantiated using one of the following two cases based on the\r\n * given arguments.\r\n *\r\n * 1. XooMLFragment already exists. Given xooMLFragmentURI and xooMLDriver.\r\n * 2. The XooMLFragment is created from an existing groupingItemURI (e.g., a dropbox folder).\r\n * Given a groupingItemURI, itemDriver, and a xooMLDriver a new itemMirror will be constructed for given groupingItemURI.\r\n *\r\n * Throws NullArgumentException when options is null.\r\n *\r\n * Throws MissingParameterException when options is not null and a required\r\n * argument is missing.\r\n *\r\n * @class ItemMirror\r\n * @constructor\r\n *\r\n * @param {Object} options Data to construct a new ItemMirror with\r\n *\r\n *  @param {String} options.groupingItemURI URI to the grouping item. Required\r\n *                  for all cases.\r\n *\r\n *  @param {String} options.itemDriver Data for the ItemDriver to\r\n *                  construct ItemMirror with. Required for cases 2 & 3\r\n *                  Can contain any amount of optional key/value pairs for\r\n *                  the various Driver implementations.\r\n *   @param {String} options.itemDriver.driverURI URI of the driver.\r\n *\r\n *  @param {String} options.xooMLDriver Data for the XooMLDriver to\r\n *                  construct ItemMirror with. Required for all cases.\r\n *                  Can contain any amount of optional key/value pairs for\r\n *                  the various Driver implementations.\r\n *   @param {String} options.xooMLDriver.driverURI URI of the driver.\r\n *\r\n *  @param {String} options.syncDriver Data for the SyncDriver to\r\n *                  construct ItemMirror with. Required Case 2 & 3. Can\r\n *                  contain any amount of optional key/value pairs for\r\n *                  the various Driver implementations.\r\n *   @param {String} options.syncDriver.driverURI URI of the driver.\r\n *\r\n *  @param {Boolean} options.readIfExists True if ItemMirror\r\n *                   should create an ItemMirror if it does not exist,\r\n *                   else false. Required for Case 2 & 3.\r\n *\r\n *  @param {ItemMirror} options.creator If being created from another\r\n *  itemMirror, specifies that itemMirror which it comes from.\r\n *\r\n * @param {Function} callback Function to execute once finished.\r\n *  @param {Object}   callback.error Null if no error has occurred\r\n *                    in executing this function, else an contains\r\n *                    an object with the error that occurred.\r\n *  @param {ItemMirror} callback.itemMirror Newly constructed ItemMirror\r\n */\r\n\r\n'use strict'\r\n\r\nvar XooMLExceptions = require('./XooMLExceptions');\r\nvar XooMLUtil = require('./XooMLUtil');\r\nvar XooMLDriver = require('./XooMLDriver');\r\nvar ItemDriver = require('./ItemDriver');\r\nvar SyncDriver = require('./SyncDriver');\r\nvar FragmentEditor = require('./FragmentEditor');\r\nvar AssociationEditor = require('./AssociationEditor');\r\n\r\n    function ItemMirror(options, callback) {\r\n    XooMLUtil.checkCallback(callback);\r\n    if (!options) {\r\n      return callback(XooMLExceptions.nullArgument);\r\n    }\r\n    if (!XooMLUtil.isObject(options)) {\r\n      return callback(XooMLExceptions.invalidType);\r\n    }\r\n\r\n   var self = this, xooMLFragmentURI, displayName;\r\n\r\n   this._xooMLDriverClient = options.xooMLDriver.clientInterface;\r\n   this._itemDriverClient = options.xooMLDriver.clientInterface;\r\n\r\n    // private variables\r\n    self._xooMLDriver = null;\r\n    self._itemDriver = null;\r\n    self._syncDriver = null;\r\n    self._creator = options.creator || null;\r\n    self._groupingItemURI = options.groupingItemURI;\r\n    self._newItemMirrorOptions = options;\r\n\r\n    // displayName for the fragment\r\n    // It may make more sense to set this later once we have the drivers loaded\r\n    // displayName = this._xooMLDriver.getDisplayName();\r\n    displayName = 'TBD';\r\n\r\n    self.fragmentURI = options.fragmentURI || null;\r\n    options.xooMLDriver.fragmentURI = xooMLFragmentURI;\r\n\r\n    // First load the XooML Driver\r\n    new XooMLDriver(options.xooMLDriver, loadXooMLDriver);\r\n\r\n    function loadXooMLDriver(error, driver) {\r\n      if (error) return callback(error);\r\n\r\n      self._xooMLDriver = driver; // actually sets the XooMLDriver\r\n\r\n      self._xooMLDriver.getXooMLFragment(processXooML);\r\n    }\r\n\r\n    function processXooML(error, fragmentString) {\r\n      // Case 2: Since the fragment doesn't exist, we need\r\n      // to construct it by using the itemDriver\r\n      if (error === 'XooML Not Found') {\r\n        new ItemDriver(options.itemDriver, createFromItemDriver);\r\n      } else if (error) {\r\n        return callback(error);\r\n      }\r\n\r\n      // Case 1: It already exists, and so all of the information\r\n      // can be constructed from the saved fragment\r\n      else {\r\n        createFromXML(fragmentString);\r\n      }\r\n    }\r\n\r\n    function createFromXML(fragmentString) {\r\n      self._fragment = new FragmentEditor({text: fragmentString});\r\n\r\n      new ItemDriver(options.itemDriver, function(error, driver) {\r\n        if (error) return callback(error);\r\n        self._itemDriver = driver;\r\n\r\n        self._syncDriver = new SyncDriver(self);\r\n\r\n        // Do a refresh in case something has been added or deleted in\r\n        // the directory since the last write\r\n        self.refresh(function() {\r\n          return callback(false, self);\r\n        });\r\n      });\r\n    }\r\n\r\n    function createFromItemDriver(error, driver) {\r\n      self._itemDriver = driver;\r\n\r\n      self._itemDriver.listItems(self._groupingItemURI, buildFragment);\r\n    }\r\n\r\n    function buildFragment(error, associations){\r\n      if (error) return callback(error);\r\n\r\n      self._fragment = new FragmentEditor({\r\n        commonData: {\r\n          itemDescribed: self._groupingItemURI,\r\n          displayName: displayName,\r\n          itemDriver: \"dropboxItemDriver\",\r\n          xooMLDriver: \"dropboxXooMLDriver\",\r\n          syncDriver: \"itemMirrorSyncUtility\"\r\n        },\r\n        associations: associations\r\n      });\r\n\r\n      self._syncDriver = new SyncDriver(self);\r\n\r\n      // Because the fragment is being built from scratch, it's safe\r\n      // to save it directly via the driver.\r\n      self._xooMLDriver.setXooMLFragment(self._fragment.toString(), function(error) {\r\n        if (error) {\r\n          throw new Error(error);\r\n        }\r\n      });\r\n\r\n      return callback(false, self);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @method getDisplayName\r\n   * @return {String} The display name of the fragment.\r\n   */\r\n  ItemMirror.prototype.getDisplayName = function() {\r\n    return this._fragment.commonData.displayName;\r\n  };\r\n\r\n  /**\r\n   * @method setDisplayName\r\n   * @param {String} name The display text to set for the fragment\r\n   */\r\n  ItemMirror.prototype.setDisplayName = function(name) {\r\n    this._fragment.commonData.displayName = name;\r\n  };\r\n\r\n  /**\r\n   *\r\n   * @method getSchemaVersion\r\n   * @return {String} XooML schema version.\r\n   */\r\n  ItemMirror.prototype.getSchemaVersion = function() {\r\n    return this._fragment.commonData.schemaVersion;\r\n  };\r\n\r\n  /**\r\n   *\r\n   * @method getSchemaLocation\r\n   * @return {String} XooML schema location.\r\n   */\r\n  ItemMirror.prototype.getSchemaLocation = function() {\r\n    return this._fragment.commonData.schemaLocation;\r\n  };\r\n\r\n  /**\r\n   * Returns URI pointing to item described by the metadata of a fragment. A URI\r\n   * might point to just about anything that can be interpreted as a grouping\r\n   * item. For example: a conventional file system folder or a tag as\r\n   * supported by any of several applications.\r\n   *\r\n   * @method getURIforItemDescribed\r\n   * @return {String} A URI pointing to item described by the metadata\r\n   * of a fragment if it exists, else returns null.\r\n   *\r\n   */\r\n  ItemMirror.prototype.getURIforItemDescribed = function() {\r\n    return this._fragment.commonData.itemDescribed;\r\n  };\r\n\r\n  /**\r\n   * Throws NullArgumentException if GUID is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   *\r\n   * @method getAssociationDisplayText\r\n   * @return {String} The display text for the association with the given GUID.\r\n   *\r\n   * @param {String} GUID GUID representing the desired association.\r\n   */\r\n    ItemMirror.prototype.getAssociationDisplayText = function(GUID) {\r\n    return this._fragment.associations[GUID].commonData.displayText;\r\n  };\r\n\r\n  /**\r\n   * Sets the display text for the association with the given GUID.\r\n   *\r\n   * Throws NullArgumentException if GUID or displayName is null. <br/>\r\n   * Throws InvalidTypeException if GUID or displayName is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method setAssociationDisplayText\r\n   *\r\n   * @param {String}   GUID        GUID of the association to set.\r\n   * @param {String}   displayText Display text to be set.\r\n   */\r\n    ItemMirror.prototype.setAssociationDisplayText = function(GUID, displayText) {\r\n    this._fragment.associations[GUID].commonData.displayText = displayText;\r\n  };\r\n\r\n  /**\r\n   * Throws NullArgumentException if GUID is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method getAssociationLocalItem\r\n   * @return {String} The local item for the association with the given GUID.\r\n   *\r\n   * @param {String} GUID GUID of the association to get.\r\n   */\r\n    ItemMirror.prototype.getAssociationLocalItem = function(GUID) {\r\n    return this._fragment.associations[GUID].commonData.localItem;\r\n  };\r\n\r\n  /**\r\n   * Throws NullArgumentException if GUID is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method getAssociationAssociatedItem\r\n   * @return {String} The associated item for the association with the given GUID.\r\n   * @param {String} GUID GUID of the association to get.\r\n   */\r\n    ItemMirror.prototype.getAssociationAssociatedItem = function(GUID) {\r\n    return this._fragment.associations[GUID].commonData.associatedItem;\r\n  };\r\n\r\n  /**\r\n   * @method getFragmentNamespaceAttribute\r\n   * @return {String} Returns the value of the given attributeName for the\r\n   * fragmentNamespaceData with the given namespaceURI.\r\n   * @param {String} attributeName Name of the attribute to be returned.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  ItemMirror.prototype.getFragmentNamespaceAttribute = function(attributeName, uri) {\r\n    var ns = this._fragment.namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    return this._fragment.namespace[uri].attributes[attributeName];\r\n  };\r\n\r\n  /**\r\n   * Sets the value of the given attributeName with the given attributeValue\r\n   * for the fragmentNamespaceData with the given namespaceURI.\r\n   *\r\n   * Throws NullArgumentException if attributeName, attributeValue, or\r\n   * namespaceURI is null. <br/>\r\n   * Throws InvalidTypeException if attributeName, attributeValue, or\r\n   * namespaceURI is not a String. <br/>\r\n   *\r\n   * @method setFragmentNamespaceAttribute\r\n   * @param {String} attributeName  Name of the attribute to be set.\r\n   * @param {String} attributeValue Value of the attribute to be set.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  ItemMirror.prototype.setFragmentNamespaceAttribute = function(attributeName, attributeValue, uri) {\r\n    var ns = this._fragment.namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    this._fragment.namespace[uri].attributes[attributeName] = attributeValue;\r\n  };\r\n\r\n  /**\r\n   * Adds the given attributeName to the fragment's current namespace\r\n   *\r\n   * Throws an InvalidStateException when the attribute already exists\r\n   *\r\n   * @method addFragmentNamespaceAttribute\r\n   *\r\n   * @param {String} attributeName Name of the attribute.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  // TODO: Possibly remove? Why not just get and set\r\n  ItemMirror.prototype.addFragmentNamespaceAttribute = function(attributeName, uri) {\r\n    var ns = this._fragment.namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    if (this._fragment.namespace[uri].attributes[attributeName]) {\r\n      throw XooMLExceptions.invalidState;\r\n    }\r\n    this.setFragmentNamespaceAttribute(attributeName, uri);\r\n  };\r\n\r\n  /**\r\n   * Removes the fragment namespace attribute with the given namespaceURI.\r\n   *\r\n   * Throws NullArgumentException if attributeName, or namespaceURI is\r\n   * null. <br/>\r\n   * Throws InvalidTypeException if attributeName, or namespaceURI is not\r\n   * a String. <br/>\r\n   * Throws an InvalidStateException when the given attributeName is not an\r\n   * attribute. <br/>\r\n   *\r\n   * @method removeFragmentNamespaceAttribute\r\n   * @param {String} attributeName Name of the attribute.\r\n   * @param {String} uri  Namespace URI\r\n   *\r\n   */\r\n  ItemMirror.prototype.removeFragmentNamespaceAttribute = function(attributeName, uri) {\r\n    delete this._fragment.namespace[uri].attributes[attributeName];\r\n  };\r\n\r\n  /**\r\n   * Checks if the fragment has the given namespaceURI.\r\n   *\r\n   * Currently cannot find a way to list the namespaces (no DOM\r\n   * standard method for doing so). So this fuction will ALWAYS RETURN\r\n   * FALSE for now.\r\n   *\r\n   * @method hasFragmentNamespace\r\n   * @return {Boolean} True if the fragment has the given\r\n   * namespaceURI, otherwise false.\r\n   *\r\n   * @param {String} uri URI of the namespace for the association.\r\n   *\r\n   */\r\n  ItemMirror.prototype.hasFragmentNamespace = function (uri) {\r\n    var namespace = this._fragment.namespace[uri];\r\n    if (namespace) { return true; }\r\n    else { return false; }\r\n  };\r\n\r\n  /**\r\n   * @method listFragmentNamespaceAttributes\r\n   * @return {String[]} An array of the attributes within the\r\n   * fragmentNamespaceData with the given namespaceURI.\r\n   * @param {String} uri Namespace URI\r\n   *\r\n  */\r\n  ItemMirror.prototype.listFragmentNamespaceAttributes = function(uri) {\r\n    return Object.keys(this._fragment.namespace[uri].attributes);\r\n  };\r\n\r\n  /**\r\n   * @method getFragmentNamespaceData\r\n   * @return {String} The fragment namespace data with the given namespace URI.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  ItemMirror.prototype.getFragmentNamespaceData = function(uri) {\r\n    return this._fragment.namespace[uri].data;\r\n  };\r\n\r\n  /**\r\n   * Sets the fragment namespace data with the given namespaceURI.\r\n   *\r\n   * @method setFragmentNamespaceData\r\n   *\r\n   * @param {String} data Fragment namespace data to be set.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  ItemMirror.prototype.setFragmentNamespaceData = function (data, uri) {\r\n    var ns = this._fragment.namespace;\r\n    ns[uri] = ns[uri] || {};\r\n\r\n    this._fragment.namespace[uri].data = data;\r\n  };\r\n\r\n  /**\r\n   * Creates an ItemMirror from the associated grouping item represented by\r\n   * the given GUID.\r\n   *\r\n   * Throws NullArgumentException if GUID or callback is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a string, and callback is\r\n   * not a function. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method createItemMirrorForAssociatedGroupingItem\r\n   * @return {ItemMirror} Possibly return an itemMirror if the GUID is a grouping item\r\n   *\r\n   * @param {String} GUID GUID of the association to create the ItemMirror\r\n   *                 from.\r\n   *\r\n   */\r\n  ItemMirror.prototype.createItemMirrorForAssociatedGroupingItem = function (GUID, callback) {\r\n    var self = this,\r\n        isGrouping,\r\n        xooMLOptions,\r\n        itemOptions,\r\n        syncOptions,\r\n        uri;\r\n\r\n    itemOptions = {\r\n      driverURI: \"GoogleItemUtility\",\r\n      clientInterface: this._itemDriverClient,\r\n      // Note that this needs to be changed, we want to point to the grouping item's id\r\n      associatedItem: self.getAssociationAssociatedItem(GUID)\r\n    };\r\n    xooMLOptions = {\r\n      fragmentURI: uri,\r\n      driverURI: \"GoogleXooMLUtility\",\r\n      clientInterface: this._xooMLDriverClient,\r\n      associatedItem: self.getAssociationAssociatedItem(GUID)\r\n    };\r\n    syncOptions = {\r\n      utilityURI: \"SyncUtility\"\r\n    };\r\n\r\n    isGrouping = self.isAssociationAssociatedItemGrouping(GUID);\r\n    if (!isGrouping) {\r\n      // Need to standardize this error\r\n      return callback(\"Association not grouping, cannot continue\");\r\n    }\r\n\r\n    new ItemMirror(\r\n      {groupingItemURI: self.getAssociationAssociatedItem(GUID),\r\n       xooMLDriver: xooMLOptions,\r\n       itemDriver: itemOptions,\r\n       syncDriver: syncOptions,\r\n       creator: self\r\n      },\r\n      function (error, itemMirror) {\r\n        return callback(error, itemMirror);\r\n      }\r\n    );\r\n  };\r\n\r\n  /**\r\n   * Creates an association based on the given options and the following\r\n   * cases.\r\n   *\r\n   * Cases 1, 2, 7 implemented. All else are not implemented.\r\n   *\r\n   * 1. Simple text association declared phantom. <br/>\r\n   * 2. Link to existing non-grouping item, phantom. This can be a URL <br/>\r\n   * 3. Link to existing non-grouping item, real. <br/>\r\n   * 4. Link to existing grouping item, phantom. <br/>\r\n   * 5. Link to existing grouping item, real. <br/>\r\n   * 6. Create new local non-grouping item. <br/>\r\n   * 7. Create new local grouping item. <br/>\r\n   *\r\n   * Throws NullArgumentException when options, or callback is null. <br/>\r\n   * Throws InvalidTypeException when options is not an object and callback\r\n   * is not a function. <br/>\r\n   * Throws MissingParameterException when an argument is missing for an expected\r\n   * case. <br/>\r\n   *\r\n   * @method createAssociation\r\n   *\r\n   * @param {Object} options Data to create an new association for.\r\n   *\r\n   *  @param {String}  options.displayText Display text for the association.\r\n   *                   Required in all cases.\r\n   *\r\n   *  @param {String}  options.itemURI URI of the item. Required for case 2 & 3. Note: Please ensure \"http://\" prefix exists at the beginning of the string when referencing a Web URL and not an Item.\r\n   *\r\n   *  @param {Boolean} options.localItemRequested True if the local item is\r\n   *                   requested, else false. Required for cases 2 & 3.\r\n   *\r\n   *  @param {String}  options.groupingItemURI URI of the grouping item.\r\n   *                   Required for cases 4 & 5.\r\n   *\r\n   *  @param {String}  options.xooMLDriverURI URI of the XooML driver for the\r\n   *                   association. Required for cases 4 & 5.\r\n   *\r\n   *  @param {String}  options.localItem URI of the new local\r\n   *                   non-grouping/grouping item. Required for cases 6 & 7.\r\n   *\r\n   *  @param {String}  options.isGroupingItem True if the item is a grouping\r\n   *                   item, else false. Required for cases 6 & 7.\r\n   *\r\n   * @param {Function} callback Function to execute once finished.\r\n   *  @param {Object}   callback.error Null if no error has occurred\r\n   *                    in executing this function, else an contains\r\n   *                    an object with the error that occurred.\r\n   *  @param {String}   callback.GUID GUID of the association created.\r\n   */\r\n  ItemMirror.prototype.createAssociation = function (options, callback) {\r\n    var self = this,\r\n        association,\r\n        saveOutFragment;\r\n\r\n    saveOutFragment = function(association){\r\n      var guid = association.commonData.ID;\r\n      // adds the association to the fragment\r\n      self._fragment.associations[guid] = association;\r\n\r\n      // Save changes out the actual XooML Fragment\r\n      self.save( function(error){\r\n        return callback(error, guid);\r\n      });\r\n    };\r\n\r\n    if (!XooMLUtil.isFunction(callback)) {\r\n      throw XooMLExceptions.invalidType;\r\n    }\r\n    if (!XooMLUtil.isObject(options)) {\r\n      return callback(XooMLExceptions.invalidType);\r\n    }\r\n\r\n    // Case 7\r\n    if (options.displayText && options.localItem && options.isGroupingItem) {\r\n      association = new AssociationEditor({\r\n        commonData: {\r\n          displayText: options.displayText,\r\n          isGrouping: true,\r\n          localItem: options.localItem,\r\n          // Changed this part, and need to test folder creation to insure safety\r\n          associatedItem: options.associatedItem\r\n        }\r\n      });\r\n\r\n      // Now we use the itemDriver to actually create the folder\r\n      // NOTE: untested\r\n      self._itemDriver.createGroupingItem(options.displayText, function(error){\r\n        if (error) return callback(error);\r\n\r\n        return saveOutFragment(association);\r\n      });\r\n    }\r\n    // Synchronous cases\r\n    else {\r\n      // Case 2\r\n      if (options.displayText && options.itemURI) {\r\n        association = new AssociationEditor({\r\n          commonData: {\r\n            displayText: options.displayText,\r\n            associatedItem: options.itemURI,\r\n            isGrouping: false\r\n          }\r\n        });\r\n      }\r\n      // Case 1\r\n      else if (options.displayText) {\r\n        association = new AssociationEditor({\r\n          commonData: {\r\n            displayText: options.displayText,\r\n            isGrouping: false\r\n          }\r\n        });\r\n      }\r\n\r\n      return saveOutFragment(association);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @method isAssociationPhantom\r\n   * @param {String} guid\r\n   * @return {Boolean} True if the association of the given GUID is a\r\n   * phantom association. False otherwise.\r\n   */\r\n  ItemMirror.prototype.isAssociationPhantom = function(guid) {\r\n    var data = this._fragment.associations[guid].commonData;\r\n    return !(data.isGrouping || data.localItem);\r\n  };\r\n\r\n  /**\r\n   * Duplicates (copies) an association to another ItemMirror Object (representing a grouping item)\r\n   *\r\n   *\r\n   * Throws NullArgumentException if GUID is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method copyAssociation\r\n   *\r\n   * @param {String} GUID GUID of the association you wish to copy/duplicate\r\n   * @param {ItemMirror} ItemMirror ItemMirror representing the grouping item you want to move the GUID object to\r\n   *\r\n   * @param {Function} callback Function to execute once finished.\r\n   * @param {Object} callback.error Null if no error Null if no error has occurred\r\n   *                 in executing this function, else it contains\r\n   *                 an object with the error that occurred.\r\n   */\r\n   ItemMirror.prototype.copyAssociation = function () {\r\n    throw new Error('Method not implemented');\r\n   };\r\n  /**\r\n   * Moves an association to another ItemMirror Object (representing a grouping item)\r\n   *\r\n   *\r\n   * Throws NullArgumentException if GUID is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method moveAssociation\r\n   *\r\n   * @param {String} GUID GUID of the item you want to paste or move\r\n   * @param {ItemMirror} ItemMirror ItemMirror representing the grouping item you want to move the GUID object to\r\n   *\r\n   * @param {Function} callback Function to execute once finished.\r\n   * @param {Object} callback.error Null if no error Null if no error has occurred\r\n   *                 in executing this function, else it contains\r\n   *                 an object with the error that occurred.\r\n   */\r\n   ItemMirror.prototype.moveAssociation = function () {\r\n    throw new Error('Method not implemented');\r\n   };\r\n\r\n  /**\r\n   * Deletes the association represented by the given GUID.\r\n   *\r\n   * Throws NullArgumentException if GUID is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method deleteAssociation\r\n   *\r\n   * @param GUID {String} GUID of the association to be deleted.\r\n   *\r\n   * @param {Function} callback Function to execute once finished.\r\n   *  @param {Object}   callback.error Null if no error has occurred\r\n   *                    in executing this function, else an contains\r\n   *                    an object with the error that occurred.\r\n   */\r\n  ItemMirror.prototype.deleteAssociation = function (GUID, callback) {\r\n    var self = this;\r\n\r\n    XooMLUtil.checkCallback(callback);\r\n    if (!GUID) {\r\n      return callback(XooMLExceptions.nullArgument);\r\n    }\r\n    if (!XooMLUtil.isGUID(GUID)) {\r\n      return callback(XooMLExceptions.invalidType);\r\n    }\r\n\r\n    // Save to ensure that the fragment is up to date\r\n    return self.save(deleteContent);\r\n\r\n    function deleteContent(error) {\r\n      if (error) return callback(error);\r\n\r\n      var isPhantom = self.isAssociationPhantom(GUID);\r\n\r\n      if (!isPhantom) {\r\n        var isGrouping = self.isAssociationAssociatedItemGrouping(GUID),\r\n            // For dropbox support, path should be the full path that is\r\n            // dynamically generated. Refer to case 39 for implementation\r\n            // details. UNTESTED\r\n            path = self.getAssociationAssociatedItem(GUID);\r\n\r\n        delete self._fragment.associations[GUID];\r\n        if (isGrouping) {\r\n          return self._itemDriver.deleteGroupingItem(path, postDelete);\r\n        } else {\r\n          return self._itemDriver.deleteNonGroupingItem(path, postDelete);\r\n        }\r\n      } else {\r\n        delete self._fragment.associations[GUID];\r\n\r\n        // Now do an unsafe_write to commit the XML. It's okay because\r\n        // save means that everything is synced, and this operation\r\n        // was extremely quick\r\n        return self._unsafeWrite(function(error) {\r\n          if (error) return callback(error);\r\n          else return callback();\r\n        });\r\n      }\r\n    }\r\n\r\n    // Now do a refresh since actual files were removed.\r\n    function postDelete(error) {\r\n      if (error) return callback(error);\r\n\r\n      return self.refresh(function(error) {\r\n        if (error) return callback(error);\r\n        return callback(error);\r\n      });\r\n    }\r\n\r\n  };\r\n\r\n  /**\r\n   * Upgrades a given association without a local item. Local item is named\r\n   * by a truncated form of the display name of this ItemMirror if the\r\n   * localItemURI is not given, else uses given localItemURI. Always\r\n   * truncated to 50 characters.\r\n   *\r\n   * ONLY SUPPORTS SIMPLE PHANTOM ASSOCIATION TO ASSOCIATION WITH GROUPING ITEM\r\n   *\r\n   * Throws NullArgumentException when options is null. <br/>\r\n   * Throws MissingParameterException when options is not null and a required\r\n   * argument is missing.<br/>\r\n   * Throws InvalidTypeException if GUID is not a string, and if callback\r\n   * is not a function. <br/>\r\n   * Throws InvalidState if the association with the given GUID cannot be\r\n   * upgraded. <br/>\r\n   *\r\n   * @method upgradeAssociation\r\n   *\r\n   * @param {Object} options Data to construct a new ItemMirror with\r\n   *\r\n   *  @param {String} options.GUID of the association to be upgraded. Required\r\n   *\r\n   *  @param {String} options.localItemURI URI of the local item to be used if\r\n   *                  a truncated display name is not the intended behavior.\r\n   *                  Optional.\r\n   *\r\n   * @param {Function} callback Function to execute once finished.\r\n   *\r\n   *  @param {String}   callback.error Null if no error has occurred\r\n   *                    in executing this function, else an contains\r\n   *                    an object with the error that occurred.\r\n   */\r\n  ItemMirror.prototype.upgradeAssociation = function () {\r\n    throw new Error('Method not implemented');\r\n  };\r\n\r\n  /**\r\n   * Renames the local item for the association with the given GUID.\r\n   *\r\n   * Throws NullArgumentException if GUID, callback is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a String, and if callback\r\n   * is not a function. <br/>\r\n   *\r\n   * @method renameAssocaitionLocalItem\r\n   *\r\n   * @param {String} GUID GUID of the association.\r\n   * @param {String} String String Name you want to rename the file to (including file extension)\r\n   * @param {Function} callback Function to execute once finished.\r\n   *  @param {Object}   callback.error Null if no error has occurred\r\n   *                    in executing this function, else an contains\r\n   *                    an object with the error that occurred.\r\n   * @param {String} callback.GUID The GUID of the association that was updated.\r\n   */\r\n  ItemMirror.prototype.renameAssociationLocalItem = function (GUID, newName, callback) {\r\n    // This method needs a redesign, and can't be properly implemented the way\r\n    // it is now. Instead, this needs to pass information to the acual item\r\n    // driver and that needs to implement an agnostic new name format. This\r\n    // path stuff is specific to dropbox and doesn't work\r\n    var self = this;\r\n    XooMLUtil.checkCallback(callback);\r\n    if (!GUID) {\r\n      return callback(XooMLExceptions.nullArgument);\r\n    }\r\n    if (!XooMLUtil.isGUID(GUID)) {\r\n      return callback(XooMLExceptions.invalidType);\r\n    }\r\n\r\n    self.save(postSave);\r\n\r\n    function postSave(error) {\r\n      if (error) return callback(error);\r\n\r\n      // This stuff needs to be replaced with a method that works for all stores\r\n          // oldPath = PathDriver.joinPath(self._groupingItemURI, localItem),\r\n          // newPath = PathDriver.joinPath(self._groupingItemURI, newName);\r\n\r\n      self._itemDriver.rename(newName, postMove);\r\n    }\r\n\r\n    function postMove(error) {\r\n      if (error) return callback(error);\r\n      // This also needs to be more agnostic\r\n      self._fragment.associations[GUID].commonData.localItem = newName;\r\n\r\n      self._unsafeWrite(postWrite);\r\n    }\r\n\r\n    function postWrite(error) {\r\n      if (error) return callback(error);\r\n\r\n      self.refresh(postRefresh);\r\n    }\r\n\r\n    function postRefresh(error) {\r\n      return callback(error, self._fragment.associations[GUID].commonData.ID);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * A special method that is used for certain file operations where\r\n   * calling a sync won't work. Essentially it is the save function,\r\n   * sans syncing. This should __never__ be called be an application.\r\n   * @method _unsafeWrite\r\n   * @param callback\r\n   * @param calback.error\r\n   */\r\n  ItemMirror.prototype._unsafeWrite = function(callback) {\r\n    var self = this;\r\n\r\n    // Note (12/8/2015) This was never used, but seems like it has purpose. May need to investigate\r\n    //var tmpFragment = new FragmentEditor({text: content});\r\n    self._fragment.updateID();\r\n    return self._xooMLDriver.setXooMLFragment(self._fragment.toString(), function(error) {\r\n      if (error) return callback(error);\r\n      return callback(false);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Checks if an association's associatedItem is a grouping item\r\n   *\r\n   * Throws NullArgumentException if GUID, callback is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a String, and if callback\r\n   * is not an function. <br/>\r\n   *\r\n   * @method isAssociationAssociatedItemGrouping\r\n   * @return {Boolean} True if the association with the given GUID's associatedItem is a grouping\r\n   * item, otherwise false.\r\n   *\r\n   * @param GUID {String} GUID of the association to be to be checked.\r\n   *\r\n   */\r\n  ItemMirror.prototype.isAssociationAssociatedItemGrouping = function(GUID) {\r\n    return this._fragment.associations[GUID].commonData.isGrouping;\r\n  };\r\n\r\n  /**\r\n   * Lists the GUIDs of each association.\r\n   *\r\n   * @method listAssociations\r\n   *\r\n   * @return {String[]} Array of the GUIDs of each association\r\n   */\r\n  ItemMirror.prototype.listAssociations = function() {\r\n    return Object.keys(this._fragment.associations);\r\n  };\r\n\r\n  /**\r\n   *\r\n   * Throws NullArgumentException if attributeName, GUID, or namespaceURI is\r\n   * null. <br/>\r\n   * Throws InvalidTypeException if attributeName, GUID, or namespaceURI is not\r\n   * a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method getAssociationNamespaceAttribute\r\n   * @return {String} The association namespace attribute with\r\n   * the given attributeName and the given namespaceURI within the\r\n   * association with the given GUID.\r\n   *\r\n   * @param {String} attributeName Name of the attribute to be returned.\r\n   * @param {String} GUID          GUID of the association to return attribute from.\r\n   * @param {String} uri Namspace URI\r\n   *\r\n   */\r\n  ItemMirror.prototype.getAssociationNamespaceAttribute = function(attributeName, GUID, uri) {\r\n    var ns = this._fragment.associations[GUID].namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    return this._fragment.associations[GUID].namespace[uri].attributes[attributeName];\r\n  };\r\n\r\n  /**\r\n   * Sets the association namespace attribute with the given attributeName\r\n   * and the given namespaceURI within the association with the given GUID.\r\n   *\r\n   * Throws NullArgumentException if attributeName, attributeValue, GUID, or\r\n   * namespaceURI is null. <br/>\r\n   * Throws InvalidTypeException if attributeName, attributeValue, GUID, or\r\n   * namespaceURI is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method setAssociationNamespaceAttribute\r\n   *\r\n   * @param {String} attributeName  Name of the attribute to be set.\r\n   * @param {String} attributeValue Value of the attribute to be set\r\n   * @param {String} GUID           GUID of association to set attribute for.\r\n   * @param {String} uri Namespace URI\r\n   *\r\n   */\r\n  ItemMirror.prototype.setAssociationNamespaceAttribute = function(attributeName, attributeValue, GUID, uri) {\r\n    var ns = this._fragment.associations[GUID].namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    this._fragment.associations[GUID].namespace[uri].attributes[attributeName] = attributeValue;\r\n  };\r\n\r\n  /**\r\n   * Adds the given attributeName to the association with the given GUID and\r\n   * namespaceURI.\r\n   *\r\n   * Throws NullArgumentException if attributeName, GUID, or namespaceURI is\r\n   * null. <br/>\r\n   * Throws InvalidTypeException if attributeName, GUID, or namespaceURI is not\r\n   * a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   * Throws an InvalidStateException when the given attributeName has already\r\n   * been added. <br/>\r\n   *\r\n   * @method addAssociationNamespaceAttribute\r\n   *\r\n   * @param {String} attributeName Name of the attribute.\r\n   * @param {String} attributeValue Value of the attribe to be set\r\n   * @param {String} GUID          GUID of the association.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  ItemMirror.prototype.addAssociationNamespaceAttribute = function(attributeName, attributeValue, GUID, uri) {\r\n    var ns = this._fragment.associations[GUID].namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    if (this._fragment.associations[GUID].namespace[uri].attributes[attributeName]) {\r\n      throw XooMLExceptions.invalidState;\r\n    }\r\n    this.setAssociationNamespaceAttribute(attributeName, attributeValue, GUID, uri);\r\n  };\r\n\r\n  /**\r\n   * Removes the given attributeName to the association with the given GUID and\r\n   * namespaceURI.\r\n   *\r\n   * Throws NullArgumentException if attributeName, GUID, or namespaceURI is\r\n   * null. <br/>\r\n   * Throws InvalidTypeException if attributeName, GUID, or namespaceURI is not\r\n   * a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   * Throws an InvalidStateException when the given attributeName is not an\r\n   * attribute. <br/>\r\n   *\r\n   * @method removeAssociationNamespaceAttribute\r\n   *\r\n   * @param {String} attributeName Name of the attribute.\r\n   * @param {String} GUID          GUID of the association.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  ItemMirror.prototype.removeAssociationNamespaceAttribute = function(attributeName, GUID, uri) {\r\n    delete this._fragment.associations[GUID].namespace[uri].attributes[attributeName];\r\n  };\r\n\r\n  /**\r\n   * @method hasAssociationNamespace\r\n   * @return {Boolean} True if the association has the given\r\n   * namespaceURI, else false.\r\n   *\r\n   * @param {String} GUID          GUID of the association.\r\n   * @param {String} uri  Namespace URI\r\n   *\r\n   */\r\n  ItemMirror.prototype.hasAssociationNamespace = function(GUID, uri) {\r\n    var namespace = this._fragment.associations[GUID].namespace[uri];\r\n    if (namespace) { return true; }\r\n    else { return false; }\r\n  };\r\n\r\n  /**\r\n   *\r\n   * Throws NullArgumentException if GUID, namespaceURI is null. <br/>\r\n   * Throws InvalidTypeException if GUID, namespaceURI is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method listAssociationNamespaceAttributes\r\n   * @return {String[]} An array of the association namespace\r\n   * attributes with the given attributeName and the given\r\n   * namespaceURI within the association with the given GUID.\r\n   *\r\n   * @param {String} GUID          GUID of association to list attributes for.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  ItemMirror.prototype.listAssociationNamespaceAttributes = function (GUID, uri) {\r\n    var ns = this._fragment.associations[GUID].namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    return Object.keys(this._fragment.associations[GUID].namespace[uri].attributes);\r\n  };\r\n\r\n  /**\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method getAssociationNamespaceData\r\n   * @return {String} The association namespace data for an\r\n   * association with the given GUID and the given namespaceURI.\r\n   *\r\n   * @param {String} GUID GUID of the association namespace data to\r\n   * returned.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  self.getAssociationNamespaceData = function (GUID, uri) {\r\n    var ns = this._fragment.associations[GUID].namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    return this._fragment.associations[GUID].namespace[uri].data;\r\n  };\r\n\r\n  /**\r\n   * Sets the association namespace data for an association with the given GUID\r\n   * and given namespaceURI using the given data.\r\n   *\r\n   * Throws NullArgumentException if data, GUID, or namespaceURI is null. <br/>\r\n   * Throws InvalidTypeException if data, GUID, or namespaceURI is not a\r\n   * String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method setAssociationNamespaceData\r\n   *\r\n   * @param {String} data          Association namespace data to set. Must be\r\n   *                               valid fragmentNamespaceData.\r\n   * @param {String} GUID          GUID of the association namespace data to set.\r\n   */\r\n  ItemMirror.prototype.setAssociationNamespaceData = function (data, GUID, uri) {\r\n    var ns = this._fragment.associations[GUID].namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    this._fragment.associations[GUID].namespace[uri].data = data;\r\n  };\r\n\r\n  /**\r\n   * Uses the specified ItemDriver and SyncDriver to synchronize the\r\n   * local ItemMirror object changes. This is an implmentation of Synchronization\r\n   * Driver which modifies the XooML Fragment according to the real structure\r\n   * under the item described.\r\n   *\r\n   * @method sync\r\n   *\r\n   * @param {Function} callback Function to execute once finished.\r\n   *  @param {Object}   callback.error Null if no error has occurred\r\n   *                    in executing this function, else an contains\r\n   *                    an object with the error that occurred.\r\n   * @private\r\n   */\r\n  ItemMirror.prototype._sync = function (callback) {\r\n    var self = this;\r\n\r\n    self._syncDriver.sync(callback);\r\n  };\r\n\r\n  /**\r\n   * Reloads the XooML Fragment\r\n   *\r\n   * @method refresh\r\n   *\r\n   * @param {Function} callback Function to execute once finished.\r\n   *  @param {Object}   callback.error Null if no error has occurred\r\n   *                    in executing this function, else an contains\r\n   *                    an object with the error that occurred.\r\n   */\r\n  ItemMirror.prototype.refresh = function(callback) {\r\n    var self = this;\r\n\r\n    self._sync( function(error) {\r\n      // This error means that sync changed the fragment\r\n      // We then will reload the fragment based on the new XooML\r\n      if (error === XooMLExceptions.itemMirrorNotCurrent) {\r\n        self._xooMLDriver.getXooMLFragment(resetFragment);\r\n      } else if (error) {\r\n        callback(error);\r\n      } else {\r\n        self._xooMLDriver.getXooMLFragment(resetFragment);\r\n      }\r\n    });\r\n\r\n    function resetFragment(error, content){\r\n      if (error) return callback(error);\r\n\r\n      self._fragment = new FragmentEditor({text: content});\r\n      return callback(false);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @method getCreator\r\n   *\r\n   * @return {Object} The itemMirror that created this current\r\n   * itemMirror, if it has one. Note that this isn't the same as\r\n   * asking for a 'parent,' since multiple itemMirrors can possibly\r\n   * link to the same one\r\n   *\r\n   */\r\n  ItemMirror.prototype.getCreator = function () {\r\n    return this._creator;\r\n  };\r\n\r\n\r\n  /**\r\n   * Saves the itemMirror object, writing it out to the\r\n   * fragment. Fails if the GUID generated on last write for the\r\n   * itemMirror and the XooML fragment don't match.\r\n   *\r\n   * @method save\r\n   *\r\n   * @param callback\r\n   *  @param callback.error Returns false if everything went ok,\r\n   *  otherwise returns the error\r\n   */\r\n  ItemMirror.prototype.save = function(callback) {\r\n    var self = this;\r\n\r\n    self._sync(postSync);\r\n\r\n    function postSync(error) {\r\n      if (error) return callback(error);\r\n\r\n      return self._unsafeWrite(postWrite);\r\n    }\r\n\r\n    function postWrite(error) {\r\n      return callback(error);\r\n    }\r\n  };\r\n\r\n/**\r\n * Checks if the AssociatedItem String passed into it is a URL or not.\r\n *\r\n * @method _isURL\r\n * @return {Boolean} True if it is an HTTP URL, false otherwise\r\n * (HTTPS will fail)\r\n * @private\r\n * @param {String} URL\r\n */\r\n  self._isURL = function (URL){\r\n    return /^http:\\/\\//.exec(URL);\r\n  };\r\n\r\n\r\n// This makes the pacakge accessible as a node module\r\nmodule.exports = ItemMirror;\r\n\r\n// This attaches the library as a global if it doesn't already exist\r\nif (window) { // Checks for window object so we don't break potential node usage\r\n  window.ItemMirror = window.ItemMirror || ItemMirror\r\n}\n},{\"./AssociationEditor\":1,\"./FragmentEditor\":2,\"./ItemDriver\":3,\"./SyncDriver\":5,\"./XooMLDriver\":7,\"./XooMLExceptions\":8,\"./XooMLUtil\":9}],5:[function(require,module,exports){\n/**\r\n * An implementation of SyncDriver which syncronizes the XooML so that\r\n * it reflects the storage. This implementation ensures that only the\r\n * XooML is modified, and that the user's storage is never modified,\r\n * safely protecting any data.\r\n *\r\n * For ItemMirror core developers only. Enable protected to see.\r\n *\r\n * @class SyncDriver\r\n *\r\n * @constructor\r\n * @param {Object} itemMirror The itemMirror object which you wish to\r\n * synchronize\r\n *\r\n * @protected\r\n */\r\n\r\n\r\n'use strict'\r\n\r\nvar XooMLExceptions = require('./XooMLExceptions');\r\nvar XooMLConfig = require('./XooMLConfig');\r\nvar XooMLUtil = require('./XooMLUtil');\r\nvar FragmentEditor = require('./FragmentEditor');\r\nvar AssociationEditor = require('./AssociationEditor');\r\nvar XooMLExceptions = require('./XooMLExceptions');\r\n\r\n\r\n  var self;\r\n\r\n  function SyncDriver(itemMirror) {\r\n    var self = this;\r\n    self._itemMirror = itemMirror;\r\n    self._itemDriver = itemMirror._itemDriver;\r\n    self._xooMLDriver = itemMirror._xooMLDriver;\r\n\r\n\r\n  }\r\n\r\n  /**\r\n   * Helper method that allows for sorting of objects by the localItem\r\n   *\r\n   * @method _nameCompare\r\n   * @private\r\n   * @protected\r\n   */\r\n  function _localItemCompare(a, b) {\r\n    if (a.commonData.localItem > b.commonData.localItem) return 1;\r\n    else if (a.commonData.localItem < b.commonData.localItem) return -1;\r\n    else return 0;\r\n  }\r\n\r\n  /**\r\n   * Synchonizes the itemMirror object.\r\n   *\r\n   * @method sync\r\n   *\r\n   * @param {Function} callback Function to execute once finished.\r\n   *  @param {Object}   callback.error Null if no error has occurred\r\n   *                    in executing this function, else an contains\r\n   *                    an object with the error that occurred.\r\n   *\r\n   * @protected\r\n   */\r\n  SyncDriver.prototype.sync = function(callback) {\r\n    var self = this,\r\n        itemAssociations;\r\n\r\n    self._itemDriver.listItems(self._itemMirror._groupingItemURI,\r\n                               processItems);\r\n\r\n    function processItems(error, associations){\r\n      if (error) return callback(error);\r\n\r\n      itemAssociations = associations;\r\n      self._xooMLDriver.getXooMLFragment(processXooML);\r\n    }\r\n\r\n    function processXooML(error, xooMLContent) {\r\n      // A 404 error is dropbox telling us that the file doesn't\r\n      // exist. In that case we just write the file\r\n      if (error === 404) {\r\n        var fragmentString = self._itemMirror._fragment.toString();\r\n        return self._xooMLDriver.setXooMLFragment( fragmentString, function(error) {\r\n          if (error) callback(error);\r\n          else callback(false);\r\n        });\r\n      } else if (error) {\r\n        return callback(error);\r\n      }\r\n\r\n      // Keeps track of the index in the xooMLassociations so that\r\n      // we don't waste time searching from the beginning\r\n      var xooMLIdx = 0;\r\n      // Keeps track of whether there are any changes that need to be made\r\n      var synchronized = true;\r\n      var xooMLAssociations;\r\n\r\n      self._fragmentEditor = new FragmentEditor({text: xooMLContent});\r\n\r\n      xooMLAssociations = Object.keys(self._fragmentEditor.associations)\r\n      // Turns the associative array into a regular array for iteration\r\n        .map( function(guid) {\r\n          return self._fragmentEditor.associations[guid];\r\n        })\r\n      // filters out any phantoms\r\n\t.filter( function(assoc) {\r\n\t  return assoc.commonData.localItem !== null;\r\n\t});\r\n\r\n      // No guarantee that the storage API sends results sorted\r\n      itemAssociations.sort(_localItemCompare);\r\n      xooMLAssociations.sort(_localItemCompare);\r\n\r\n      // Gets the localItems in a separate array, but in needed sorted order\r\n      var itemLocals = itemAssociations.map( function (assoc) {return assoc.commonData.localItem;} );\r\n      var xooMLLocals = xooMLAssociations.map( function (assoc) {return assoc.commonData.localItem;} );\r\n\r\n      itemLocals.forEach( function(localItem, itemIdx) {\r\n\tvar search = xooMLLocals.lastIndexOf(localItem, xooMLIdx);\r\n\t// Create association\r\n\tif (search === -1) {\r\n\t  synchronized = false;\r\n\t  // Case 6/7 only, other cases won't be handled\r\n          var association = itemAssociations[itemIdx];\r\n          self._fragmentEditor.associations[association.commonData.ID] = association;\r\n\t} else {\r\n\t  // Deletes any extraneous associations\r\n\t  xooMLAssociations\r\n\t    .slice(xooMLIdx, search)\r\n\t    .forEach( function(assoc) {\r\n\t      synchronized = false;\r\n              delete self._fragmentEditor.associations[assoc.guid];\r\n\t    });\r\n\t  xooMLIdx = search + 1;\r\n\t}\r\n      });\r\n      // Any remaining associations need to be deleted because they don't exist\r\n      xooMLAssociations\r\n\t.slice(xooMLIdx, xooMLLocals.length)\r\n\t.forEach( function(assoc) {\r\n\t  synchronized = false;\r\n          delete self._fragmentEditor.associations[assoc.commonData.ID];\r\n\t});\r\n\r\n      // Only save fragment if needed\r\n      if (!synchronized) {\r\n        self._fragmentEditor.updateID(); // generate a new guid for GUIDGeneratedOnLastWrite;\r\n        // Writes out the fragment\r\n        self._xooMLDriver.setXooMLFragment(self._fragmentEditor.toString(), function(error) {\r\n          if (error) return callback(error);\r\n\r\n          return callback(false);\r\n        });\r\n      } else return callback(false);\r\n    }\r\n  };\r\n\r\nmodule.exports = SyncDriver;\n},{\"./AssociationEditor\":1,\"./FragmentEditor\":2,\"./XooMLConfig\":6,\"./XooMLExceptions\":8,\"./XooMLUtil\":9}],6:[function(require,module,exports){\n/**\r\n * Configuration variables for XooML.js\r\n *\r\n * For ItemMirror core developers only. Enable protected to see.\r\n *\r\n * @class XooMLConfig\r\n * @static\r\n *\r\n * @protected\r\n */\r\nmodule.exports = {\r\n  // default schema version\r\n  schemaVersion: \"0.54\",\r\n\r\n  // default schema location\r\n  schemaLocation: \"http://kftf.ischool.washington.edu/xmlns/xooml\",\r\n\r\n  // XooMLFragment file name for XooML2.xmlns\r\n  xooMLFragmentFileName: \"XooML2.xml\",\r\n\r\n  // Maximum file length for upgradeAssociation localItemURI truncation\r\n  maxFileLength: 50,\r\n\r\n  // Case 1\r\n  createAssociationSimple: {\r\n    \"displayText\": true\r\n  },\r\n\r\n  // Case 2 and 3\r\n  // localItemRequested exists:> case 3\r\n  createAssociationLinkNonGrouping: {\r\n    \"displayText\": true,        // String\r\n    \"itemURI\": true,            // String\r\n    \"localItemRequested\": false // String\r\n  },\r\n\r\n  // Case 4 and 5\r\n  // localItemRequested:== true:> Case 5\r\n  createAssociationLinkGrouping: { // Case 3\r\n    \"displayText\": true,\r\n    \"groupingItemURI\": true,\r\n    \"xooMLDriverURI\": true\r\n  },\r\n\r\n  // Case 6 and 7\r\n  createAssociationCreate: {\r\n    \"displayText\": true,\r\n    \"itemName\": true,\r\n    \"isGroupingItem\": true\r\n  }\r\n}\n},{}],7:[function(require,module,exports){\n/**\r\n * An XooML utility interacts with an storage and is responsible for\r\n * reading and writing XooML fragments. This is an implementation of XooML utility\r\n * using Dropbox as the storage.\r\n *\r\n * This specific version is for google drive\r\n *\r\n * For ItemMirror core developers only. Enable protected to see.\r\n *\r\n * @class XooMLDriver\r\n * @constructor\r\n *\r\n * @param {Object} options Data to construct a new XooMLU with\r\n * @param {String} options.fragmentURI The URI of fragment\r\n * contains the XooML\r\n * @param {String} options.utilityURI URI of the utility\r\n * @param {Object} options.dropboxClient Authenticated dropbox client\r\n *\r\n * @protected\r\n */\r\n\r\nvar XooMLExceptions = require('./XooMLExceptions');\r\nvar XooMLConfig = require('./XooMLConfig');\r\n\r\n  var _CONSTRUCTOR_OPTIONS = {\r\n      // This is the location of the driver\r\n      // Not currently used, but will eventually be specified\r\n      driverURI: true,\r\n      // This is the location of the fragment (XooML2.xml) for a given\r\n      // interface. In the case of google drive it's just the first result of\r\n      // the root folder with a search for the exact file XooML2.xml. While\r\n      // there's a more specific ID for the file itself, we can't really\r\n      // use that because there's no pointer to that initial file.\r\n\r\n      // This means that if there are two XooML2.xml files in the root\r\n      // directory, it's then possible that one will get ignored\r\n    };\r\n\r\n  /**\r\n   * Constructs a XooMLDriver for reading/writing XooML fragment.\r\n   *\r\n   * @method XooMLDriver\r\n   *\r\n   * @param {Object} options A list of options for construction\r\n   * @param {Function} callback A function to call after completion\r\n   *\r\n   * @protected\r\n   */\r\n  function XooMLDriver(options, callback) {\r\n    var self = this;\r\n\r\n    if (!options.clientInterface) {\r\n      throw new Error('Missing client interface in options!');\r\n    }\r\n\r\n    // The parent URI tells us what 'folder', the XooML should be put inside\r\n    // of. Root is a special URI for google drive, otherwise it should be an\r\n    // id\r\n    this._parentURI = options.associatedItem || 'root';\r\n\r\n    // Client Interface is whatever object that a given client hands back\r\n    // after the authorization step. We use it to make sending and recieving\r\n    // requests extremely simple.\r\n\r\n    // Note: This does assume that the client has already been authenticated\r\n    // If not it could lead to potential errors. gapi should be set to the\r\n    // clientInterface\r\n    this.clientInterface = options.clientInterface;\r\n\r\n    // The fragmentURI is the id of the XooML file. It may or may not exist\r\n    this._fragmentURI = options.fragmentURI ? options.fragmentURI : null;\r\n\r\n    // This comes from the usage of teh updated API, we have to jump through\r\n    // several hoops to geth the authentication token that we're looking for\r\n    var authResponse = this.clientInterface.auth2.getAuthInstance()\r\n      .currentUser.get()\r\n      .getAuthResponse();\r\n\r\n    // This is the authorized header, so we can easily make requests via ajax.\r\n    // If we get request errors, make sure that this header is correct, and\r\n    // doesn't constantly change\r\n    this._AUTH_HEADER = { Authorization: 'Bearer ' + authResponse.access_token };\r\n    this._DRIVE_FILE_API = 'https://www.googleapis.com/drive/v2/files/';\r\n\r\n    return callback(false, self);\r\n  }\r\n\r\n\r\n  /**\r\n   * Creates a request for a given fileID and executes the request\r\n   * @method _readFile\r\n   * @param  {Function} callback Function with the XML string response\r\n   * @param {String} id ID of the file you want to get download\r\n   */\r\n  XooMLDriver.prototype._readFile = function(callback) {\r\n    var self = this;\r\n\r\n    $.ajax({\r\n      url:  self._DRIVE_FILE_API + self._fragmentURI,\r\n      // Required to actually initiate a download\r\n      data: 'alt=media',\r\n      // If this isn't specified, we get an XMLDocument back. We want a\r\n      // string for maximum flexibility.\r\n      dataType: 'text',\r\n      // Note, if the authorization header is messed up, it will give us\r\n      // an error that tells us we need to sign in and have reached our\r\n      // limit.\r\n      headers: self._AUTH_HEADER\r\n    }).then(function(xml_text) {\r\n      callback(false, xml_text);\r\n    });\r\n  };\r\n\r\n  // This is a helper function that searches for the xml file in a folder when\r\n  // necessary\r\n  XooMLDriver.prototype._searchXooML = function(callback, folderID) {\r\n    var self = this;\r\n\r\n    // This query means return the file with the title XooML2.xml in the\r\n    // root directory.\r\n    // Details on the gapi query syntax: https://developers.google.com/drive/web/search-parameters\r\n    var query = 'title = \\'' + XooMLConfig.xooMLFragmentFileName + '\\' and \\'' + folderID + '\\' in parents';\r\n    var request = this.clientInterface.client.drive.files.list({\r\n      'maxResults': 10,\r\n      'q': query\r\n    });\r\n    request.execute(function(resp) {\r\n      // Now that we've made the request, we can extract the fileID and\r\n      // read the file contents\r\n      var xoomlItem = resp.items[0];\r\n\r\n      if (resp.items.length > 1) {\r\n        console.warn('Mutliple XooML files found, only using first one. Please delete extras');\r\n        console.log(resp.items);\r\n      }\r\n\r\n      // This means that there currently is no XooML file\r\n      if (!xoomlItem) {\r\n        // This error should be standardized somewhere and made into a number\r\n        // that way all drivers can  share it\r\n        return callback('XooML Not Found'); \r\n      }\r\n\r\n      self._fragmentURI = xoomlItem.id;\r\n      self._readFile(callback);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reads and returns a XooML fragment\r\n   * @method getXooMLFragment\r\n   * @param {Function} callback(content) Function to be called when self function is finished with it's operation. content is the content of the XooML fragment.\r\n   *\r\n   * @protected\r\n   */\r\n  XooMLDriver.prototype.getXooMLFragment = function (callback) {\r\n    var self = this;\r\n\r\n    // If we don't have the fragmentURI, we need this for searching\r\n    if (!this._fragmentURI) {\r\n      console.log('SEARCH CASE');\r\n      return this._searchXooML(callback, this._parentURI);\r\n    } else {\r\n      // General case, where we don't need to do a query\r\n      console.log('GENERAL CASE');\r\n      this._readFile(callback, this._fragmentURI);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Writes a XooML fragment\r\n   * @method setXooMLFragment\r\n   * @param {String} xmlString the content of the XooML fragment\r\n   * @param {Function} callback(content) Function to be called when self function is finished with it's operation. content is the content of the XooML fragment.\r\n   *\r\n   * @protected\r\n   */\r\n  XooMLDriver.prototype.setXooMLFragment = function (xmlString, callback) {\r\n    var self = this;\r\n    var mimeType = 'text/xml';\r\n\r\n    // Used when updating an already existing XooML.xml\r\n    function updateFile(callback) {\r\n      var request = gapi.client.request({\r\n        path: '/upload/drive/v2/files/' + self._fragmentURI,\r\n        method: 'PUT',\r\n        params: {'uploadType': 'media'},\r\n        body: xmlString\r\n      });\r\n\r\n      request.execute(function(response) {\r\n        callback(false);\r\n      }, function(error) {\r\n        console.error(error);\r\n        callback(error);\r\n      });\r\n    }\r\n\r\n    // Used when writing a new XooML file\r\n    function insertFile(fileData, callback) {\r\n      var boundary = '-------314159265358979323846';\r\n      var delimiter = \"\\r\\n--\" + boundary + \"\\r\\n\";\r\n      var close_delim = \"\\r\\n--\" + boundary + \"--\";\r\n\r\n      var reader = new FileReader();\r\n      reader.readAsBinaryString(fileData);\r\n      reader.onload = function(e) {\r\n        var contentType = fileData.type || 'application/octet-stream';\r\n        var metadata = {\r\n          'title': XooMLConfig.xooMLFragmentFileName,\r\n          'mimeType': contentType,\r\n          'parents': [{\r\n            \"kind\": \"drive#parentReference\",\r\n            \"id\": self._parentURI,\r\n          }]\r\n        };\r\n\r\n        console.log('XooML Metadata for writing');\r\n        console.log(metadata);\r\n\r\n        var base64Data = btoa(reader.result);\r\n        var multipartRequestBody =\r\n            delimiter +\r\n            'Content-Type: application/json\\r\\n\\r\\n' +\r\n            JSON.stringify(metadata) +\r\n            delimiter +\r\n            'Content-Type: ' + contentType + '\\r\\n' +\r\n            'Content-Transfer-Encoding: base64\\r\\n' +\r\n            '\\r\\n' +\r\n            base64Data +\r\n            close_delim;\r\n\r\n        var request = gapi.client.request({\r\n            'path': '/upload/drive/v2/files',\r\n            'method': 'POST',\r\n            'params': {'uploadType': 'multipart'},\r\n            'headers': {\r\n              'Content-Type': 'multipart/mixed; boundary=\"' + boundary + '\"'\r\n            },\r\n            'body': multipartRequestBody});\r\n        request.execute(function(response) {\r\n          // The response is the newly created file, and we set the fragment ID to that\r\n          // so that future requests don't require additional searches\r\n          self._fragmentURI = response.id\r\n          callback(false);\r\n        }, function(response) {\r\n          callback('Could not write out XooML Fragment', response);\r\n        });\r\n      };\r\n    }\r\n\r\n    var blob = new Blob([xmlString], {type: mimeType, fileName: XooMLConfig.xooMLFragmentFileName});\r\n\r\n\r\n    // Update or create the file depending on the circumstances\r\n    if (self._fragmentURI) {\r\n      updateFile(callback);\r\n    } else {\r\n      insertFile(blob, callback);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Check if the XooML fragment exists\r\n   * @method checkExists\r\n   * @param {Function} callback Function to be called when\r\n   * self function is finished with it's operation.\r\n   *  @param {String} callback.error Dropbox error if there is one\r\n   *  @param {Boolean} callback.result True if the fragment exists and\r\n   *  false otherwis\r\n   *\r\n   * @protected\r\n   */\r\n  XooMLDriver.prototype.checkExists = function (callback) {\r\n    var self = this;\r\n\r\n    // If we have the URI, first make a direct request for that\r\n    if (this._fragmentURI) {\r\n      // A simple get request will suffice\r\n      $.get({\r\n        url: _DRIVE_FILE_API + self._fragmentURI,\r\n        headers: _AUTH_HEADER\r\n      }).then(function() {\r\n        callback(false);\r\n      }).fail(function() {\r\n        callback('XooML file: ' + self._fragmentURI + ' not found');\r\n      });\r\n    // In this case, we do a search for XooML in the folder\r\n    } else {\r\n      var query = 'title = \\'' + XooMLConfig.xooMLFragmentFileName + '\\' and \\'' + self._parentURI + '\\' in parents';\r\n      var request = this.clientInterface.client.drive.files.list({\r\n        'maxResults': 1,\r\n        'q': query\r\n      });\r\n      request.execute(function(resp) {\r\n        // Simply check if there were any results\r\n        if (resp.items[0]) {\r\n          callback(false);\r\n        } else {\r\n          callback('XooML file not found in directory: ' + self._parentURI);\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\nmodule.exports = XooMLDriver;\n},{\"./XooMLConfig\":6,\"./XooMLExceptions\":8}],8:[function(require,module,exports){\n/**\r\n * Collection of exceptions associated with the XooML tools.\r\n *\r\n * For ItemMirror core developers only. Enable protected to see.\r\n *\r\n * @class XooMLExceptions\r\n * @static\r\n *\r\n * @protected\r\n */\r\nmodule.exports = {\r\n  /**\r\n   * Thrown when a method is not yet implemented.\r\n   *\r\n   * @event NotImplementedException\r\n   *\r\n   * @protected\r\n   */\r\n  notImplemented: \"NotImplementedException\",\r\n\r\n  /**\r\n   * Thrown when a required property from a method's options is missing.\r\n   *\r\n   * @event MissingParameterException\r\n   *\r\n   * @protected\r\n   */\r\n  missingParameter: \"MissingParameterException\",\r\n\r\n  /**\r\n   * Thrown when an argument is given a null value when it does not accept null\r\n   * values.\r\n   *\r\n   * @event NullArgumentException\r\n   *\r\n   * @protected\r\n   */\r\n  nullArgument: \"NullArgumentException\",\r\n\r\n  /**\r\n   * Thrown when an argument is given a value with a different type from the\r\n   * expected type.\r\n   *\r\n   * @event InvalidTypeException\r\n   *\r\n   * @protected\r\n   */\r\n  invalidType: \"InvalidTypeException\",\r\n\r\n  /**\r\n   * Thrown when an a method is called when the object is in invalid state\r\n   * given what the method expected.\r\n   *\r\n   * @event InvalidStateArgument\r\n   *\r\n   * @protected\r\n   */\r\n  invalidState: \"InvalidStateArgument\",\r\n\r\n  /**\r\n   * Thrown after receiving an exception from XooMLU Storage\r\n   *\r\n   * @event XooMLUException\r\n   *\r\n   * @protected\r\n   */\r\n  xooMLUException: \"XooMLUException\",\r\n\r\n  /**\r\n   * Thrown after receiving an exception from ItemU Storage\r\n   *\r\n   * @event ItemUException\r\n   *\r\n   * @protected\r\n   */\r\n  itemUException: \"ItemUException\",\r\n\r\n  /**\r\n   * Thrown after an association was upgraded that could not be upgraded.\r\n   *\r\n   * @event NonUpgradeableAssociationException\r\n   *\r\n   * @protected\r\n   */\r\n  nonUpgradeableAssociationException: \"NonUpgradeableAssociationException\",\r\n\r\n  /**\r\n   * Thrown after an argument was passed in an invalid state than expected.\r\n   *\r\n   * @event InvalidArgumentException\r\n   *\r\n   * @protected\r\n   */\r\n  invalidArgument: \"InvalidOptionsException\",\r\n\r\n  /**\r\n   * Thrown after expecting a file or folder not to exist when it does.\r\n   *\r\n   * @event FileOrFolderAlreadyExistsException\r\n   *\r\n   * @protected\r\n   */\r\n  itemAlreadyExists: \"ItemAlreadyExistsException\",\r\n\r\n  /**\r\n   * Thrown when expecting the ItemMirror to be current, and it is not.\r\n   *\r\n   * @event FileOrFolderAlreadyExistsException\r\n   *\r\n   * @protected\r\n   */\r\n  itemMirrorNotCurrent: \"ItemMirrorNotCurrent\"\r\n}\n},{}],9:[function(require,module,exports){\n/**\r\n * Collection of type checking, exception throwing, utility methods for the\r\n * XooML tools.\r\n *\r\n * For ItemMirror core developers only. Enable protected to see.\r\n *\r\n * @class XooMLUtil\r\n * @static\r\n *\r\n * @protected\r\n */\r\n\r\n 'use strict'\r\n\r\n var XooMLExceptions = require('./XooMLExceptions');\r\n var XooMLConfig = require('./XooMLConfig'); \r\n\r\n  var\r\n    _GUIDRegex = /\\[([a-z0-9]{8}(?:-[a-z0-9]{4}){3}-[a-z0-9]{12})\\]/i,\r\n    _TYPES = {\r\n      \"[object Boolean]\": \"boolean\",\r\n      \"[object Number]\": \"number\",\r\n      \"[object String]\": \"string\",\r\n      \"[object Function]\": \"function\",\r\n      \"[object Array]\": \"array\",\r\n      \"[object Date]\": \"date\",\r\n      \"[object RegExp]\": \"regexp\",\r\n      \"[object Object]\": \"object\",\r\n      \"[object Error]\": \"error\"\r\n    };\r\n\r\n  var XooMLUtil = {\r\n    /**\r\n     * Checks if each option within the given checkedOptions is a property of\r\n     * the given options.\r\n     *\r\n     * @method hasOptions\r\n     *\r\n     * @param {Object}  checkedOptions Array of strings for each expected option.\r\n     * @param {Object} options         Options given to a function.\r\n     *\r\n     * @protected\r\n     */\r\n    hasOptions: function (checkedOptions, options) {\r\n      if (!checkedOptions || !options) {\r\n        throw XooMLExceptions.nullArgument;\r\n      }\r\n      if (!XooMLUtil.isObject(checkedOptions) ||\r\n          !XooMLUtil.isObject(options)) {\r\n        throw XooMLExceptions.invalidType;\r\n      }\r\n      var checkedOption, isRequiredOption, missingOptionalParamCount;\r\n\r\n      missingOptionalParamCount = 0;\r\n\r\n      if (Object.keys(options).length <= Object.keys(checkedOptions).length) {\r\n        for (checkedOption in checkedOptions) {\r\n          if (checkedOptions.hasOwnProperty(checkedOption)) {\r\n            isRequiredOption = checkedOptions[checkedOption];\r\n\r\n            if (!options.hasOwnProperty(checkedOption)) {\r\n              if (isRequiredOption) {\r\n                return false;\r\n              } else {\r\n                missingOptionalParamCount += 1;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        return false;\r\n      }\r\n\r\n      return Object.keys(options).length <=\r\n        Object.keys(checkedOptions).length - missingOptionalParamCount;\r\n    },\r\n\r\n    // throws exceptions for callbacks since null callbacks mean the program can't continue\r\n    checkCallback: function (callback) {\r\n      if (callback) {\r\n        if (!XooMLUtil.isFunction(callback)) {\r\n          throw XooMLExceptions.invalidType;\r\n        }\r\n      } else {\r\n        throw XooMLExceptions.nullArgument;\r\n      }\r\n    },\r\n\r\n    isGUID: function (GUID) {\r\n      if (XooMLUtil.getType(GUID) === \"string\") {\r\n        return true; // TODO implement guid checking\r\n      } else {\r\n        return false;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns if the given value is an array.\r\n     *\r\n     * Throws NullArgumentException when value is null. <br/>\r\n     *\r\n     * @method isArray\r\n     *\r\n     * @param {Object} value Given object have it's type checked.\r\n     *\r\n     * @protected\r\n     */\r\n    isArray: function (value) {\r\n      return XooMLUtil.getType(value) === \"array\";\r\n    },\r\n\r\n    /**\r\n     * Returns if the given value is an object.\r\n     *\r\n     * Throws NullArgumentException when value is null. <br/>\r\n     *\r\n     * @method isObject\r\n     *\r\n     * @param {Object} value Given object have it's type checked.\r\n     *\r\n     * @return {Boolean} True if the given value is an Object, else false.\r\n     *\r\n     * @protected\r\n     */\r\n    isObject: function (value) {\r\n      return XooMLUtil.getType(value) === \"object\";\r\n    },\r\n\r\n    /**\r\n     * Returns if the given value is an function.\r\n     *\r\n     * Throws NullArgumentException when value is null. <br/>\r\n     *\r\n     * @method isFunction\r\n     *\r\n     * @param {Object} value Given object have it's type checked.\r\n     *\r\n     * @return {Boolean} True if the given value is a Function, else false.\r\n     *\r\n     * @protected\r\n     */\r\n    isFunction: function (value) {\r\n      return value !== null;\r\n      //return XooMLUtil.getType(value) === \"function\"; TODO figure out why this doesn't work\r\n    },\r\n\r\n    /**\r\n     * Returns if the given value is an string.\r\n     *\r\n     * Throws NullArgumentException when value is null. <br/>\r\n     *\r\n     * @method isString\r\n     *\r\n     * @param {Object} value Given object have it's type checked.\r\n     *\r\n     * @return {Boolean} True if the given value is a String, else false.\r\n     *\r\n     * @protected\r\n     */\r\n    isString: function (value) {\r\n      return XooMLUtil.getType(value) === \"string\";\r\n    },\r\n\r\n    isBoolean: function (value) {\r\n      return XooMLUtil.getType(value) === \"boolean\";\r\n    },\r\n\r\n    /**\r\n     * Generates a GUID.\r\n     *\r\n     * @method generateGUID\r\n     *\r\n     * @return {String} Randomly generated GUID.\r\n     *\r\n     * @protected\r\n     */\r\n    generateGUID: function () {\r\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\r\n        return v.toString(16);\r\n      });\r\n    },\r\n\r\n    getType: function (obj) {\r\n      if (obj === null) {\r\n        return String(obj);\r\n      }\r\n      return typeof obj === \"object\" ||\r\n        typeof obj === \"function\" ? _TYPES[obj.toString()] || \"object\" : typeof obj;\r\n    },\r\n\r\n    endsWith: function (string, suffix) {\r\n      return string.indexOf(suffix, string.length - suffix.length) !== -1;\r\n    },\r\n\r\n    // http://stackoverflow.com/questions/728360/most-elegant-way-to-clone-a-javascript-object\r\n    clone: function (obj) {\r\n      var copy;\r\n      // Handle the 3 simple types, and null or undefined\r\n      if (null === obj || \"object\" != typeof obj) return obj;\r\n\r\n      // Handle Date\r\n      if (obj instanceof Date) {\r\n        copy = new Date();\r\n        copy.setTime(obj.getTime());\r\n        return copy;\r\n      }\r\n\r\n      // Handle Array\r\n      if (obj instanceof Array) {\r\n        copy = [];\r\n        for (var i = 0, len = obj.length; i < len; i++) {\r\n          copy[i] = XooMLUtil.clone(obj[i]);\r\n        }\r\n        return copy;\r\n      }\r\n\r\n      // Handle Object\r\n      if (obj instanceof Object) {\r\n        copy = {};\r\n        for (var attr in obj) {\r\n          if (obj.hasOwnProperty(attr)) copy[attr] = XooMLUtil.clone(obj[attr]);\r\n        }\r\n        return copy;\r\n      }\r\n\r\n      throw XooMLExceptions.invalidType;\r\n    }\r\n  };\r\n\r\nmodule.exports = XooMLUtil;\n},{\"./XooMLConfig\":6,\"./XooMLExceptions\":8}]},{},[4])\n\n","/**\r\n * Constructs a FragmentWrapper for a XooML fragment. In the following cases.\r\n *\r\n * 1. XooMLFragment String is passed in and is used as the XooMLFragment\r\n * 2. XooMLFragment Element is passed in and is used as the XooMLFragment.\r\n * 2. Associations, XooMLDriver, ItemDriver, SyncDriver,\r\n * groupingItemURI are given and used to create a new XooMLFragment with\r\n * the given data.\r\n *\r\n * The FragmentWrapper is merely a representation of a XooML fragment,\r\n * and is used by an itemMirror that actually handles the details of\r\n * creating deleting and modifying associations.\r\n *\r\n * For ItemMirror core developers only. Enable protected to see.\r\n *\r\n * @class FragmentEditor\r\n * @constructor\r\n *\r\n * @param {Object} options Data to construct a new FragmentWrapper with\r\n *  @param {String} options.text Unparsed XML directly from a storage\r\n *  platform.\r\n *  @param {Element} options.element XML Element representing a XooML\r\n *                   fragment. Required for case 1.\r\n *  @param {AssociationEditor[]} options.associations List of associations for\r\n *          the newly constructed XooMLFragment in case 2. <br/>__optional__\r\n *  @param {Object} options.commonData Common data for the\r\n *  fragment. Look at the constructor for more details. Required for case 2\r\n *  @param {String} options.groupingItemURI The URI for the grouping\r\n *  item of the fragment. Required for case 2.\r\n *\r\n * @protected\r\n **/\r\n\r\n\r\n'use strict'\r\n\r\nvar XooMLExceptions = require('./XooMLExceptions');\r\nvar XooMLUtil = require('./XooMLUtil');\r\nvar AssociationEditor = require('./AssociationEditor');\r\n\r\n  var _ELEMENT_NAME = \"fragment\",\r\n      _ASSOCIATION_ELEMENT_NAME = \"association\",\r\n      _ASSOCIATION_ID_ATTR = \"ID\",\r\n      _NAMESPACE_ELEMENT_NAME = \"fragmentNamespaceElement\",\r\n      _SCHEMA_VERSION_ATTR = \"schemaVersion\",\r\n      _SCHEMA_LOCATION_ATTR = \"schemaLocation\",\r\n      _ITEM_DESCRIBED_ATTR = \"itemDescribed\",\r\n      _DISPLAY_NAME_ATTR = \"displayName\",\r\n      _ITEM_DRIVER_ATTR = \"itemDriver\",\r\n      _SYNC_DRIVER_ATTR = \"syncDriver\",\r\n      _XOOML_DRIVER_ATTR = \"xooMLDriver\",\r\n      _GUID_ATTR = \"GUIDGeneratedOnLastWrite\",\r\n      _ITEM_MIRROR_NS = \"http://kftf.ischool.washington.edu/xmlns/xooml\";\r\n\r\n  function FragmentEditor(options) {\r\n    var self = this;\r\n\r\n    if (options.text) {\r\n      _fromString(options.text, self);\r\n    } else if (options.element) {\r\n      _fromElement(options.element, self);\r\n    } else if (options.commonData) {\r\n      _fromOptions(options.commonData, options.associations, self);\r\n    } else {\r\n      throw new Error(XooMLExceptions.missingParameter);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the GUID of the Fragment\r\n   *\r\n   * @method updateID\r\n   * @return {String} The new GUID of the fragment\r\n   * @private\r\n   * @protected\r\n   */\r\n  FragmentEditor.prototype.updateID = function() {\r\n    var guid = XooMLUtil.generateGUID();\r\n    this.commonData.GUIDGeneratedOnLastWrite = guid;\r\n    return guid;\r\n  };\r\n\r\n  /**\r\n   * Converts a FragmentEditor object into an XML element, which can\r\n   * then be serialized and saved as a string, or further manipulated\r\n   * with DOM methods\r\n   * @method toElement\r\n   * @return {Element} The XooML fragment as an XML element\r\n   * @protected\r\n   */\r\n  FragmentEditor.prototype.toElement = function() {\r\n    var self = this,\r\n        fragmentElem = document.createElementNS(_ITEM_MIRROR_NS, _ELEMENT_NAME);\r\n\r\n    // common data\r\n    Object.keys(self.commonData).forEach( function(attrName) {\r\n      var attrValue = self.commonData[attrName];\r\n      if (attrValue) { // Don't set null attributes\r\n        fragmentElem.setAttribute(attrName, attrValue);\r\n      }\r\n    });\r\n\r\n    // namespace data\r\n    Object.keys(self.namespace).forEach( function(uri) {\r\n      var nsElem = document.createElementNS(uri, _NAMESPACE_ELEMENT_NAME);\r\n      // Attributes\r\n      Object.keys(self.namespace[uri].attributes).forEach( function(attrName) {\r\n        nsElem.setAttributeNS(uri, attrName, self.namespace[ uri ].attributes[ attrName ]);\r\n      });\r\n\r\n      nsElem.textContent = self.namespace[ uri ].data;\r\n\r\n      fragmentElem.appendChild(nsElem);\r\n    });\r\n\r\n    // associations\r\n    Object.keys(self.associations).forEach( function(id) {\r\n      fragmentElem.appendChild( self.associations[id].toElement() );\r\n    });\r\n\r\n    return fragmentElem;\r\n  };\r\n\r\n  /**\r\n   * Returns the XML of a fragment as a string, _not_ the string\r\n   * version of the object. This is used for persisting the fragment\r\n   * across multiple platforms\r\n   * @method toString\r\n   * @return {String} Fragment XML\r\n   */\r\n  FragmentEditor.prototype.toString = function() {\r\n    var serializer = new XMLSerializer();\r\n    return serializer.serializeToString( this.toElement() );\r\n  };\r\n\r\n  /**\r\n   * Constructs a fragmentEditor based on data passed into the\r\n   * parameters\r\n   *\r\n   * @method _fromOptions\r\n   *\r\n   * @param {Object} commonData An object containing common data for the association\r\n   *  @param {String} commonData.schemaVersion The version of the schema <br/> __required__\r\n   *  @param {String} commonData.schemaLocation The location of the schema\r\n   *  @param {String} commonData.itemDescribed URI pointing to item for which the\r\n   *  XooML fragment is metadata.\r\n   *  @param {String} commonData.displayName Display name of the fragment\r\n   *  @param {String} commonData.itemDriver The URI of the item driver for the fragment\r\n   *  @param {String} commonData.syncDriver The URI of the sync driver for the fragment\r\n   *  @param {String} commonData.xooMLDriver The URI of the XooML driver for the fragment\r\n   *  @param {String} commonData.GUIDGeneratedOnLastWrite The GUID generated the last time the fragment was written\r\n   * @param {AssociationEditor[]} associations An array of associations that the fragment has\r\n   * @param {String} namespace The namespace URI that an app will use for it's own private data\r\n   * @param {FragmentEditor} self\r\n   *\r\n   * @private\r\n   */\r\n  function _fromOptions(commonData, associations, self) {\r\n    if (!commonData) {\r\n      throw XooMLExceptions.nullArgument;\r\n    }\r\n\r\n    // Properties from the common data\r\n    /**\r\n     * Common Data of the association that is accessible to all applications\r\n     * @property commonData\r\n     * @type Object\r\n     */\r\n    self.commonData = {\r\n      /**\r\n       * Text that describes the fragment\r\n       * @property commonData.displayName\r\n       * @type String\r\n       */\r\n      displayName: commonData.displayName || null,\r\n\r\n      /**\r\n       * The schema location for the fragment\r\n       * @property commonData.schemaLocation\r\n       * @type String\r\n       */\r\n      schemaLocation: commonData.schemaLocation || null,\r\n\r\n      /**\r\n       * The schema version for the fragment\r\n       * @property commonData.schemaVersion\r\n       * @type String\r\n       */\r\n      schemaVersion: commonData.schemaVersion || null,\r\n\r\n      /**\r\n       * The item driver URI for the fragment\r\n       * @property commonData.itemDriver\r\n       * @type String\r\n       */\r\n      itemDriver: commonData.itemDriver || null,\r\n\r\n      /**\r\n       * The item described for the fragment. This is a URI that\r\n       * points to grouping item from wich the itemMirror was created\r\n       * @property commonData.\r\n       * @type String\r\n       */\r\n      itemDescribed: commonData.itemDescribed || null,\r\n\r\n      /**\r\n       * The sync driver URI for the fragment\r\n       * @property commonData.syncDriver\r\n       * @type String\r\n       */\r\n      syncDriver: commonData.syncDriver || null,\r\n\r\n      /**\r\n       * The XooML driver URI for the fragment\r\n       * @property commonData.xooMLDriver\r\n       * @type String\r\n       */\r\n      xooMLDriver: commonData.xooMLDriver || null,\r\n\r\n      /**\r\n       * The unique GUID for the fragment that is updated after every\r\n       * write\r\n       * @property commonData.GUIDGeneratedOnLastWrite\r\n       * @type String\r\n       */\r\n      GUIDGeneratedOnLastWrite: XooMLUtil.generateGUID()\r\n    };\r\n\r\n    /**\r\n     * The associations of the fragment. Each association is accessed\r\n     * by referencing it's ID, which then gives the corresponding\r\n     * AssociationEditor object for manipulating that association.\r\n     * @property associations\r\n     * @type Object\r\n     */\r\n    // Takes the association array and turns it into an associative\r\n    // array accessed by the GUID of an association\r\n    self.associations = {};\r\n    associations.forEach( function(assoc) {\r\n      var guid = assoc.commonData.ID;\r\n      self.associations[guid] = assoc;\r\n    });\r\n\r\n\r\n    /**\r\n     * The namespace data of the fragment. Holds both the URI as well\r\n     * as the namespace specific data for the fragment\r\n     * @property namespace\r\n     * @type Object\r\n     */\r\n    self.namespace = {};\r\n      /**\r\n       * The namespace URI for the fragment. Used to set namespace data\r\n       * for both the fragment and it's associations\r\n       * @property namespace.uri\r\n       * @type String\r\n       */\r\n\r\n      /**\r\n       * The attributes of the namespace. This is app specific data\r\n       * that is set for the fragment. Each key pair in the object\r\n       * represents an attribute name and it's corresponding value\r\n       * @property namespace.attributes\r\n       * @type Object\r\n       */\r\n  }\r\n\r\n  /**\r\n   * Takes a fragment in the form of a string and then parses that\r\n   * into XML. From there it converts that element into an object\r\n   * using the _fromElement method\r\n   * \r\n   * @method _fromString\r\n   *\r\n   * @param {String} text The text representing the fragment. Should\r\n   * be obtained directly from a storage platform like dropbox or a\r\n   * local filesystem\r\n   * @param {String} namespace The URI of the namespace that will\r\n   * initially be used for the fragment when handling any namespace\r\n   * data\r\n   * @param {FragmentEditor} self\r\n   */\r\n  function _fromString(text, namespace, self) {\r\n    var parser = new DOMParser();\r\n    var doc = parser.parseFromString(text, \"application/xml\");\r\n    _fromElement(doc.children[0], namespace, self);\r\n  }\r\n\r\n  /**\r\n   * Takes a fragment element in XML and then converts that into a\r\n   * FragmentEditor object. Intended to be one of the ways the object\r\n   * is constructed\r\n   *\r\n   * @method _fromElement\r\n   *\r\n   * @param {Element} element The XML element that represents an association.\r\n   * @param {FragmentEditor} self\r\n   * @private\r\n   */\r\n  function _fromElement(element, self) {\r\n    var dataElems, i, associationElems, guid, elem, uri;\r\n    // Sets all common data attributes\r\n    self.commonData = {\r\n      fragmentNamespaceElement: element.getAttribute(_NAMESPACE_ELEMENT_NAME),\r\n      schemaVersion: element.getAttribute(_SCHEMA_VERSION_ATTR),\r\n      schemaLocation: element.getAttribute(_SCHEMA_LOCATION_ATTR),\r\n      itemDescribed: element.getAttribute(_ITEM_DESCRIBED_ATTR),\r\n      displayName: element.getAttribute(_DISPLAY_NAME_ATTR),\r\n      itemDriver: element.getAttribute(_ITEM_DRIVER_ATTR),\r\n      syncDriver: element.getAttribute(_SYNC_DRIVER_ATTR),\r\n      xooMLDriver: element.getAttribute(_XOOML_DRIVER_ATTR),\r\n      GUIDGeneratedOnLastWrite: element.getAttribute(_GUID_ATTR)\r\n    };\r\n\r\n    /**\r\n     * The namespace object is an associated array with each key being\r\n     * a namespace URI. These can thene be used to modify fragment\r\n     * namespace attributes and data\r\n     * @property namespace\r\n     * @type Object\r\n     */\r\n    self.namespace = {};\r\n\r\n    dataElems = element.getElementsByTagName(_NAMESPACE_ELEMENT_NAME);\r\n    for (i = 0; i < dataElems.length; i += 1) {\r\n      elem = dataElems[i];\r\n      uri = elem.namespaceURI;\r\n\r\n      /**\r\n       * The information for a given namespace. Includes both the\r\n       * data, and the attributes. Namespaces URIs must be unique or\r\n       * they will overwrite data from another namespace\r\n       * @property namespace.URI\r\n       * @type Object\r\n       */\r\n      self.namespace[ uri ] = {};\r\n      self.namespace[ uri ].attributes = {};\r\n\r\n      for (i = 0; i < elem.attributes.length; i += 1) {\r\n        // We have to filter out the special namespace attribute We\r\n        // let the namespace methods handle the namespace, and we\r\n        // don't deal with it\r\n        if (elem.attributes[i].name !== \"xmlns\") {\r\n          /**\r\n           * The attributes of the current namespace, with each attribute\r\n           * having a corresponding value.\r\n           * @property namespace.URI.attributes\r\n           * @type Object\r\n           */\r\n          self.namespace[ uri ].attributes[ elem.attributes[i].localName ] =\r\n            elem.getAttributeNS(uri, elem.attributes[i].localName);\r\n        }\r\n      }\r\n\r\n    /**\r\n     * This is the namespace data stored within the namespace\r\n     * element. Anything can be put here, and it will be stored as a\r\n     * string. ItemMirror will not do anything with the data here and\r\n     * doesn't interact with it at all. It is the responsibility of\r\n     * other applications to properly store information here.\r\n     * @property namespace.URI.data\r\n     * @type String\r\n     */\r\n      self.namespace[ uri ].data = elem.textContent;\r\n    }\r\n\r\n    // associations\r\n    self.associations = {};\r\n    associationElems = element.getElementsByTagName(_ASSOCIATION_ELEMENT_NAME);\r\n    for (i = 0; i < associationElems.length; i += 1) {\r\n      guid = associationElems[i].getAttribute(_ASSOCIATION_ID_ATTR);\r\n      self.associations[guid] = new AssociationEditor({\r\n        element: associationElems[i]\r\n      });\r\n    }\r\n  }\r\n\r\nmodule.exports = FragmentEditor;","/**\r\n * An item utility interacts with the item storage and is responsible for\r\n * creating and deleting items. This is an implementation of item utility\r\n * using Dropbox as the item storage.\r\n *\r\n * For ItemMirror core developers only. Enable protected to see.\r\n *\r\n * @class ItemDriver\r\n * @constructor\r\n *\r\n * @param {Object} options Data to construct a new ItemU with\r\n * @param {String} options.utilityURI URI of the utility\r\n * @param {Object} options.dropboxClient Authenticated dropbox client\r\n *\r\n * @protected\r\n */\r\n\r\n'use strict'\r\n\r\nvar XooMLConfig = require('./XooMLConfig');\r\nvar AssociationEditor = require('./AssociationEditor');\r\n\r\n  /**\r\n   * Constructs a ItemDriver for reading/writing Item Storage\r\n   *\r\n   * @method ItemDriver\r\n   *\r\n   * @param {Object} options Options passed for construction\r\n   * @param {Function} callback The function to call after completion\r\n   *\r\n   * @protected\r\n   */\r\n  function ItemDriver(options, callback) {\r\n    var self = this;\r\n\r\n    // client (google drive in this case)\r\n    if (!options.clientInterface) {\r\n      throw new Error('Client parameter missing');\r\n    }\r\n    this.clientInterface = options.clientInterface;\r\n\r\n    var authResponse = this.clientInterface.auth2.getAuthInstance()\r\n      .currentUser.get()\r\n      .getAuthResponse();\r\n\r\n    // These are the same across multple files, and so should be put in a common configuration somewhere\r\n    this._AUTH_HEADER = { Authorization: 'Bearer ' + authResponse.access_token };\r\n    this._DRIVE_FILE_API = 'https://www.googleapis.com/drive/v2/files/';\r\n\r\n    self._FOLDER_MIMETYPE = 'application/vnd.google-apps.folder';\r\n\r\n    return callback(false, self);\r\n  }\r\n\r\n  ItemDriver.prototype.isGroupingItem = function (id, callback) {\r\n    var self = this;\r\n\r\n    // do a simple get request, and see if it's a folder\r\n    $.get({\r\n      url: self._DRIVE_FILE_API + id,\r\n      headers: self._AUTH_HEADER\r\n    }).then(function(resp) {\r\n      // This is the specific mimetype that google counts as a 'folder'\r\n      callback(false, self._FOLDER_MIMETYPE === resp.mimeType);\r\n    }).fail(function() {\r\n      callback('No response from GET: ' + id);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Creates a grouping item at the location\r\n   * @method createGroupingItem\r\n   * @param {String} path the path to the location that the grouping item will be created\r\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\r\n   *\r\n   * @protected\r\n   */\r\n  ItemDriver.prototype.createGroupingItem = function (parentURI, title, callback) {\r\n    var self = this;\r\n\r\n    $.post({\r\n      url: self._DRIVE_FILE_API,\r\n      headers: self._AUTH_HEADER,\r\n      body: {\r\n        mimeType: self._FOLDER_MIMETYPE,\r\n        title: title,\r\n        parents: [parentURI]\r\n      }\r\n    }).then(function(resp) {\r\n      // Callback with ID of the newly created folder so we have a reference\r\n      callback(false, resp.id);\r\n    }).fail(function() {\r\n      callback('Failed to make POST request for new grouping item. Check network requests for more deatils');\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Creates or uploads a non-grouping item at the location\r\n   * @method createNonGroupingItem\r\n   * @param {String} path the path to the location that the non-grouping item will be created\r\n   * @param {String} file the contents to be written to the non-grouping item\r\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\r\n   *\r\n   * @protected\r\n   */\r\n  ItemDriver.prototype.createNonGroupingItem = function (path, file, callback) {\r\n    var self = this;\r\n\r\n    self._dropboxClient.writeFile(path, file, function (error, stat) {\r\n      if (error) {\r\n        return self._showDropboxError(error, callback);\r\n      }\r\n      return callback(false, stat);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Deletes a grouping item at the location\r\n   * @method deleteGroupingItem\r\n   * @param {String} path the path to the location that the grouping item is located\r\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\r\n   *\r\n   * @protected\r\n   */\r\n  ItemDriver.prototype.deleteGroupingItem = function (path, callback) {\r\n    var self = this;\r\n\r\n    self._dropboxClient.remove(path, function (error, stat) {\r\n      if (error) {\r\n        return self._showDropboxError(error, callback);\r\n      }\r\n      return callback(false, stat);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Deletes a non-grouping item at the location\r\n   * @method deleteNonGroupingItem\r\n   * @param {String} path the path to the location that the non-grouping item is located\r\n   * @param {String} name the name of the non-grouping item\r\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\r\n   *\r\n   * @protected\r\n   */\r\n  ItemDriver.prototype.deleteNonGroupingItem = function (path, callback) {\r\n    var self = this;\r\n\r\n    self._dropboxClient.remove(path, function (error, stat) {\r\n      if (error) {\r\n        return self._showDropboxError(error, callback);\r\n      }\r\n      return callback(false, stat);\r\n    });\r\n  };\r\n  \r\n    /**\r\n   * Copies an item in the fashion of moveItem\r\n   * @method copyItem\r\n   * @param {String} fromPath the path to the file you want copied\r\n   * @param {String} toPath the GroupingItem path you want the fromPath file copied to\r\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\r\n   *\r\n   * @protected\r\n   */\r\n  self.copyItem = function (fromPath, toPath, callback) {\r\n    var self = this;\r\n    \r\n    self._dropboxClient.copy(fromPath, toPath, function(error){\r\n      if (error) {\r\n        return self._showDropboxError(error, callback);\r\n      }\r\n      return callback(false);\r\n    });\r\n  };\r\n  \r\n  /**\r\n   * Moves an item\r\n   * @method moveItem\r\n   * @param {String} fromPath the path to the file you want moved\r\n   * @param {String} toPath the GroupingItem path you want the fromPath file moved\r\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\r\n   *\r\n   * @protected\r\n   */\r\n  ItemDriver.prototype.moveItem = function (fromPath, toPath, callback) {\r\n    var self = this;\r\n    \r\n    self._dropboxClient.move(fromPath, toPath, function(error){\r\n      if (error) {\r\n        return self._showDropboxError(error, callback);\r\n      }\r\n      return callback(false);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Get publicly readable download url for a non-grouping item from Dropbox website.\r\n   * @method getURL\r\n   * @param {String} path the path to the location that the non-grouping item is located\r\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\r\n   *\r\n   * @protected\r\n  */\r\n  ItemDriver.prototype.getURL = function (path, callback){\r\n    var self = this;\r\n    \r\n    self._dropboxClient.makeUrl(path, null, function (error, publicURL){\r\n        if (error) {\r\n          return self._showDropboxError(error, callback);\r\n        }\r\n         return callback(false, publicURL.url);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Lists the items under the grouping item\r\n   * @method listItems\r\n   * @param {String} path the path to the grouping item\r\n   * @param {Function} callback(output) Function to be called when self function is finished with it's operation. Output is an array of AssociationEditors.\r\n   *\r\n   * @protected\r\n   */\r\n  ItemDriver.prototype.listItems = function (parentURI, callback) {\r\n    var self = this;\r\n\r\n    var query = '\\'' + parentURI + '\\' in ' + 'parents';\r\n    var request = this.clientInterface.client.drive.files.list({\r\n      'maxResults': 1000,\r\n      'q': query\r\n    });\r\n    request.execute(function(resp) {\r\n      if (resp.error) {\r\n        return callback('Error: Bad Response / Request');  \r\n      }\r\n\r\n      var items = resp.items.filter(function(item) {\r\n        return item.title !== XooMLConfig.xooMLFragmentFileName;\r\n      })\r\n      .map(function(item) {\r\n        return new AssociationEditor({\r\n          commonData: {\r\n            // Change this to be the ID of the XooML.xml file eventually\r\n            // Will need another parameter for that\r\n            associatedXooMLFragment: null, \r\n            associatedItem: item.id,\r\n            associatedItemDriver: 'GoogleItemDriver',\r\n            associatedXooMLDriver: 'GoogleXooMLDriver',\r\n            associatedSyncDriver: 'MirrorSyncDriver', \r\n            isGrouping: item.mimeType === self._FOLDER_MIMETYPE,\r\n            localItem: item.id,\r\n            displayText: item.title\r\n          }\r\n        });\r\n      });\r\n\r\n      callback(false, items);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Check if the item is existed\r\n   * @method checkExisted\r\n   * @param {String} path the path to the location that the item is located\r\n   * @param {String} name the name of the item\r\n   * @param {Function} callback(result) Function to be called when self function is finished with it's operation. Result is the bollean value for whether existed.\r\n   *\r\n   * @protected\r\n   */\r\n  ItemDriver.prototype.checkExisted = function(path, callback){\r\n    var self = this, result;\r\n\r\n    self._dropboxClient.stat(path, function (error,stat){\r\n      if (error) {\r\n        return self._showDropboxError(error, callback);\r\n      }\r\n      result = !(error !== null && error.status === 404) || (error === null && stat.isRemoved);\r\n\r\n      return callback(false, result);\r\n    });\r\n  };\r\n\r\nmodule.exports = ItemDriver;","/**\r\n * ItemMirror represents an Item according to the XooML2 specification.\r\n *\r\n * It can be instantiated using one of the following two cases based on the\r\n * given arguments.\r\n *\r\n * 1. XooMLFragment already exists. Given xooMLFragmentURI and xooMLDriver.\r\n * 2. The XooMLFragment is created from an existing groupingItemURI (e.g., a dropbox folder).\r\n * Given a groupingItemURI, itemDriver, and a xooMLDriver a new itemMirror will be constructed for given groupingItemURI.\r\n *\r\n * Throws NullArgumentException when options is null.\r\n *\r\n * Throws MissingParameterException when options is not null and a required\r\n * argument is missing.\r\n *\r\n * @class ItemMirror\r\n * @constructor\r\n *\r\n * @param {Object} options Data to construct a new ItemMirror with\r\n *\r\n *  @param {String} options.groupingItemURI URI to the grouping item. Required\r\n *                  for all cases.\r\n *\r\n *  @param {String} options.itemDriver Data for the ItemDriver to\r\n *                  construct ItemMirror with. Required for cases 2 & 3\r\n *                  Can contain any amount of optional key/value pairs for\r\n *                  the various Driver implementations.\r\n *   @param {String} options.itemDriver.driverURI URI of the driver.\r\n *\r\n *  @param {String} options.xooMLDriver Data for the XooMLDriver to\r\n *                  construct ItemMirror with. Required for all cases.\r\n *                  Can contain any amount of optional key/value pairs for\r\n *                  the various Driver implementations.\r\n *   @param {String} options.xooMLDriver.driverURI URI of the driver.\r\n *\r\n *  @param {String} options.syncDriver Data for the SyncDriver to\r\n *                  construct ItemMirror with. Required Case 2 & 3. Can\r\n *                  contain any amount of optional key/value pairs for\r\n *                  the various Driver implementations.\r\n *   @param {String} options.syncDriver.driverURI URI of the driver.\r\n *\r\n *  @param {Boolean} options.readIfExists True if ItemMirror\r\n *                   should create an ItemMirror if it does not exist,\r\n *                   else false. Required for Case 2 & 3.\r\n *\r\n *  @param {ItemMirror} options.creator If being created from another\r\n *  itemMirror, specifies that itemMirror which it comes from.\r\n *\r\n * @param {Function} callback Function to execute once finished.\r\n *  @param {Object}   callback.error Null if no error has occurred\r\n *                    in executing this function, else an contains\r\n *                    an object with the error that occurred.\r\n *  @param {ItemMirror} callback.itemMirror Newly constructed ItemMirror\r\n */\r\n\r\n'use strict'\r\n\r\nvar XooMLExceptions = require('./XooMLExceptions');\r\nvar XooMLUtil = require('./XooMLUtil');\r\nvar XooMLDriver = require('./XooMLDriver');\r\nvar ItemDriver = require('./ItemDriver');\r\nvar SyncDriver = require('./SyncDriver');\r\nvar FragmentEditor = require('./FragmentEditor');\r\nvar AssociationEditor = require('./AssociationEditor');\r\n\r\n    function ItemMirror(options, callback) {\r\n    XooMLUtil.checkCallback(callback);\r\n    if (!options) {\r\n      return callback(XooMLExceptions.nullArgument);\r\n    }\r\n    if (!XooMLUtil.isObject(options)) {\r\n      return callback(XooMLExceptions.invalidType);\r\n    }\r\n\r\n   var self = this, xooMLFragmentURI, displayName;\r\n\r\n   this._xooMLDriverClient = options.xooMLDriver.clientInterface;\r\n   this._itemDriverClient = options.xooMLDriver.clientInterface;\r\n\r\n    // private variables\r\n    self._xooMLDriver = null;\r\n    self._itemDriver = null;\r\n    self._syncDriver = null;\r\n    self._creator = options.creator || null;\r\n    self._groupingItemURI = options.groupingItemURI;\r\n    self._newItemMirrorOptions = options;\r\n\r\n    // displayName for the fragment\r\n    // It may make more sense to set this later once we have the drivers loaded\r\n    // displayName = this._xooMLDriver.getDisplayName();\r\n    displayName = 'TBD';\r\n\r\n    self.fragmentURI = options.fragmentURI || null;\r\n    options.xooMLDriver.fragmentURI = xooMLFragmentURI;\r\n\r\n    // First load the XooML Driver\r\n    new XooMLDriver(options.xooMLDriver, loadXooMLDriver);\r\n\r\n    function loadXooMLDriver(error, driver) {\r\n      if (error) return callback(error);\r\n\r\n      self._xooMLDriver = driver; // actually sets the XooMLDriver\r\n\r\n      self._xooMLDriver.getXooMLFragment(processXooML);\r\n    }\r\n\r\n    function processXooML(error, fragmentString) {\r\n      // Case 2: Since the fragment doesn't exist, we need\r\n      // to construct it by using the itemDriver\r\n      if (error === 'XooML Not Found') {\r\n        new ItemDriver(options.itemDriver, createFromItemDriver);\r\n      } else if (error) {\r\n        return callback(error);\r\n      }\r\n\r\n      // Case 1: It already exists, and so all of the information\r\n      // can be constructed from the saved fragment\r\n      else {\r\n        createFromXML(fragmentString);\r\n      }\r\n    }\r\n\r\n    function createFromXML(fragmentString) {\r\n      self._fragment = new FragmentEditor({text: fragmentString});\r\n\r\n      new ItemDriver(options.itemDriver, function(error, driver) {\r\n        if (error) return callback(error);\r\n        self._itemDriver = driver;\r\n\r\n        self._syncDriver = new SyncDriver(self);\r\n\r\n        // Do a refresh in case something has been added or deleted in\r\n        // the directory since the last write\r\n        self.refresh(function() {\r\n          return callback(false, self);\r\n        });\r\n      });\r\n    }\r\n\r\n    function createFromItemDriver(error, driver) {\r\n      self._itemDriver = driver;\r\n\r\n      self._itemDriver.listItems(self._groupingItemURI, buildFragment);\r\n    }\r\n\r\n    function buildFragment(error, associations){\r\n      if (error) return callback(error);\r\n\r\n      self._fragment = new FragmentEditor({\r\n        commonData: {\r\n          itemDescribed: self._groupingItemURI,\r\n          displayName: displayName,\r\n          itemDriver: \"dropboxItemDriver\",\r\n          xooMLDriver: \"dropboxXooMLDriver\",\r\n          syncDriver: \"itemMirrorSyncUtility\"\r\n        },\r\n        associations: associations\r\n      });\r\n\r\n      self._syncDriver = new SyncDriver(self);\r\n\r\n      // Because the fragment is being built from scratch, it's safe\r\n      // to save it directly via the driver.\r\n      self._xooMLDriver.setXooMLFragment(self._fragment.toString(), function(error) {\r\n        if (error) {\r\n          throw new Error(error);\r\n        }\r\n      });\r\n\r\n      return callback(false, self);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @method getDisplayName\r\n   * @return {String} The display name of the fragment.\r\n   */\r\n  ItemMirror.prototype.getDisplayName = function() {\r\n    return this._fragment.commonData.displayName;\r\n  };\r\n\r\n  /**\r\n   * @method setDisplayName\r\n   * @param {String} name The display text to set for the fragment\r\n   */\r\n  ItemMirror.prototype.setDisplayName = function(name) {\r\n    this._fragment.commonData.displayName = name;\r\n  };\r\n\r\n  /**\r\n   *\r\n   * @method getSchemaVersion\r\n   * @return {String} XooML schema version.\r\n   */\r\n  ItemMirror.prototype.getSchemaVersion = function() {\r\n    return this._fragment.commonData.schemaVersion;\r\n  };\r\n\r\n  /**\r\n   *\r\n   * @method getSchemaLocation\r\n   * @return {String} XooML schema location.\r\n   */\r\n  ItemMirror.prototype.getSchemaLocation = function() {\r\n    return this._fragment.commonData.schemaLocation;\r\n  };\r\n\r\n  /**\r\n   * Returns URI pointing to item described by the metadata of a fragment. A URI\r\n   * might point to just about anything that can be interpreted as a grouping\r\n   * item. For example: a conventional file system folder or a tag as\r\n   * supported by any of several applications.\r\n   *\r\n   * @method getURIforItemDescribed\r\n   * @return {String} A URI pointing to item described by the metadata\r\n   * of a fragment if it exists, else returns null.\r\n   *\r\n   */\r\n  ItemMirror.prototype.getURIforItemDescribed = function() {\r\n    return this._fragment.commonData.itemDescribed;\r\n  };\r\n\r\n  /**\r\n   * Throws NullArgumentException if GUID is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   *\r\n   * @method getAssociationDisplayText\r\n   * @return {String} The display text for the association with the given GUID.\r\n   *\r\n   * @param {String} GUID GUID representing the desired association.\r\n   */\r\n    ItemMirror.prototype.getAssociationDisplayText = function(GUID) {\r\n    return this._fragment.associations[GUID].commonData.displayText;\r\n  };\r\n\r\n  /**\r\n   * Sets the display text for the association with the given GUID.\r\n   *\r\n   * Throws NullArgumentException if GUID or displayName is null. <br/>\r\n   * Throws InvalidTypeException if GUID or displayName is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method setAssociationDisplayText\r\n   *\r\n   * @param {String}   GUID        GUID of the association to set.\r\n   * @param {String}   displayText Display text to be set.\r\n   */\r\n    ItemMirror.prototype.setAssociationDisplayText = function(GUID, displayText) {\r\n    this._fragment.associations[GUID].commonData.displayText = displayText;\r\n  };\r\n\r\n  /**\r\n   * Throws NullArgumentException if GUID is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method getAssociationLocalItem\r\n   * @return {String} The local item for the association with the given GUID.\r\n   *\r\n   * @param {String} GUID GUID of the association to get.\r\n   */\r\n    ItemMirror.prototype.getAssociationLocalItem = function(GUID) {\r\n    return this._fragment.associations[GUID].commonData.localItem;\r\n  };\r\n\r\n  /**\r\n   * Throws NullArgumentException if GUID is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method getAssociationAssociatedItem\r\n   * @return {String} The associated item for the association with the given GUID.\r\n   * @param {String} GUID GUID of the association to get.\r\n   */\r\n    ItemMirror.prototype.getAssociationAssociatedItem = function(GUID) {\r\n    return this._fragment.associations[GUID].commonData.associatedItem;\r\n  };\r\n\r\n  /**\r\n   * @method getFragmentNamespaceAttribute\r\n   * @return {String} Returns the value of the given attributeName for the\r\n   * fragmentNamespaceData with the given namespaceURI.\r\n   * @param {String} attributeName Name of the attribute to be returned.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  ItemMirror.prototype.getFragmentNamespaceAttribute = function(attributeName, uri) {\r\n    var ns = this._fragment.namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    return this._fragment.namespace[uri].attributes[attributeName];\r\n  };\r\n\r\n  /**\r\n   * Sets the value of the given attributeName with the given attributeValue\r\n   * for the fragmentNamespaceData with the given namespaceURI.\r\n   *\r\n   * Throws NullArgumentException if attributeName, attributeValue, or\r\n   * namespaceURI is null. <br/>\r\n   * Throws InvalidTypeException if attributeName, attributeValue, or\r\n   * namespaceURI is not a String. <br/>\r\n   *\r\n   * @method setFragmentNamespaceAttribute\r\n   * @param {String} attributeName  Name of the attribute to be set.\r\n   * @param {String} attributeValue Value of the attribute to be set.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  ItemMirror.prototype.setFragmentNamespaceAttribute = function(attributeName, attributeValue, uri) {\r\n    var ns = this._fragment.namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    this._fragment.namespace[uri].attributes[attributeName] = attributeValue;\r\n  };\r\n\r\n  /**\r\n   * Adds the given attributeName to the fragment's current namespace\r\n   *\r\n   * Throws an InvalidStateException when the attribute already exists\r\n   *\r\n   * @method addFragmentNamespaceAttribute\r\n   *\r\n   * @param {String} attributeName Name of the attribute.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  // TODO: Possibly remove? Why not just get and set\r\n  ItemMirror.prototype.addFragmentNamespaceAttribute = function(attributeName, uri) {\r\n    var ns = this._fragment.namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    if (this._fragment.namespace[uri].attributes[attributeName]) {\r\n      throw XooMLExceptions.invalidState;\r\n    }\r\n    this.setFragmentNamespaceAttribute(attributeName, uri);\r\n  };\r\n\r\n  /**\r\n   * Removes the fragment namespace attribute with the given namespaceURI.\r\n   *\r\n   * Throws NullArgumentException if attributeName, or namespaceURI is\r\n   * null. <br/>\r\n   * Throws InvalidTypeException if attributeName, or namespaceURI is not\r\n   * a String. <br/>\r\n   * Throws an InvalidStateException when the given attributeName is not an\r\n   * attribute. <br/>\r\n   *\r\n   * @method removeFragmentNamespaceAttribute\r\n   * @param {String} attributeName Name of the attribute.\r\n   * @param {String} uri  Namespace URI\r\n   *\r\n   */\r\n  ItemMirror.prototype.removeFragmentNamespaceAttribute = function(attributeName, uri) {\r\n    delete this._fragment.namespace[uri].attributes[attributeName];\r\n  };\r\n\r\n  /**\r\n   * Checks if the fragment has the given namespaceURI.\r\n   *\r\n   * Currently cannot find a way to list the namespaces (no DOM\r\n   * standard method for doing so). So this fuction will ALWAYS RETURN\r\n   * FALSE for now.\r\n   *\r\n   * @method hasFragmentNamespace\r\n   * @return {Boolean} True if the fragment has the given\r\n   * namespaceURI, otherwise false.\r\n   *\r\n   * @param {String} uri URI of the namespace for the association.\r\n   *\r\n   */\r\n  ItemMirror.prototype.hasFragmentNamespace = function (uri) {\r\n    var namespace = this._fragment.namespace[uri];\r\n    if (namespace) { return true; }\r\n    else { return false; }\r\n  };\r\n\r\n  /**\r\n   * @method listFragmentNamespaceAttributes\r\n   * @return {String[]} An array of the attributes within the\r\n   * fragmentNamespaceData with the given namespaceURI.\r\n   * @param {String} uri Namespace URI\r\n   *\r\n  */\r\n  ItemMirror.prototype.listFragmentNamespaceAttributes = function(uri) {\r\n    return Object.keys(this._fragment.namespace[uri].attributes);\r\n  };\r\n\r\n  /**\r\n   * @method getFragmentNamespaceData\r\n   * @return {String} The fragment namespace data with the given namespace URI.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  ItemMirror.prototype.getFragmentNamespaceData = function(uri) {\r\n    return this._fragment.namespace[uri].data;\r\n  };\r\n\r\n  /**\r\n   * Sets the fragment namespace data with the given namespaceURI.\r\n   *\r\n   * @method setFragmentNamespaceData\r\n   *\r\n   * @param {String} data Fragment namespace data to be set.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  ItemMirror.prototype.setFragmentNamespaceData = function (data, uri) {\r\n    var ns = this._fragment.namespace;\r\n    ns[uri] = ns[uri] || {};\r\n\r\n    this._fragment.namespace[uri].data = data;\r\n  };\r\n\r\n  /**\r\n   * Creates an ItemMirror from the associated grouping item represented by\r\n   * the given GUID.\r\n   *\r\n   * Throws NullArgumentException if GUID or callback is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a string, and callback is\r\n   * not a function. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method createItemMirrorForAssociatedGroupingItem\r\n   * @return {ItemMirror} Possibly return an itemMirror if the GUID is a grouping item\r\n   *\r\n   * @param {String} GUID GUID of the association to create the ItemMirror\r\n   *                 from.\r\n   *\r\n   */\r\n  ItemMirror.prototype.createItemMirrorForAssociatedGroupingItem = function (GUID, callback) {\r\n    var self = this,\r\n        isGrouping,\r\n        xooMLOptions,\r\n        itemOptions,\r\n        syncOptions,\r\n        uri;\r\n\r\n    itemOptions = {\r\n      driverURI: \"GoogleItemUtility\",\r\n      clientInterface: this._itemDriverClient,\r\n      // Note that this needs to be changed, we want to point to the grouping item's id\r\n      associatedItem: self.getAssociationAssociatedItem(GUID)\r\n    };\r\n    xooMLOptions = {\r\n      fragmentURI: uri,\r\n      driverURI: \"GoogleXooMLUtility\",\r\n      clientInterface: this._xooMLDriverClient,\r\n      associatedItem: self.getAssociationAssociatedItem(GUID)\r\n    };\r\n    syncOptions = {\r\n      utilityURI: \"SyncUtility\"\r\n    };\r\n\r\n    isGrouping = self.isAssociationAssociatedItemGrouping(GUID);\r\n    if (!isGrouping) {\r\n      // Need to standardize this error\r\n      return callback(\"Association not grouping, cannot continue\");\r\n    }\r\n\r\n    new ItemMirror(\r\n      {groupingItemURI: self.getAssociationAssociatedItem(GUID),\r\n       xooMLDriver: xooMLOptions,\r\n       itemDriver: itemOptions,\r\n       syncDriver: syncOptions,\r\n       creator: self\r\n      },\r\n      function (error, itemMirror) {\r\n        return callback(error, itemMirror);\r\n      }\r\n    );\r\n  };\r\n\r\n  /**\r\n   * Creates an association based on the given options and the following\r\n   * cases.\r\n   *\r\n   * Cases 1, 2, 7 implemented. All else are not implemented.\r\n   *\r\n   * 1. Simple text association declared phantom. <br/>\r\n   * 2. Link to existing non-grouping item, phantom. This can be a URL <br/>\r\n   * 3. Link to existing non-grouping item, real. <br/>\r\n   * 4. Link to existing grouping item, phantom. <br/>\r\n   * 5. Link to existing grouping item, real. <br/>\r\n   * 6. Create new local non-grouping item. <br/>\r\n   * 7. Create new local grouping item. <br/>\r\n   *\r\n   * Throws NullArgumentException when options, or callback is null. <br/>\r\n   * Throws InvalidTypeException when options is not an object and callback\r\n   * is not a function. <br/>\r\n   * Throws MissingParameterException when an argument is missing for an expected\r\n   * case. <br/>\r\n   *\r\n   * @method createAssociation\r\n   *\r\n   * @param {Object} options Data to create an new association for.\r\n   *\r\n   *  @param {String}  options.displayText Display text for the association.\r\n   *                   Required in all cases.\r\n   *\r\n   *  @param {String}  options.itemURI URI of the item. Required for case 2 & 3. Note: Please ensure \"http://\" prefix exists at the beginning of the string when referencing a Web URL and not an Item.\r\n   *\r\n   *  @param {Boolean} options.localItemRequested True if the local item is\r\n   *                   requested, else false. Required for cases 2 & 3.\r\n   *\r\n   *  @param {String}  options.groupingItemURI URI of the grouping item.\r\n   *                   Required for cases 4 & 5.\r\n   *\r\n   *  @param {String}  options.xooMLDriverURI URI of the XooML driver for the\r\n   *                   association. Required for cases 4 & 5.\r\n   *\r\n   *  @param {String}  options.localItem URI of the new local\r\n   *                   non-grouping/grouping item. Required for cases 6 & 7.\r\n   *\r\n   *  @param {String}  options.isGroupingItem True if the item is a grouping\r\n   *                   item, else false. Required for cases 6 & 7.\r\n   *\r\n   * @param {Function} callback Function to execute once finished.\r\n   *  @param {Object}   callback.error Null if no error has occurred\r\n   *                    in executing this function, else an contains\r\n   *                    an object with the error that occurred.\r\n   *  @param {String}   callback.GUID GUID of the association created.\r\n   */\r\n  ItemMirror.prototype.createAssociation = function (options, callback) {\r\n    var self = this,\r\n        association,\r\n        saveOutFragment;\r\n\r\n    saveOutFragment = function(association){\r\n      var guid = association.commonData.ID;\r\n      // adds the association to the fragment\r\n      self._fragment.associations[guid] = association;\r\n\r\n      // Save changes out the actual XooML Fragment\r\n      self.save( function(error){\r\n        return callback(error, guid);\r\n      });\r\n    };\r\n\r\n    if (!XooMLUtil.isFunction(callback)) {\r\n      throw XooMLExceptions.invalidType;\r\n    }\r\n    if (!XooMLUtil.isObject(options)) {\r\n      return callback(XooMLExceptions.invalidType);\r\n    }\r\n\r\n    // Case 7\r\n    if (options.displayText && options.localItem && options.isGroupingItem) {\r\n      association = new AssociationEditor({\r\n        commonData: {\r\n          displayText: options.displayText,\r\n          isGrouping: true,\r\n          localItem: options.localItem,\r\n          // Changed this part, and need to test folder creation to insure safety\r\n          associatedItem: options.associatedItem\r\n        }\r\n      });\r\n\r\n      // Now we use the itemDriver to actually create the folder\r\n      // NOTE: untested\r\n      self._itemDriver.createGroupingItem(options.displayText, function(error){\r\n        if (error) return callback(error);\r\n\r\n        return saveOutFragment(association);\r\n      });\r\n    }\r\n    // Synchronous cases\r\n    else {\r\n      // Case 2\r\n      if (options.displayText && options.itemURI) {\r\n        association = new AssociationEditor({\r\n          commonData: {\r\n            displayText: options.displayText,\r\n            associatedItem: options.itemURI,\r\n            isGrouping: false\r\n          }\r\n        });\r\n      }\r\n      // Case 1\r\n      else if (options.displayText) {\r\n        association = new AssociationEditor({\r\n          commonData: {\r\n            displayText: options.displayText,\r\n            isGrouping: false\r\n          }\r\n        });\r\n      }\r\n\r\n      return saveOutFragment(association);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @method isAssociationPhantom\r\n   * @param {String} guid\r\n   * @return {Boolean} True if the association of the given GUID is a\r\n   * phantom association. False otherwise.\r\n   */\r\n  ItemMirror.prototype.isAssociationPhantom = function(guid) {\r\n    var data = this._fragment.associations[guid].commonData;\r\n    return !(data.isGrouping || data.localItem);\r\n  };\r\n\r\n  /**\r\n   * Duplicates (copies) an association to another ItemMirror Object (representing a grouping item)\r\n   *\r\n   *\r\n   * Throws NullArgumentException if GUID is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method copyAssociation\r\n   *\r\n   * @param {String} GUID GUID of the association you wish to copy/duplicate\r\n   * @param {ItemMirror} ItemMirror ItemMirror representing the grouping item you want to move the GUID object to\r\n   *\r\n   * @param {Function} callback Function to execute once finished.\r\n   * @param {Object} callback.error Null if no error Null if no error has occurred\r\n   *                 in executing this function, else it contains\r\n   *                 an object with the error that occurred.\r\n   */\r\n   ItemMirror.prototype.copyAssociation = function () {\r\n    throw new Error('Method not implemented');\r\n   };\r\n  /**\r\n   * Moves an association to another ItemMirror Object (representing a grouping item)\r\n   *\r\n   *\r\n   * Throws NullArgumentException if GUID is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method moveAssociation\r\n   *\r\n   * @param {String} GUID GUID of the item you want to paste or move\r\n   * @param {ItemMirror} ItemMirror ItemMirror representing the grouping item you want to move the GUID object to\r\n   *\r\n   * @param {Function} callback Function to execute once finished.\r\n   * @param {Object} callback.error Null if no error Null if no error has occurred\r\n   *                 in executing this function, else it contains\r\n   *                 an object with the error that occurred.\r\n   */\r\n   ItemMirror.prototype.moveAssociation = function () {\r\n    throw new Error('Method not implemented');\r\n   };\r\n\r\n  /**\r\n   * Deletes the association represented by the given GUID.\r\n   *\r\n   * Throws NullArgumentException if GUID is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method deleteAssociation\r\n   *\r\n   * @param GUID {String} GUID of the association to be deleted.\r\n   *\r\n   * @param {Function} callback Function to execute once finished.\r\n   *  @param {Object}   callback.error Null if no error has occurred\r\n   *                    in executing this function, else an contains\r\n   *                    an object with the error that occurred.\r\n   */\r\n  ItemMirror.prototype.deleteAssociation = function (GUID, callback) {\r\n    var self = this;\r\n\r\n    XooMLUtil.checkCallback(callback);\r\n    if (!GUID) {\r\n      return callback(XooMLExceptions.nullArgument);\r\n    }\r\n    if (!XooMLUtil.isGUID(GUID)) {\r\n      return callback(XooMLExceptions.invalidType);\r\n    }\r\n\r\n    // Save to ensure that the fragment is up to date\r\n    return self.save(deleteContent);\r\n\r\n    function deleteContent(error) {\r\n      if (error) return callback(error);\r\n\r\n      var isPhantom = self.isAssociationPhantom(GUID);\r\n\r\n      if (!isPhantom) {\r\n        var isGrouping = self.isAssociationAssociatedItemGrouping(GUID),\r\n            // For dropbox support, path should be the full path that is\r\n            // dynamically generated. Refer to case 39 for implementation\r\n            // details. UNTESTED\r\n            path = self.getAssociationAssociatedItem(GUID);\r\n\r\n        delete self._fragment.associations[GUID];\r\n        if (isGrouping) {\r\n          return self._itemDriver.deleteGroupingItem(path, postDelete);\r\n        } else {\r\n          return self._itemDriver.deleteNonGroupingItem(path, postDelete);\r\n        }\r\n      } else {\r\n        delete self._fragment.associations[GUID];\r\n\r\n        // Now do an unsafe_write to commit the XML. It's okay because\r\n        // save means that everything is synced, and this operation\r\n        // was extremely quick\r\n        return self._unsafeWrite(function(error) {\r\n          if (error) return callback(error);\r\n          else return callback();\r\n        });\r\n      }\r\n    }\r\n\r\n    // Now do a refresh since actual files were removed.\r\n    function postDelete(error) {\r\n      if (error) return callback(error);\r\n\r\n      return self.refresh(function(error) {\r\n        if (error) return callback(error);\r\n        return callback(error);\r\n      });\r\n    }\r\n\r\n  };\r\n\r\n  /**\r\n   * Upgrades a given association without a local item. Local item is named\r\n   * by a truncated form of the display name of this ItemMirror if the\r\n   * localItemURI is not given, else uses given localItemURI. Always\r\n   * truncated to 50 characters.\r\n   *\r\n   * ONLY SUPPORTS SIMPLE PHANTOM ASSOCIATION TO ASSOCIATION WITH GROUPING ITEM\r\n   *\r\n   * Throws NullArgumentException when options is null. <br/>\r\n   * Throws MissingParameterException when options is not null and a required\r\n   * argument is missing.<br/>\r\n   * Throws InvalidTypeException if GUID is not a string, and if callback\r\n   * is not a function. <br/>\r\n   * Throws InvalidState if the association with the given GUID cannot be\r\n   * upgraded. <br/>\r\n   *\r\n   * @method upgradeAssociation\r\n   *\r\n   * @param {Object} options Data to construct a new ItemMirror with\r\n   *\r\n   *  @param {String} options.GUID of the association to be upgraded. Required\r\n   *\r\n   *  @param {String} options.localItemURI URI of the local item to be used if\r\n   *                  a truncated display name is not the intended behavior.\r\n   *                  Optional.\r\n   *\r\n   * @param {Function} callback Function to execute once finished.\r\n   *\r\n   *  @param {String}   callback.error Null if no error has occurred\r\n   *                    in executing this function, else an contains\r\n   *                    an object with the error that occurred.\r\n   */\r\n  ItemMirror.prototype.upgradeAssociation = function () {\r\n    throw new Error('Method not implemented');\r\n  };\r\n\r\n  /**\r\n   * Renames the local item for the association with the given GUID.\r\n   *\r\n   * Throws NullArgumentException if GUID, callback is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a String, and if callback\r\n   * is not a function. <br/>\r\n   *\r\n   * @method renameAssocaitionLocalItem\r\n   *\r\n   * @param {String} GUID GUID of the association.\r\n   * @param {String} String String Name you want to rename the file to (including file extension)\r\n   * @param {Function} callback Function to execute once finished.\r\n   *  @param {Object}   callback.error Null if no error has occurred\r\n   *                    in executing this function, else an contains\r\n   *                    an object with the error that occurred.\r\n   * @param {String} callback.GUID The GUID of the association that was updated.\r\n   */\r\n  ItemMirror.prototype.renameAssociationLocalItem = function (GUID, newName, callback) {\r\n    // This method needs a redesign, and can't be properly implemented the way\r\n    // it is now. Instead, this needs to pass information to the acual item\r\n    // driver and that needs to implement an agnostic new name format. This\r\n    // path stuff is specific to dropbox and doesn't work\r\n    var self = this;\r\n    XooMLUtil.checkCallback(callback);\r\n    if (!GUID) {\r\n      return callback(XooMLExceptions.nullArgument);\r\n    }\r\n    if (!XooMLUtil.isGUID(GUID)) {\r\n      return callback(XooMLExceptions.invalidType);\r\n    }\r\n\r\n    self.save(postSave);\r\n\r\n    function postSave(error) {\r\n      if (error) return callback(error);\r\n\r\n      // This stuff needs to be replaced with a method that works for all stores\r\n          // oldPath = PathDriver.joinPath(self._groupingItemURI, localItem),\r\n          // newPath = PathDriver.joinPath(self._groupingItemURI, newName);\r\n\r\n      self._itemDriver.rename(newName, postMove);\r\n    }\r\n\r\n    function postMove(error) {\r\n      if (error) return callback(error);\r\n      // This also needs to be more agnostic\r\n      self._fragment.associations[GUID].commonData.localItem = newName;\r\n\r\n      self._unsafeWrite(postWrite);\r\n    }\r\n\r\n    function postWrite(error) {\r\n      if (error) return callback(error);\r\n\r\n      self.refresh(postRefresh);\r\n    }\r\n\r\n    function postRefresh(error) {\r\n      return callback(error, self._fragment.associations[GUID].commonData.ID);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * A special method that is used for certain file operations where\r\n   * calling a sync won't work. Essentially it is the save function,\r\n   * sans syncing. This should __never__ be called be an application.\r\n   * @method _unsafeWrite\r\n   * @param callback\r\n   * @param calback.error\r\n   */\r\n  ItemMirror.prototype._unsafeWrite = function(callback) {\r\n    var self = this;\r\n\r\n    // Note (12/8/2015) This was never used, but seems like it has purpose. May need to investigate\r\n    //var tmpFragment = new FragmentEditor({text: content});\r\n    self._fragment.updateID();\r\n    return self._xooMLDriver.setXooMLFragment(self._fragment.toString(), function(error) {\r\n      if (error) return callback(error);\r\n      return callback(false);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Checks if an association's associatedItem is a grouping item\r\n   *\r\n   * Throws NullArgumentException if GUID, callback is null. <br/>\r\n   * Throws InvalidTypeException if GUID is not a String, and if callback\r\n   * is not an function. <br/>\r\n   *\r\n   * @method isAssociationAssociatedItemGrouping\r\n   * @return {Boolean} True if the association with the given GUID's associatedItem is a grouping\r\n   * item, otherwise false.\r\n   *\r\n   * @param GUID {String} GUID of the association to be to be checked.\r\n   *\r\n   */\r\n  ItemMirror.prototype.isAssociationAssociatedItemGrouping = function(GUID) {\r\n    return this._fragment.associations[GUID].commonData.isGrouping;\r\n  };\r\n\r\n  /**\r\n   * Lists the GUIDs of each association.\r\n   *\r\n   * @method listAssociations\r\n   *\r\n   * @return {String[]} Array of the GUIDs of each association\r\n   */\r\n  ItemMirror.prototype.listAssociations = function() {\r\n    return Object.keys(this._fragment.associations);\r\n  };\r\n\r\n  /**\r\n   *\r\n   * Throws NullArgumentException if attributeName, GUID, or namespaceURI is\r\n   * null. <br/>\r\n   * Throws InvalidTypeException if attributeName, GUID, or namespaceURI is not\r\n   * a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method getAssociationNamespaceAttribute\r\n   * @return {String} The association namespace attribute with\r\n   * the given attributeName and the given namespaceURI within the\r\n   * association with the given GUID.\r\n   *\r\n   * @param {String} attributeName Name of the attribute to be returned.\r\n   * @param {String} GUID          GUID of the association to return attribute from.\r\n   * @param {String} uri Namspace URI\r\n   *\r\n   */\r\n  ItemMirror.prototype.getAssociationNamespaceAttribute = function(attributeName, GUID, uri) {\r\n    var ns = this._fragment.associations[GUID].namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    return this._fragment.associations[GUID].namespace[uri].attributes[attributeName];\r\n  };\r\n\r\n  /**\r\n   * Sets the association namespace attribute with the given attributeName\r\n   * and the given namespaceURI within the association with the given GUID.\r\n   *\r\n   * Throws NullArgumentException if attributeName, attributeValue, GUID, or\r\n   * namespaceURI is null. <br/>\r\n   * Throws InvalidTypeException if attributeName, attributeValue, GUID, or\r\n   * namespaceURI is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method setAssociationNamespaceAttribute\r\n   *\r\n   * @param {String} attributeName  Name of the attribute to be set.\r\n   * @param {String} attributeValue Value of the attribute to be set\r\n   * @param {String} GUID           GUID of association to set attribute for.\r\n   * @param {String} uri Namespace URI\r\n   *\r\n   */\r\n  ItemMirror.prototype.setAssociationNamespaceAttribute = function(attributeName, attributeValue, GUID, uri) {\r\n    var ns = this._fragment.associations[GUID].namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    this._fragment.associations[GUID].namespace[uri].attributes[attributeName] = attributeValue;\r\n  };\r\n\r\n  /**\r\n   * Adds the given attributeName to the association with the given GUID and\r\n   * namespaceURI.\r\n   *\r\n   * Throws NullArgumentException if attributeName, GUID, or namespaceURI is\r\n   * null. <br/>\r\n   * Throws InvalidTypeException if attributeName, GUID, or namespaceURI is not\r\n   * a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   * Throws an InvalidStateException when the given attributeName has already\r\n   * been added. <br/>\r\n   *\r\n   * @method addAssociationNamespaceAttribute\r\n   *\r\n   * @param {String} attributeName Name of the attribute.\r\n   * @param {String} attributeValue Value of the attribe to be set\r\n   * @param {String} GUID          GUID of the association.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  ItemMirror.prototype.addAssociationNamespaceAttribute = function(attributeName, attributeValue, GUID, uri) {\r\n    var ns = this._fragment.associations[GUID].namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    if (this._fragment.associations[GUID].namespace[uri].attributes[attributeName]) {\r\n      throw XooMLExceptions.invalidState;\r\n    }\r\n    this.setAssociationNamespaceAttribute(attributeName, attributeValue, GUID, uri);\r\n  };\r\n\r\n  /**\r\n   * Removes the given attributeName to the association with the given GUID and\r\n   * namespaceURI.\r\n   *\r\n   * Throws NullArgumentException if attributeName, GUID, or namespaceURI is\r\n   * null. <br/>\r\n   * Throws InvalidTypeException if attributeName, GUID, or namespaceURI is not\r\n   * a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   * Throws an InvalidStateException when the given attributeName is not an\r\n   * attribute. <br/>\r\n   *\r\n   * @method removeAssociationNamespaceAttribute\r\n   *\r\n   * @param {String} attributeName Name of the attribute.\r\n   * @param {String} GUID          GUID of the association.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  ItemMirror.prototype.removeAssociationNamespaceAttribute = function(attributeName, GUID, uri) {\r\n    delete this._fragment.associations[GUID].namespace[uri].attributes[attributeName];\r\n  };\r\n\r\n  /**\r\n   * @method hasAssociationNamespace\r\n   * @return {Boolean} True if the association has the given\r\n   * namespaceURI, else false.\r\n   *\r\n   * @param {String} GUID          GUID of the association.\r\n   * @param {String} uri  Namespace URI\r\n   *\r\n   */\r\n  ItemMirror.prototype.hasAssociationNamespace = function(GUID, uri) {\r\n    var namespace = this._fragment.associations[GUID].namespace[uri];\r\n    if (namespace) { return true; }\r\n    else { return false; }\r\n  };\r\n\r\n  /**\r\n   *\r\n   * Throws NullArgumentException if GUID, namespaceURI is null. <br/>\r\n   * Throws InvalidTypeException if GUID, namespaceURI is not a String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method listAssociationNamespaceAttributes\r\n   * @return {String[]} An array of the association namespace\r\n   * attributes with the given attributeName and the given\r\n   * namespaceURI within the association with the given GUID.\r\n   *\r\n   * @param {String} GUID          GUID of association to list attributes for.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  ItemMirror.prototype.listAssociationNamespaceAttributes = function (GUID, uri) {\r\n    var ns = this._fragment.associations[GUID].namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    return Object.keys(this._fragment.associations[GUID].namespace[uri].attributes);\r\n  };\r\n\r\n  /**\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method getAssociationNamespaceData\r\n   * @return {String} The association namespace data for an\r\n   * association with the given GUID and the given namespaceURI.\r\n   *\r\n   * @param {String} GUID GUID of the association namespace data to\r\n   * returned.\r\n   * @param {String} uri Namespace URI\r\n   */\r\n  self.getAssociationNamespaceData = function (GUID, uri) {\r\n    var ns = this._fragment.associations[GUID].namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    return this._fragment.associations[GUID].namespace[uri].data;\r\n  };\r\n\r\n  /**\r\n   * Sets the association namespace data for an association with the given GUID\r\n   * and given namespaceURI using the given data.\r\n   *\r\n   * Throws NullArgumentException if data, GUID, or namespaceURI is null. <br/>\r\n   * Throws InvalidTypeException if data, GUID, or namespaceURI is not a\r\n   * String. <br/>\r\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\r\n   *\r\n   * @method setAssociationNamespaceData\r\n   *\r\n   * @param {String} data          Association namespace data to set. Must be\r\n   *                               valid fragmentNamespaceData.\r\n   * @param {String} GUID          GUID of the association namespace data to set.\r\n   */\r\n  ItemMirror.prototype.setAssociationNamespaceData = function (data, GUID, uri) {\r\n    var ns = this._fragment.associations[GUID].namespace;\r\n    ns[uri] = ns[uri] || {};\r\n    ns[uri].attributes = ns[uri].attributes || {};\r\n\r\n    this._fragment.associations[GUID].namespace[uri].data = data;\r\n  };\r\n\r\n  /**\r\n   * Uses the specified ItemDriver and SyncDriver to synchronize the\r\n   * local ItemMirror object changes. This is an implmentation of Synchronization\r\n   * Driver which modifies the XooML Fragment according to the real structure\r\n   * under the item described.\r\n   *\r\n   * @method sync\r\n   *\r\n   * @param {Function} callback Function to execute once finished.\r\n   *  @param {Object}   callback.error Null if no error has occurred\r\n   *                    in executing this function, else an contains\r\n   *                    an object with the error that occurred.\r\n   * @private\r\n   */\r\n  ItemMirror.prototype._sync = function (callback) {\r\n    var self = this;\r\n\r\n    self._syncDriver.sync(callback);\r\n  };\r\n\r\n  /**\r\n   * Reloads the XooML Fragment\r\n   *\r\n   * @method refresh\r\n   *\r\n   * @param {Function} callback Function to execute once finished.\r\n   *  @param {Object}   callback.error Null if no error has occurred\r\n   *                    in executing this function, else an contains\r\n   *                    an object with the error that occurred.\r\n   */\r\n  ItemMirror.prototype.refresh = function(callback) {\r\n    var self = this;\r\n\r\n    self._sync( function(error) {\r\n      // This error means that sync changed the fragment\r\n      // We then will reload the fragment based on the new XooML\r\n      if (error === XooMLExceptions.itemMirrorNotCurrent) {\r\n        self._xooMLDriver.getXooMLFragment(resetFragment);\r\n      } else if (error) {\r\n        callback(error);\r\n      } else {\r\n        self._xooMLDriver.getXooMLFragment(resetFragment);\r\n      }\r\n    });\r\n\r\n    function resetFragment(error, content){\r\n      if (error) return callback(error);\r\n\r\n      self._fragment = new FragmentEditor({text: content});\r\n      return callback(false);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @method getCreator\r\n   *\r\n   * @return {Object} The itemMirror that created this current\r\n   * itemMirror, if it has one. Note that this isn't the same as\r\n   * asking for a 'parent,' since multiple itemMirrors can possibly\r\n   * link to the same one\r\n   *\r\n   */\r\n  ItemMirror.prototype.getCreator = function () {\r\n    return this._creator;\r\n  };\r\n\r\n\r\n  /**\r\n   * Saves the itemMirror object, writing it out to the\r\n   * fragment. Fails if the GUID generated on last write for the\r\n   * itemMirror and the XooML fragment don't match.\r\n   *\r\n   * @method save\r\n   *\r\n   * @param callback\r\n   *  @param callback.error Returns false if everything went ok,\r\n   *  otherwise returns the error\r\n   */\r\n  ItemMirror.prototype.save = function(callback) {\r\n    var self = this;\r\n\r\n    self._sync(postSync);\r\n\r\n    function postSync(error) {\r\n      if (error) return callback(error);\r\n\r\n      return self._unsafeWrite(postWrite);\r\n    }\r\n\r\n    function postWrite(error) {\r\n      return callback(error);\r\n    }\r\n  };\r\n\r\n/**\r\n * Checks if the AssociatedItem String passed into it is a URL or not.\r\n *\r\n * @method _isURL\r\n * @return {Boolean} True if it is an HTTP URL, false otherwise\r\n * (HTTPS will fail)\r\n * @private\r\n * @param {String} URL\r\n */\r\n  self._isURL = function (URL){\r\n    return /^http:\\/\\//.exec(URL);\r\n  };\r\n\r\n\r\n// This makes the pacakge accessible as a node module\r\nmodule.exports = ItemMirror;\r\n\r\n// This attaches the library as a global if it doesn't already exist\r\nif (window) { // Checks for window object so we don't break potential node usage\r\n  window.ItemMirror = window.ItemMirror || ItemMirror\r\n}","/**\r\n * An implementation of SyncDriver which syncronizes the XooML so that\r\n * it reflects the storage. This implementation ensures that only the\r\n * XooML is modified, and that the user's storage is never modified,\r\n * safely protecting any data.\r\n *\r\n * For ItemMirror core developers only. Enable protected to see.\r\n *\r\n * @class SyncDriver\r\n *\r\n * @constructor\r\n * @param {Object} itemMirror The itemMirror object which you wish to\r\n * synchronize\r\n *\r\n * @protected\r\n */\r\n\r\n\r\n'use strict'\r\n\r\nvar XooMLExceptions = require('./XooMLExceptions');\r\nvar XooMLConfig = require('./XooMLConfig');\r\nvar XooMLUtil = require('./XooMLUtil');\r\nvar FragmentEditor = require('./FragmentEditor');\r\nvar AssociationEditor = require('./AssociationEditor');\r\nvar XooMLExceptions = require('./XooMLExceptions');\r\n\r\n\r\n  var self;\r\n\r\n  function SyncDriver(itemMirror) {\r\n    var self = this;\r\n    self._itemMirror = itemMirror;\r\n    self._itemDriver = itemMirror._itemDriver;\r\n    self._xooMLDriver = itemMirror._xooMLDriver;\r\n\r\n\r\n  }\r\n\r\n  /**\r\n   * Helper method that allows for sorting of objects by the localItem\r\n   *\r\n   * @method _nameCompare\r\n   * @private\r\n   * @protected\r\n   */\r\n  function _localItemCompare(a, b) {\r\n    if (a.commonData.localItem > b.commonData.localItem) return 1;\r\n    else if (a.commonData.localItem < b.commonData.localItem) return -1;\r\n    else return 0;\r\n  }\r\n\r\n  /**\r\n   * Synchonizes the itemMirror object.\r\n   *\r\n   * @method sync\r\n   *\r\n   * @param {Function} callback Function to execute once finished.\r\n   *  @param {Object}   callback.error Null if no error has occurred\r\n   *                    in executing this function, else an contains\r\n   *                    an object with the error that occurred.\r\n   *\r\n   * @protected\r\n   */\r\n  SyncDriver.prototype.sync = function(callback) {\r\n    var self = this,\r\n        itemAssociations;\r\n\r\n    self._itemDriver.listItems(self._itemMirror._groupingItemURI,\r\n                               processItems);\r\n\r\n    function processItems(error, associations){\r\n      if (error) return callback(error);\r\n\r\n      itemAssociations = associations;\r\n      self._xooMLDriver.getXooMLFragment(processXooML);\r\n    }\r\n\r\n    function processXooML(error, xooMLContent) {\r\n      // A 404 error is dropbox telling us that the file doesn't\r\n      // exist. In that case we just write the file\r\n      if (error === 404) {\r\n        var fragmentString = self._itemMirror._fragment.toString();\r\n        return self._xooMLDriver.setXooMLFragment( fragmentString, function(error) {\r\n          if (error) callback(error);\r\n          else callback(false);\r\n        });\r\n      } else if (error) {\r\n        return callback(error);\r\n      }\r\n\r\n      // Keeps track of the index in the xooMLassociations so that\r\n      // we don't waste time searching from the beginning\r\n      var xooMLIdx = 0;\r\n      // Keeps track of whether there are any changes that need to be made\r\n      var synchronized = true;\r\n      var xooMLAssociations;\r\n\r\n      self._fragmentEditor = new FragmentEditor({text: xooMLContent});\r\n\r\n      xooMLAssociations = Object.keys(self._fragmentEditor.associations)\r\n      // Turns the associative array into a regular array for iteration\r\n        .map( function(guid) {\r\n          return self._fragmentEditor.associations[guid];\r\n        })\r\n      // filters out any phantoms\r\n\t.filter( function(assoc) {\r\n\t  return assoc.commonData.localItem !== null;\r\n\t});\r\n\r\n      // No guarantee that the storage API sends results sorted\r\n      itemAssociations.sort(_localItemCompare);\r\n      xooMLAssociations.sort(_localItemCompare);\r\n\r\n      // Gets the localItems in a separate array, but in needed sorted order\r\n      var itemLocals = itemAssociations.map( function (assoc) {return assoc.commonData.localItem;} );\r\n      var xooMLLocals = xooMLAssociations.map( function (assoc) {return assoc.commonData.localItem;} );\r\n\r\n      itemLocals.forEach( function(localItem, itemIdx) {\r\n\tvar search = xooMLLocals.lastIndexOf(localItem, xooMLIdx);\r\n\t// Create association\r\n\tif (search === -1) {\r\n\t  synchronized = false;\r\n\t  // Case 6/7 only, other cases won't be handled\r\n          var association = itemAssociations[itemIdx];\r\n          self._fragmentEditor.associations[association.commonData.ID] = association;\r\n\t} else {\r\n\t  // Deletes any extraneous associations\r\n\t  xooMLAssociations\r\n\t    .slice(xooMLIdx, search)\r\n\t    .forEach( function(assoc) {\r\n\t      synchronized = false;\r\n              delete self._fragmentEditor.associations[assoc.guid];\r\n\t    });\r\n\t  xooMLIdx = search + 1;\r\n\t}\r\n      });\r\n      // Any remaining associations need to be deleted because they don't exist\r\n      xooMLAssociations\r\n\t.slice(xooMLIdx, xooMLLocals.length)\r\n\t.forEach( function(assoc) {\r\n\t  synchronized = false;\r\n          delete self._fragmentEditor.associations[assoc.commonData.ID];\r\n\t});\r\n\r\n      // Only save fragment if needed\r\n      if (!synchronized) {\r\n        self._fragmentEditor.updateID(); // generate a new guid for GUIDGeneratedOnLastWrite;\r\n        // Writes out the fragment\r\n        self._xooMLDriver.setXooMLFragment(self._fragmentEditor.toString(), function(error) {\r\n          if (error) return callback(error);\r\n\r\n          return callback(false);\r\n        });\r\n      } else return callback(false);\r\n    }\r\n  };\r\n\r\nmodule.exports = SyncDriver;","/**\r\n * Configuration variables for XooML.js\r\n *\r\n * For ItemMirror core developers only. Enable protected to see.\r\n *\r\n * @class XooMLConfig\r\n * @static\r\n *\r\n * @protected\r\n */\r\nmodule.exports = {\r\n  // default schema version\r\n  schemaVersion: \"0.54\",\r\n\r\n  // default schema location\r\n  schemaLocation: \"http://kftf.ischool.washington.edu/xmlns/xooml\",\r\n\r\n  // XooMLFragment file name for XooML2.xmlns\r\n  xooMLFragmentFileName: \"XooML2.xml\",\r\n\r\n  // Maximum file length for upgradeAssociation localItemURI truncation\r\n  maxFileLength: 50,\r\n\r\n  // Case 1\r\n  createAssociationSimple: {\r\n    \"displayText\": true\r\n  },\r\n\r\n  // Case 2 and 3\r\n  // localItemRequested exists:> case 3\r\n  createAssociationLinkNonGrouping: {\r\n    \"displayText\": true,        // String\r\n    \"itemURI\": true,            // String\r\n    \"localItemRequested\": false // String\r\n  },\r\n\r\n  // Case 4 and 5\r\n  // localItemRequested:== true:> Case 5\r\n  createAssociationLinkGrouping: { // Case 3\r\n    \"displayText\": true,\r\n    \"groupingItemURI\": true,\r\n    \"xooMLDriverURI\": true\r\n  },\r\n\r\n  // Case 6 and 7\r\n  createAssociationCreate: {\r\n    \"displayText\": true,\r\n    \"itemName\": true,\r\n    \"isGroupingItem\": true\r\n  }\r\n}","/**\r\n * An XooML utility interacts with an storage and is responsible for\r\n * reading and writing XooML fragments. This is an implementation of XooML utility\r\n * using Dropbox as the storage.\r\n *\r\n * This specific version is for google drive\r\n *\r\n * For ItemMirror core developers only. Enable protected to see.\r\n *\r\n * @class XooMLDriver\r\n * @constructor\r\n *\r\n * @param {Object} options Data to construct a new XooMLU with\r\n * @param {String} options.fragmentURI The URI of fragment\r\n * contains the XooML\r\n * @param {String} options.utilityURI URI of the utility\r\n * @param {Object} options.dropboxClient Authenticated dropbox client\r\n *\r\n * @protected\r\n */\r\n\r\nvar XooMLExceptions = require('./XooMLExceptions');\r\nvar XooMLConfig = require('./XooMLConfig');\r\n\r\n  var _CONSTRUCTOR_OPTIONS = {\r\n      // This is the location of the driver\r\n      // Not currently used, but will eventually be specified\r\n      driverURI: true,\r\n      // This is the location of the fragment (XooML2.xml) for a given\r\n      // interface. In the case of google drive it's just the first result of\r\n      // the root folder with a search for the exact file XooML2.xml. While\r\n      // there's a more specific ID for the file itself, we can't really\r\n      // use that because there's no pointer to that initial file.\r\n\r\n      // This means that if there are two XooML2.xml files in the root\r\n      // directory, it's then possible that one will get ignored\r\n    };\r\n\r\n  /**\r\n   * Constructs a XooMLDriver for reading/writing XooML fragment.\r\n   *\r\n   * @method XooMLDriver\r\n   *\r\n   * @param {Object} options A list of options for construction\r\n   * @param {Function} callback A function to call after completion\r\n   *\r\n   * @protected\r\n   */\r\n  function XooMLDriver(options, callback) {\r\n    var self = this;\r\n\r\n    if (!options.clientInterface) {\r\n      throw new Error('Missing client interface in options!');\r\n    }\r\n\r\n    // The parent URI tells us what 'folder', the XooML should be put inside\r\n    // of. Root is a special URI for google drive, otherwise it should be an\r\n    // id\r\n    this._parentURI = options.associatedItem || 'root';\r\n\r\n    // Client Interface is whatever object that a given client hands back\r\n    // after the authorization step. We use it to make sending and recieving\r\n    // requests extremely simple.\r\n\r\n    // Note: This does assume that the client has already been authenticated\r\n    // If not it could lead to potential errors. gapi should be set to the\r\n    // clientInterface\r\n    this.clientInterface = options.clientInterface;\r\n\r\n    // The fragmentURI is the id of the XooML file. It may or may not exist\r\n    this._fragmentURI = options.fragmentURI ? options.fragmentURI : null;\r\n\r\n    // This comes from the usage of teh updated API, we have to jump through\r\n    // several hoops to geth the authentication token that we're looking for\r\n    var authResponse = this.clientInterface.auth2.getAuthInstance()\r\n      .currentUser.get()\r\n      .getAuthResponse();\r\n\r\n    // This is the authorized header, so we can easily make requests via ajax.\r\n    // If we get request errors, make sure that this header is correct, and\r\n    // doesn't constantly change\r\n    this._AUTH_HEADER = { Authorization: 'Bearer ' + authResponse.access_token };\r\n    this._DRIVE_FILE_API = 'https://www.googleapis.com/drive/v2/files/';\r\n\r\n    return callback(false, self);\r\n  }\r\n\r\n\r\n  /**\r\n   * Creates a request for a given fileID and executes the request\r\n   * @method _readFile\r\n   * @param  {Function} callback Function with the XML string response\r\n   * @param {String} id ID of the file you want to get download\r\n   */\r\n  XooMLDriver.prototype._readFile = function(callback) {\r\n    var self = this;\r\n\r\n    $.ajax({\r\n      url:  self._DRIVE_FILE_API + self._fragmentURI,\r\n      // Required to actually initiate a download\r\n      data: 'alt=media',\r\n      // If this isn't specified, we get an XMLDocument back. We want a\r\n      // string for maximum flexibility.\r\n      dataType: 'text',\r\n      // Note, if the authorization header is messed up, it will give us\r\n      // an error that tells us we need to sign in and have reached our\r\n      // limit.\r\n      headers: self._AUTH_HEADER\r\n    }).then(function(xml_text) {\r\n      callback(false, xml_text);\r\n    });\r\n  };\r\n\r\n  // This is a helper function that searches for the xml file in a folder when\r\n  // necessary\r\n  XooMLDriver.prototype._searchXooML = function(callback, folderID) {\r\n    var self = this;\r\n\r\n    // This query means return the file with the title XooML2.xml in the\r\n    // root directory.\r\n    // Details on the gapi query syntax: https://developers.google.com/drive/web/search-parameters\r\n    var query = 'title = \\'' + XooMLConfig.xooMLFragmentFileName + '\\' and \\'' + folderID + '\\' in parents';\r\n    var request = this.clientInterface.client.drive.files.list({\r\n      'maxResults': 10,\r\n      'q': query\r\n    });\r\n    request.execute(function(resp) {\r\n      // Now that we've made the request, we can extract the fileID and\r\n      // read the file contents\r\n      var xoomlItem = resp.items[0];\r\n\r\n      if (resp.items.length > 1) {\r\n        console.warn('Mutliple XooML files found, only using first one. Please delete extras');\r\n        console.log(resp.items);\r\n      }\r\n\r\n      // This means that there currently is no XooML file\r\n      if (!xoomlItem) {\r\n        // This error should be standardized somewhere and made into a number\r\n        // that way all drivers can  share it\r\n        return callback('XooML Not Found'); \r\n      }\r\n\r\n      self._fragmentURI = xoomlItem.id;\r\n      self._readFile(callback);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reads and returns a XooML fragment\r\n   * @method getXooMLFragment\r\n   * @param {Function} callback(content) Function to be called when self function is finished with it's operation. content is the content of the XooML fragment.\r\n   *\r\n   * @protected\r\n   */\r\n  XooMLDriver.prototype.getXooMLFragment = function (callback) {\r\n    var self = this;\r\n\r\n    // If we don't have the fragmentURI, we need this for searching\r\n    if (!this._fragmentURI) {\r\n      console.log('SEARCH CASE');\r\n      return this._searchXooML(callback, this._parentURI);\r\n    } else {\r\n      // General case, where we don't need to do a query\r\n      console.log('GENERAL CASE');\r\n      this._readFile(callback, this._fragmentURI);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Writes a XooML fragment\r\n   * @method setXooMLFragment\r\n   * @param {String} xmlString the content of the XooML fragment\r\n   * @param {Function} callback(content) Function to be called when self function is finished with it's operation. content is the content of the XooML fragment.\r\n   *\r\n   * @protected\r\n   */\r\n  XooMLDriver.prototype.setXooMLFragment = function (xmlString, callback) {\r\n    var self = this;\r\n    var mimeType = 'text/xml';\r\n\r\n    // Used when updating an already existing XooML.xml\r\n    function updateFile(callback) {\r\n      var request = gapi.client.request({\r\n        path: '/upload/drive/v2/files/' + self._fragmentURI,\r\n        method: 'PUT',\r\n        params: {'uploadType': 'media'},\r\n        body: xmlString\r\n      });\r\n\r\n      request.execute(function(response) {\r\n        callback(false);\r\n      }, function(error) {\r\n        console.error(error);\r\n        callback(error);\r\n      });\r\n    }\r\n\r\n    // Used when writing a new XooML file\r\n    function insertFile(fileData, callback) {\r\n      var boundary = '-------314159265358979323846';\r\n      var delimiter = \"\\r\\n--\" + boundary + \"\\r\\n\";\r\n      var close_delim = \"\\r\\n--\" + boundary + \"--\";\r\n\r\n      var reader = new FileReader();\r\n      reader.readAsBinaryString(fileData);\r\n      reader.onload = function(e) {\r\n        var contentType = fileData.type || 'application/octet-stream';\r\n        var metadata = {\r\n          'title': XooMLConfig.xooMLFragmentFileName,\r\n          'mimeType': contentType,\r\n          'parents': [{\r\n            \"kind\": \"drive#parentReference\",\r\n            \"id\": self._parentURI,\r\n          }]\r\n        };\r\n\r\n        console.log('XooML Metadata for writing');\r\n        console.log(metadata);\r\n\r\n        var base64Data = btoa(reader.result);\r\n        var multipartRequestBody =\r\n            delimiter +\r\n            'Content-Type: application/json\\r\\n\\r\\n' +\r\n            JSON.stringify(metadata) +\r\n            delimiter +\r\n            'Content-Type: ' + contentType + '\\r\\n' +\r\n            'Content-Transfer-Encoding: base64\\r\\n' +\r\n            '\\r\\n' +\r\n            base64Data +\r\n            close_delim;\r\n\r\n        var request = gapi.client.request({\r\n            'path': '/upload/drive/v2/files',\r\n            'method': 'POST',\r\n            'params': {'uploadType': 'multipart'},\r\n            'headers': {\r\n              'Content-Type': 'multipart/mixed; boundary=\"' + boundary + '\"'\r\n            },\r\n            'body': multipartRequestBody});\r\n        request.execute(function(response) {\r\n          // The response is the newly created file, and we set the fragment ID to that\r\n          // so that future requests don't require additional searches\r\n          self._fragmentURI = response.id\r\n          callback(false);\r\n        }, function(response) {\r\n          callback('Could not write out XooML Fragment', response);\r\n        });\r\n      };\r\n    }\r\n\r\n    var blob = new Blob([xmlString], {type: mimeType, fileName: XooMLConfig.xooMLFragmentFileName});\r\n\r\n\r\n    // Update or create the file depending on the circumstances\r\n    if (self._fragmentURI) {\r\n      updateFile(callback);\r\n    } else {\r\n      insertFile(blob, callback);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Check if the XooML fragment exists\r\n   * @method checkExists\r\n   * @param {Function} callback Function to be called when\r\n   * self function is finished with it's operation.\r\n   *  @param {String} callback.error Dropbox error if there is one\r\n   *  @param {Boolean} callback.result True if the fragment exists and\r\n   *  false otherwis\r\n   *\r\n   * @protected\r\n   */\r\n  XooMLDriver.prototype.checkExists = function (callback) {\r\n    var self = this;\r\n\r\n    // If we have the URI, first make a direct request for that\r\n    if (this._fragmentURI) {\r\n      // A simple get request will suffice\r\n      $.get({\r\n        url: _DRIVE_FILE_API + self._fragmentURI,\r\n        headers: _AUTH_HEADER\r\n      }).then(function() {\r\n        callback(false);\r\n      }).fail(function() {\r\n        callback('XooML file: ' + self._fragmentURI + ' not found');\r\n      });\r\n    // In this case, we do a search for XooML in the folder\r\n    } else {\r\n      var query = 'title = \\'' + XooMLConfig.xooMLFragmentFileName + '\\' and \\'' + self._parentURI + '\\' in parents';\r\n      var request = this.clientInterface.client.drive.files.list({\r\n        'maxResults': 1,\r\n        'q': query\r\n      });\r\n      request.execute(function(resp) {\r\n        // Simply check if there were any results\r\n        if (resp.items[0]) {\r\n          callback(false);\r\n        } else {\r\n          callback('XooML file not found in directory: ' + self._parentURI);\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\nmodule.exports = XooMLDriver;","/**\r\n * Collection of exceptions associated with the XooML tools.\r\n *\r\n * For ItemMirror core developers only. Enable protected to see.\r\n *\r\n * @class XooMLExceptions\r\n * @static\r\n *\r\n * @protected\r\n */\r\nmodule.exports = {\r\n  /**\r\n   * Thrown when a method is not yet implemented.\r\n   *\r\n   * @event NotImplementedException\r\n   *\r\n   * @protected\r\n   */\r\n  notImplemented: \"NotImplementedException\",\r\n\r\n  /**\r\n   * Thrown when a required property from a method's options is missing.\r\n   *\r\n   * @event MissingParameterException\r\n   *\r\n   * @protected\r\n   */\r\n  missingParameter: \"MissingParameterException\",\r\n\r\n  /**\r\n   * Thrown when an argument is given a null value when it does not accept null\r\n   * values.\r\n   *\r\n   * @event NullArgumentException\r\n   *\r\n   * @protected\r\n   */\r\n  nullArgument: \"NullArgumentException\",\r\n\r\n  /**\r\n   * Thrown when an argument is given a value with a different type from the\r\n   * expected type.\r\n   *\r\n   * @event InvalidTypeException\r\n   *\r\n   * @protected\r\n   */\r\n  invalidType: \"InvalidTypeException\",\r\n\r\n  /**\r\n   * Thrown when an a method is called when the object is in invalid state\r\n   * given what the method expected.\r\n   *\r\n   * @event InvalidStateArgument\r\n   *\r\n   * @protected\r\n   */\r\n  invalidState: \"InvalidStateArgument\",\r\n\r\n  /**\r\n   * Thrown after receiving an exception from XooMLU Storage\r\n   *\r\n   * @event XooMLUException\r\n   *\r\n   * @protected\r\n   */\r\n  xooMLUException: \"XooMLUException\",\r\n\r\n  /**\r\n   * Thrown after receiving an exception from ItemU Storage\r\n   *\r\n   * @event ItemUException\r\n   *\r\n   * @protected\r\n   */\r\n  itemUException: \"ItemUException\",\r\n\r\n  /**\r\n   * Thrown after an association was upgraded that could not be upgraded.\r\n   *\r\n   * @event NonUpgradeableAssociationException\r\n   *\r\n   * @protected\r\n   */\r\n  nonUpgradeableAssociationException: \"NonUpgradeableAssociationException\",\r\n\r\n  /**\r\n   * Thrown after an argument was passed in an invalid state than expected.\r\n   *\r\n   * @event InvalidArgumentException\r\n   *\r\n   * @protected\r\n   */\r\n  invalidArgument: \"InvalidOptionsException\",\r\n\r\n  /**\r\n   * Thrown after expecting a file or folder not to exist when it does.\r\n   *\r\n   * @event FileOrFolderAlreadyExistsException\r\n   *\r\n   * @protected\r\n   */\r\n  itemAlreadyExists: \"ItemAlreadyExistsException\",\r\n\r\n  /**\r\n   * Thrown when expecting the ItemMirror to be current, and it is not.\r\n   *\r\n   * @event FileOrFolderAlreadyExistsException\r\n   *\r\n   * @protected\r\n   */\r\n  itemMirrorNotCurrent: \"ItemMirrorNotCurrent\"\r\n}","/**\r\n * Collection of type checking, exception throwing, utility methods for the\r\n * XooML tools.\r\n *\r\n * For ItemMirror core developers only. Enable protected to see.\r\n *\r\n * @class XooMLUtil\r\n * @static\r\n *\r\n * @protected\r\n */\r\n\r\n 'use strict'\r\n\r\n var XooMLExceptions = require('./XooMLExceptions');\r\n var XooMLConfig = require('./XooMLConfig'); \r\n\r\n  var\r\n    _GUIDRegex = /\\[([a-z0-9]{8}(?:-[a-z0-9]{4}){3}-[a-z0-9]{12})\\]/i,\r\n    _TYPES = {\r\n      \"[object Boolean]\": \"boolean\",\r\n      \"[object Number]\": \"number\",\r\n      \"[object String]\": \"string\",\r\n      \"[object Function]\": \"function\",\r\n      \"[object Array]\": \"array\",\r\n      \"[object Date]\": \"date\",\r\n      \"[object RegExp]\": \"regexp\",\r\n      \"[object Object]\": \"object\",\r\n      \"[object Error]\": \"error\"\r\n    };\r\n\r\n  var XooMLUtil = {\r\n    /**\r\n     * Checks if each option within the given checkedOptions is a property of\r\n     * the given options.\r\n     *\r\n     * @method hasOptions\r\n     *\r\n     * @param {Object}  checkedOptions Array of strings for each expected option.\r\n     * @param {Object} options         Options given to a function.\r\n     *\r\n     * @protected\r\n     */\r\n    hasOptions: function (checkedOptions, options) {\r\n      if (!checkedOptions || !options) {\r\n        throw XooMLExceptions.nullArgument;\r\n      }\r\n      if (!XooMLUtil.isObject(checkedOptions) ||\r\n          !XooMLUtil.isObject(options)) {\r\n        throw XooMLExceptions.invalidType;\r\n      }\r\n      var checkedOption, isRequiredOption, missingOptionalParamCount;\r\n\r\n      missingOptionalParamCount = 0;\r\n\r\n      if (Object.keys(options).length <= Object.keys(checkedOptions).length) {\r\n        for (checkedOption in checkedOptions) {\r\n          if (checkedOptions.hasOwnProperty(checkedOption)) {\r\n            isRequiredOption = checkedOptions[checkedOption];\r\n\r\n            if (!options.hasOwnProperty(checkedOption)) {\r\n              if (isRequiredOption) {\r\n                return false;\r\n              } else {\r\n                missingOptionalParamCount += 1;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        return false;\r\n      }\r\n\r\n      return Object.keys(options).length <=\r\n        Object.keys(checkedOptions).length - missingOptionalParamCount;\r\n    },\r\n\r\n    // throws exceptions for callbacks since null callbacks mean the program can't continue\r\n    checkCallback: function (callback) {\r\n      if (callback) {\r\n        if (!XooMLUtil.isFunction(callback)) {\r\n          throw XooMLExceptions.invalidType;\r\n        }\r\n      } else {\r\n        throw XooMLExceptions.nullArgument;\r\n      }\r\n    },\r\n\r\n    isGUID: function (GUID) {\r\n      if (XooMLUtil.getType(GUID) === \"string\") {\r\n        return true; // TODO implement guid checking\r\n      } else {\r\n        return false;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns if the given value is an array.\r\n     *\r\n     * Throws NullArgumentException when value is null. <br/>\r\n     *\r\n     * @method isArray\r\n     *\r\n     * @param {Object} value Given object have it's type checked.\r\n     *\r\n     * @protected\r\n     */\r\n    isArray: function (value) {\r\n      return XooMLUtil.getType(value) === \"array\";\r\n    },\r\n\r\n    /**\r\n     * Returns if the given value is an object.\r\n     *\r\n     * Throws NullArgumentException when value is null. <br/>\r\n     *\r\n     * @method isObject\r\n     *\r\n     * @param {Object} value Given object have it's type checked.\r\n     *\r\n     * @return {Boolean} True if the given value is an Object, else false.\r\n     *\r\n     * @protected\r\n     */\r\n    isObject: function (value) {\r\n      return XooMLUtil.getType(value) === \"object\";\r\n    },\r\n\r\n    /**\r\n     * Returns if the given value is an function.\r\n     *\r\n     * Throws NullArgumentException when value is null. <br/>\r\n     *\r\n     * @method isFunction\r\n     *\r\n     * @param {Object} value Given object have it's type checked.\r\n     *\r\n     * @return {Boolean} True if the given value is a Function, else false.\r\n     *\r\n     * @protected\r\n     */\r\n    isFunction: function (value) {\r\n      return value !== null;\r\n      //return XooMLUtil.getType(value) === \"function\"; TODO figure out why this doesn't work\r\n    },\r\n\r\n    /**\r\n     * Returns if the given value is an string.\r\n     *\r\n     * Throws NullArgumentException when value is null. <br/>\r\n     *\r\n     * @method isString\r\n     *\r\n     * @param {Object} value Given object have it's type checked.\r\n     *\r\n     * @return {Boolean} True if the given value is a String, else false.\r\n     *\r\n     * @protected\r\n     */\r\n    isString: function (value) {\r\n      return XooMLUtil.getType(value) === \"string\";\r\n    },\r\n\r\n    isBoolean: function (value) {\r\n      return XooMLUtil.getType(value) === \"boolean\";\r\n    },\r\n\r\n    /**\r\n     * Generates a GUID.\r\n     *\r\n     * @method generateGUID\r\n     *\r\n     * @return {String} Randomly generated GUID.\r\n     *\r\n     * @protected\r\n     */\r\n    generateGUID: function () {\r\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\r\n        return v.toString(16);\r\n      });\r\n    },\r\n\r\n    getType: function (obj) {\r\n      if (obj === null) {\r\n        return String(obj);\r\n      }\r\n      return typeof obj === \"object\" ||\r\n        typeof obj === \"function\" ? _TYPES[obj.toString()] || \"object\" : typeof obj;\r\n    },\r\n\r\n    endsWith: function (string, suffix) {\r\n      return string.indexOf(suffix, string.length - suffix.length) !== -1;\r\n    },\r\n\r\n    // http://stackoverflow.com/questions/728360/most-elegant-way-to-clone-a-javascript-object\r\n    clone: function (obj) {\r\n      var copy;\r\n      // Handle the 3 simple types, and null or undefined\r\n      if (null === obj || \"object\" != typeof obj) return obj;\r\n\r\n      // Handle Date\r\n      if (obj instanceof Date) {\r\n        copy = new Date();\r\n        copy.setTime(obj.getTime());\r\n        return copy;\r\n      }\r\n\r\n      // Handle Array\r\n      if (obj instanceof Array) {\r\n        copy = [];\r\n        for (var i = 0, len = obj.length; i < len; i++) {\r\n          copy[i] = XooMLUtil.clone(obj[i]);\r\n        }\r\n        return copy;\r\n      }\r\n\r\n      // Handle Object\r\n      if (obj instanceof Object) {\r\n        copy = {};\r\n        for (var attr in obj) {\r\n          if (obj.hasOwnProperty(attr)) copy[attr] = XooMLUtil.clone(obj[attr]);\r\n        }\r\n        return copy;\r\n      }\r\n\r\n      throw XooMLExceptions.invalidType;\r\n    }\r\n  };\r\n\r\nmodule.exports = XooMLUtil;"],"sourceRoot":"/source/"}
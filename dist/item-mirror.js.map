{"version":3,"sources":["node_modules/browser-pack/_prelude.js","scripts/AssociationEditor.js","item-mirror.js","scripts/FragmentEditor.js","scripts/ItemMirror.js","scripts/SyncDriver.js","scripts/XooMLConfig.js","scripts/XooMLExceptions.js","scripts/XooMLUtil.js","scripts/google-item-driver.js","scripts/google-xooml-driver.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","AssociationEditor","options","self","this","element","_fromElement","commonData","XooMLExceptions","missingParameter","_fromOptions","dataElems","uri","elem","ID","getAttribute","_ID_ATTR","displayText","_DISPLAY_TEXT_ATTR","associatedXooMLFragment","_ASSOCIATED_XOOML_FRAGMENT_ATTR","associatedXooMLDriver","_ASSOCIATED_XOOML_DRIVER_ATTR","associatedSyncDriver","_ASSOCIATED_SYNC_DRIVER_ATTR","associatedItemDriver","_ASSOCIATED_ITEM_DRIVER_ATTR","associatedItem","_ASSOCIATED_ITEM_ATTR","localItem","_LOCAL_ITEM_ATTR","isGrouping","JSON","parse","_IS_GROUPING_ATTR","publicURL","_PUBLIC_URL","namespace","getElementsByTagName","_NAMESPACE_ELEMENT_NAME","namespaceURI","attributes","name","localName","getAttributeNS","data","textContent","nullArgument","XooMLUtil","generateGUID","_ELEMENT_NAME","prototype","toElement","associationElem","document","createElementNS","Object","keys","forEach","key","setAttribute","nsElem","attrName","setAttributeNS","appendChild","./XooMLExceptions","./XooMLUtil",2,"FragmentEditor","text","_fromString","associations","displayName","schemaLocation","schemaVersion","itemDriver","itemDescribed","syncDriver","xooMLDriver","GUIDGeneratedOnLastWrite","assoc","guid","parser","DOMParser","doc","parseFromString","children","associationElems","fragmentNamespaceElement","_SCHEMA_VERSION_ATTR","_SCHEMA_LOCATION_ATTR","_ITEM_DESCRIBED_ATTR","_DISPLAY_NAME_ATTR","_ITEM_DRIVER_ATTR","_SYNC_DRIVER_ATTR","_XOOML_DRIVER_ATTR","_GUID_ATTR","_ASSOCIATION_ELEMENT_NAME","_ASSOCIATION_ID_ATTR","_ITEM_MIRROR_NS","updateID","fragmentElem","attrValue","id","toString","serializer","XMLSerializer","serializeToString","./AssociationEditor",3,"ItemMirror","callback","specialConstruction","xml","join","_fragment","regularConstruction","_xooMLDriverClient","clientInterface","_itemDriverClient","_xooMLDriver","_itemDriver","_syncDriver","_creator","creator","_groupingItemURI","groupingItemURI","_newItemMirrorOptions","fragmentURI","xooMLFragmentURI","XooMLDriver","loadXooMLDriver","error","driver","getXooMLFragment","processXooML","fragmentString","ItemDriver","createFromItemDriver","createFromXML","SyncDriver","refresh","listItems","buildFragment","setXooMLFragment","checkCallback","getDisplayName","setDisplayName","getSchemaVersion","getSchemaLocation","getURIforItemDescribed","getPublicURL","GUID","getAssociationDisplayText","setAssociationDisplayText","getAssociationLocalItem","getAssociationAssociatedItem","getFragmentNamespaceAttribute","attributeName","ns","setFragmentNamespaceAttribute","attributeValue","addFragmentNamespaceAttribute","invalidState","removeFragmentNamespaceAttribute","hasFragmentNamespace","listFragmentNamespaceAttributes","getFragmentNamespaceData","setFragmentNamespaceData","createItemMirrorForAssociatedGroupingItem","xooMLOptions","itemOptions","syncOptions","association","dropboxXooMLUtility","driverURI","dropboxClient","dropboxItemUtility","mirrorSyncUtility","utilityURI","DropboxItemMirror","driveXooMLUtility","gapi","driveItemUtility","isAssociationAssociatedItemGrouping","itemMirror","createAssociation","saveOutFragment","save","isFunction","invalidType","isObject","isGroupingItem","createGroupingItem","itemURI","isAssociationPhantom","copyAssociation","moveAssociation","deleteAssociation","deleteContent","isPhantom","_unsafeWrite","path","deleteGroupingItem","postDelete","deleteNonGroupingItem","isGUID","upgradeAssociation","renameAssociationLocalItem","newName","postSave","rename","postMove","postWrite","postRefresh","listAssociations","getAssociationNamespaceAttribute","setAssociationNamespaceAttribute","addAssociationNamespaceAttribute","removeAssociationNamespaceAttribute","hasAssociationNamespace","listAssociationNamespaceAttributes","getAssociationNamespaceData","setAssociationNamespaceData","_sync","sync","resetFragment","content","itemMirrorNotCurrent","getCreator","postSync","_isURL","URL","exec","window","./FragmentEditor","./SyncDriver","./google-item-driver","./google-xooml-driver",4,"_itemMirror","_localItemCompare","b","processItems","itemAssociations","xooMLContent","xooMLAssociations","xooMLIdx","synchronized","_fragmentEditor","map","filter","sort","itemLocals","xooMLLocals","itemIdx","search","lastIndexOf","slice",5,"xooMLFragmentFileName","maxFileLength","createAssociationSimple","createAssociationLinkNonGrouping","localItemRequested","createAssociationLinkGrouping","xooMLDriverURI","createAssociationCreate","itemName",6,"notImplemented","xooMLUException","itemUException","nonUpgradeableAssociationException","invalidArgument","itemAlreadyExists",7,"_TYPES","[object Boolean]","[object Number]","[object String]","[object Function]","[object Array]","[object Date]","[object RegExp]","[object Object]","[object Error]","hasOptions","checkedOptions","checkedOption","isRequiredOption","missingOptionalParamCount","hasOwnProperty","getType","isArray","value","isString","isBoolean","replace","c","Math","random","v","obj","String","endsWith","string","suffix","indexOf","clone","copy","Date","setTime","getTime","Array","len","attr",8,"authResponse","auth2","getAuthInstance","currentUser","get","getAuthResponse","_AUTH_HEADER","Authorization","access_token","_DRIVE_FILE_API","_FOLDER_MIMETYPE","XooMLConfig","$","url","headers","then","resp","mimeType","fail","parentURI","title","post","body","parents","createNonGroupingItem","fileName","file","insertFile","fileData","boundary","delimiter","close_delim","reader","FileReader","readAsBinaryString","onload","contentType","type","metadata","kind","_parentURI","base64Data","btoa","result","multipartRequestBody","stringify","request","client","method","params","uploadType","Content-Type","execute","response","blob","Blob","_deleteID","query","drive","files","list","maxResults","q","items","item","alternateLink","checkExisted","_dropboxClient","stat","_showDropboxError","status","isRemoved","./XooMLConfig",9,"_fragmentURI","_readFile","ajax","dataType","xml_text","_searchXooML","folderID","xoomlItem","xmlString","updateFile","checkExists"],"mappings":"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","file":"item-mirror.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * AssociationEditor is a minimal interface to represent a XooML2\n * association. This object is used together with FragmentEditor to\n * fully reprsent a XooML fragment as javascript object. It can be\n * converted seamlessly between an object and XML.\n *\n * Note that upon construction, this doesn't actually create an\n * association, merely a /representation/ of an association.\n *\n * There are two ways to construct an AssociationEditor:\n * 1. Through a valid Association XML Element\n * 2. By specifying all data through an object\n *\n * For ItemMirror core developers only. Enable protected to see.\n *\n * @class AssociationEditor\n * @constructor\n *\n * @param {Object} options The options specified for the constructor\n *  @param {Element} options.element A DOM element that correctly\n *  represents an association as specified by the XooML schema.\n *  @param {Object} options.commonData An object that specifies the\n *  data for an association. Look at the private constructor\n *  `_fromOptions` for more details\n *\n * @protected\n */\n\n\n'use strict'\n\nvar XooMLExceptions = require('./XooMLExceptions');\nvar XooMLUtil = require('./XooMLUtil');\n\n var _ELEMENT_NAME = \"association\",\n     _NAMESPACE_ELEMENT_NAME = \"associationNamespaceElement\",\n     _ID_ATTR = \"ID\",\n     _DISPLAY_TEXT_ATTR = \"displayText\",\n     _ASSOCIATED_XOOML_FRAGMENT_ATTR = \"associatedXooMLFragment\",\n     _ASSOCIATED_XOOML_DRIVER_ATTR = \"associatedXooMLDriver\",\n     _ASSOCIATED_SYNC_DRIVER_ATTR = \"associatedSyncDriver\",\n     _ASSOCIATED_ITEM_DRIVER_ATTR = \"associatedItemDriver\",\n     _ASSOCIATED_ITEM_ATTR = \"associatedItem\",\n     _LOCAL_ITEM_ATTR = \"localItem\",\n     _IS_GROUPING_ATTR = \"isGrouping\",\n     _PUBLIC_URL = \"publicURL\";\n\n  function AssociationEditor(options) {\n    var self = this;\n\n    if (options.element) {\n      _fromElement(options.element, self);\n    } else if (options.commonData) {\n      _fromOptions(options.commonData, self);\n    } else {\n      throw new Error(XooMLExceptions.missingParameter);\n    }\n  }\n\n  /**\n   * Converts the object into an association element, which can then\n   * be converted to a string or added to the DOM.\n   *\n   * @method toElement\n   *\n   * @return {Element} A DOM element that can be further manipulated\n   * with DOM methods\n   *\n   * @protected\n   */\n  AssociationEditor.prototype.toElement = function() {\n    var self = this,\n        // The We use a null namespace to leave it blank, otherwise it\n        // sets it as XHTML and won't serialize attribute names properly.\n        // The namespace will be inherited by the fragment it resides in.\n        associationElem = document.createElementNS(null, _ELEMENT_NAME);\n\n    // common data\n    Object.keys(self.commonData).forEach( function(key) {\n      if ( self.commonData[key] ) {// Don't set null attributes\n        associationElem.setAttribute(key, self.commonData[key]);\n      }\n    });\n\n    // namespace data\n    Object.keys(self.namespace).forEach( function(uri) {\n      var nsElem = document.createElementNS(uri, _NAMESPACE_ELEMENT_NAME);\n      // Attributes\n      Object.keys(self.namespace[uri].attributes).forEach( function(attrName) {\n        nsElem.setAttributeNS(uri, attrName, self.namespace[ uri ].attributes[ attrName ]);\n      });\n      // Data\n      nsElem.textContent = self.namespace[ uri ].data;\n\n      associationElem.appendChild(nsElem);\n    });\n\n    return associationElem;\n  };\n\n  /**\n   * Takes an association element in XML and then converts that into\n   * an AssociationEditor object. Intended to be one of the ways the\n   * object is constructed\n   *\n   * @method _fromElement\n   *\n   * @param {Element} element The XML element that represents an association.\n   */\n  function _fromElement(element, self) {\n    var dataElems, i, uri, elem;\n    // Sets all common data attributes\n    self.commonData = {\n      ID: element.getAttribute(_ID_ATTR),\n      displayText: element.getAttribute(_DISPLAY_TEXT_ATTR),\n      associatedXooMLFragment: element.getAttribute(_ASSOCIATED_XOOML_FRAGMENT_ATTR),\n      associatedXooMLDriver: element.getAttribute(_ASSOCIATED_XOOML_DRIVER_ATTR),\n      associatedSyncDriver: element.getAttribute(_ASSOCIATED_SYNC_DRIVER_ATTR),\n      associatedItemDriver: element.getAttribute(_ASSOCIATED_ITEM_DRIVER_ATTR),\n      associatedItem: element.getAttribute(_ASSOCIATED_ITEM_ATTR),\n      localItem: element.getAttribute(_LOCAL_ITEM_ATTR),\n      // We use JSON.parse to get the value as a boolean, not as a string\n      isGrouping: JSON.parse(element.getAttribute(_IS_GROUPING_ATTR)),\n      publicURL: element.getAttribute(_PUBLIC_URL)\n    };\n\n    self.namespace = {};\n\n    dataElems = element.getElementsByTagName(_NAMESPACE_ELEMENT_NAME);\n    for (i = 0; i < dataElems.length; i += 1) {\n      elem = dataElems[i];\n      uri = elem.namespaceURI;\n\n      /**\n       * The information for a given namespace. Includes both the\n       * data, and the attributes. Namespaces URIs must be unique or\n       * they will overwrite data from another namespace\n       * @property namespace.URI\n       * @type Object\n       */\n      self.namespace[ uri ] = {};\n      self.namespace[ uri ].attributes = {};\n\n      for (i = 0; i < elem.attributes.length; i += 1) {\n        // We have to filter out the special namespace attribute We\n        // let the namespace methods handle the namespace, and we\n        // don't deal with it\n        if (elem.attributes[i].name !== \"xmlns\") {\n          /**\n           * The attributes of the current namespace, with each attribute\n           * having a corresponding value.\n           * @property namespace.URI.attributes\n           * @type Object\n           */\n          self.namespace[ uri ].attributes[ elem.attributes[i].localName ] =\n            elem.getAttributeNS(uri, elem.attributes[i].localName );\n        }\n      }\n\n    /**\n     * This is the namespace data stored within the namespace\n     * element. Anything can be put here, and it will be stored as a\n     * string. ItemMirror will not do anything with the data here and\n     * doesn't interact with it at all. It is the responsibility of\n     * other applications to properly store information here.\n     * @property namespace.URI.data\n     * @type String\n     */\n      self.namespace[ uri ].data = elem.textContent;\n    }\n  }\n\n  /**\n   * Constructs an association with data from an object\n   * @method _fromOptions\n   *\n   * @param {Object} commonData Common data that is used by the\n   * itemMirror library, and is app agnostic\n   *  @param {String} commonData.displayText Display text for the\n   *  association\n   *  @param {String} commonData.associatedXooMLFragment URI of the\n   *  associated XooML fragment for the association\n   *  @param {String} commonData.associatedItem URI of the associated item\n   *  @param {String} commonData.associatedXooMLDriver The associated\n   *  XooML driver for the association\n   *  @param {String} commonData.associatedItemDriver The associated\n   *  item driver for the association\n   *  @param {String} commonData.associatedSyncDriver The associated\n   *  sync driver of the association\n   *  @param {String} commonData.localItem The name/id of the\n   *  association\n   *  @param {Boolean} comnmonData.isGrouping Whether or not the\n   *  association is a grouping item\n   *  @param {String} commonData.readOnlyURLtoXooMLfragment Used in\n   *  cases where the owner wishes for the XooML fragment representing\n   *  an item to be public\n   * @protected\n   * @private\n   */\n  function _fromOptions(commonData, self) {\n    if (!commonData) {\n      throw XooMLExceptions.nullArgument;\n    }\n\n    // Properties from the common data\n    /**\n     * Common Data of the association that is accessible to all applications\n     * @property commonData\n     * @type Object\n     */\n    self.commonData = {\n      /**\n       * Text that describes the association\n       * @property commonData.displayText\n       * @type String\n       */\n      displayText: commonData.displayText || null,\n\n      /**\n       * The associated XooML fragment of the association\n       * @property commonData.associatedXooMLFragment\n       * @type String\n       */\n      associatedXooMLFragment: commonData.associatedXooMLFragment || null,\n\n      /**\n       * The associated XooML driver of the association\n       * @property commonData.associatedXooMLDriver\n       * @type String\n       */\n      associatedXooMLDriver: commonData.associatedXooMLDriver || null,\n\n      /**\n       * The associated sync driver of the association\n       * @property commonData.associatedSyncDriver\n       * @type String\n       */\n      associatedSyncDriver: commonData.associatedSyncDriver || null,\n\n      /**\n       * The associated item driver of the association\n       * @property commonData.associatedItemDriver\n       * @type String\n       */\n      associatedItemDriver: commonData.associatedItemDriver || null,\n\n      /**\n       * The associated item of the association\n       * @property commonData.associatedItem\n       * @type String\n       */\n      associatedItem: commonData.associatedItem || null,\n\n      /**\n       * The local item of the association\n       * @property commonData.localItem\n       * @type String\n       */\n      localItem: commonData.localItem || null,\n\n      /**\n       * Whether or not the item is a grouping item\n       * @property commonData.isGrouping\n       * @type Boolean\n       */\n      isGrouping: commonData.isGrouping || false,\n\n      /**\n       * The GUID of the association\n       * @property commonData.ID\n       * @type String\n       */\n      // GUID is generated upon construction\n      ID: XooMLUtil.generateGUID(),\n\n      publicURL: commonData.publicURL || null\n    };\n\n    /**\n     * Data for the namespaces. Stored as a key pair value, with each\n     * namespace referencing the namespace association element for the\n     * corresponding namespace.\n     *\n     * @property namespace\n     * @type Object\n     */\n    self.namespace = {};\n    /**\n     * The attributes of the current namespace, with each attribute\n     * having a corresponding value.\n     * @property namespace.URI.attributes\n     * @type Object\n     */\n\n    /**\n     * This is the namespace data stored within the namespace\n     * element. Anything can be put here, and it will be stored as a\n     * string. ItemMirror will not do anything with the data here and\n     * doesn't interact with it at all. It is the responsibility of\n     * other applications to properly store information here.\n     *\n     * @property namespace.URI.data\n     * @type String\n     */\n  }\n\nmodule.exports = AssociationEditor;","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * AssociationEditor is a minimal interface to represent a XooML2\n * association. This object is used together with FragmentEditor to\n * fully reprsent a XooML fragment as javascript object. It can be\n * converted seamlessly between an object and XML.\n *\n * Note that upon construction, this doesn't actually create an\n * association, merely a /representation/ of an association.\n *\n * There are two ways to construct an AssociationEditor:\n * 1. Through a valid Association XML Element\n * 2. By specifying all data through an object\n *\n * For ItemMirror core developers only. Enable protected to see.\n *\n * @class AssociationEditor\n * @constructor\n *\n * @param {Object} options The options specified for the constructor\n *  @param {Element} options.element A DOM element that correctly\n *  represents an association as specified by the XooML schema.\n *  @param {Object} options.commonData An object that specifies the\n *  data for an association. Look at the private constructor\n *  `_fromOptions` for more details\n *\n * @protected\n */\n\n\n'use strict'\n\nvar XooMLExceptions = require('./XooMLExceptions');\nvar XooMLUtil = require('./XooMLUtil');\n\n var _ELEMENT_NAME = \"association\",\n     _NAMESPACE_ELEMENT_NAME = \"associationNamespaceElement\",\n     _ID_ATTR = \"ID\",\n     _DISPLAY_TEXT_ATTR = \"displayText\",\n     _ASSOCIATED_XOOML_FRAGMENT_ATTR = \"associatedXooMLFragment\",\n     _ASSOCIATED_XOOML_DRIVER_ATTR = \"associatedXooMLDriver\",\n     _ASSOCIATED_SYNC_DRIVER_ATTR = \"associatedSyncDriver\",\n     _ASSOCIATED_ITEM_DRIVER_ATTR = \"associatedItemDriver\",\n     _ASSOCIATED_ITEM_ATTR = \"associatedItem\",\n     _LOCAL_ITEM_ATTR = \"localItem\",\n     _IS_GROUPING_ATTR = \"isGrouping\",\n     _PUBLIC_URL = \"publicURL\";\n\n  function AssociationEditor(options) {\n    var self = this;\n\n    if (options.element) {\n      _fromElement(options.element, self);\n    } else if (options.commonData) {\n      _fromOptions(options.commonData, self);\n    } else {\n      throw new Error(XooMLExceptions.missingParameter);\n    }\n  }\n\n  /**\n   * Converts the object into an association element, which can then\n   * be converted to a string or added to the DOM.\n   *\n   * @method toElement\n   *\n   * @return {Element} A DOM element that can be further manipulated\n   * with DOM methods\n   *\n   * @protected\n   */\n  AssociationEditor.prototype.toElement = function() {\n    var self = this,\n        // The We use a null namespace to leave it blank, otherwise it\n        // sets it as XHTML and won't serialize attribute names properly.\n        // The namespace will be inherited by the fragment it resides in.\n        associationElem = document.createElementNS(null, _ELEMENT_NAME);\n\n    // common data\n    Object.keys(self.commonData).forEach( function(key) {\n      if ( self.commonData[key] ) {// Don't set null attributes\n        associationElem.setAttribute(key, self.commonData[key]);\n      }\n    });\n\n    // namespace data\n    Object.keys(self.namespace).forEach( function(uri) {\n      var nsElem = document.createElementNS(uri, _NAMESPACE_ELEMENT_NAME);\n      // Attributes\n      Object.keys(self.namespace[uri].attributes).forEach( function(attrName) {\n        nsElem.setAttributeNS(uri, attrName, self.namespace[ uri ].attributes[ attrName ]);\n      });\n      // Data\n      nsElem.textContent = self.namespace[ uri ].data;\n\n      associationElem.appendChild(nsElem);\n    });\n\n    return associationElem;\n  };\n\n  /**\n   * Takes an association element in XML and then converts that into\n   * an AssociationEditor object. Intended to be one of the ways the\n   * object is constructed\n   *\n   * @method _fromElement\n   *\n   * @param {Element} element The XML element that represents an association.\n   */\n  function _fromElement(element, self) {\n    var dataElems, i, uri, elem;\n    // Sets all common data attributes\n    self.commonData = {\n      ID: element.getAttribute(_ID_ATTR),\n      displayText: element.getAttribute(_DISPLAY_TEXT_ATTR),\n      associatedXooMLFragment: element.getAttribute(_ASSOCIATED_XOOML_FRAGMENT_ATTR),\n      associatedXooMLDriver: element.getAttribute(_ASSOCIATED_XOOML_DRIVER_ATTR),\n      associatedSyncDriver: element.getAttribute(_ASSOCIATED_SYNC_DRIVER_ATTR),\n      associatedItemDriver: element.getAttribute(_ASSOCIATED_ITEM_DRIVER_ATTR),\n      associatedItem: element.getAttribute(_ASSOCIATED_ITEM_ATTR),\n      localItem: element.getAttribute(_LOCAL_ITEM_ATTR),\n      // We use JSON.parse to get the value as a boolean, not as a string\n      isGrouping: JSON.parse(element.getAttribute(_IS_GROUPING_ATTR)),\n      publicURL: element.getAttribute(_PUBLIC_URL)\n    };\n\n    self.namespace = {};\n\n    dataElems = element.getElementsByTagName(_NAMESPACE_ELEMENT_NAME);\n    for (i = 0; i < dataElems.length; i += 1) {\n      elem = dataElems[i];\n      uri = elem.namespaceURI;\n\n      /**\n       * The information for a given namespace. Includes both the\n       * data, and the attributes. Namespaces URIs must be unique or\n       * they will overwrite data from another namespace\n       * @property namespace.URI\n       * @type Object\n       */\n      self.namespace[ uri ] = {};\n      self.namespace[ uri ].attributes = {};\n\n      for (i = 0; i < elem.attributes.length; i += 1) {\n        // We have to filter out the special namespace attribute We\n        // let the namespace methods handle the namespace, and we\n        // don't deal with it\n        if (elem.attributes[i].name !== \"xmlns\") {\n          /**\n           * The attributes of the current namespace, with each attribute\n           * having a corresponding value.\n           * @property namespace.URI.attributes\n           * @type Object\n           */\n          self.namespace[ uri ].attributes[ elem.attributes[i].localName ] =\n            elem.getAttributeNS(uri, elem.attributes[i].localName );\n        }\n      }\n\n    /**\n     * This is the namespace data stored within the namespace\n     * element. Anything can be put here, and it will be stored as a\n     * string. ItemMirror will not do anything with the data here and\n     * doesn't interact with it at all. It is the responsibility of\n     * other applications to properly store information here.\n     * @property namespace.URI.data\n     * @type String\n     */\n      self.namespace[ uri ].data = elem.textContent;\n    }\n  }\n\n  /**\n   * Constructs an association with data from an object\n   * @method _fromOptions\n   *\n   * @param {Object} commonData Common data that is used by the\n   * itemMirror library, and is app agnostic\n   *  @param {String} commonData.displayText Display text for the\n   *  association\n   *  @param {String} commonData.associatedXooMLFragment URI of the\n   *  associated XooML fragment for the association\n   *  @param {String} commonData.associatedItem URI of the associated item\n   *  @param {String} commonData.associatedXooMLDriver The associated\n   *  XooML driver for the association\n   *  @param {String} commonData.associatedItemDriver The associated\n   *  item driver for the association\n   *  @param {String} commonData.associatedSyncDriver The associated\n   *  sync driver of the association\n   *  @param {String} commonData.localItem The name/id of the\n   *  association\n   *  @param {Boolean} comnmonData.isGrouping Whether or not the\n   *  association is a grouping item\n   *  @param {String} commonData.readOnlyURLtoXooMLfragment Used in\n   *  cases where the owner wishes for the XooML fragment representing\n   *  an item to be public\n   * @protected\n   * @private\n   */\n  function _fromOptions(commonData, self) {\n    if (!commonData) {\n      throw XooMLExceptions.nullArgument;\n    }\n\n    // Properties from the common data\n    /**\n     * Common Data of the association that is accessible to all applications\n     * @property commonData\n     * @type Object\n     */\n    self.commonData = {\n      /**\n       * Text that describes the association\n       * @property commonData.displayText\n       * @type String\n       */\n      displayText: commonData.displayText || null,\n\n      /**\n       * The associated XooML fragment of the association\n       * @property commonData.associatedXooMLFragment\n       * @type String\n       */\n      associatedXooMLFragment: commonData.associatedXooMLFragment || null,\n\n      /**\n       * The associated XooML driver of the association\n       * @property commonData.associatedXooMLDriver\n       * @type String\n       */\n      associatedXooMLDriver: commonData.associatedXooMLDriver || null,\n\n      /**\n       * The associated sync driver of the association\n       * @property commonData.associatedSyncDriver\n       * @type String\n       */\n      associatedSyncDriver: commonData.associatedSyncDriver || null,\n\n      /**\n       * The associated item driver of the association\n       * @property commonData.associatedItemDriver\n       * @type String\n       */\n      associatedItemDriver: commonData.associatedItemDriver || null,\n\n      /**\n       * The associated item of the association\n       * @property commonData.associatedItem\n       * @type String\n       */\n      associatedItem: commonData.associatedItem || null,\n\n      /**\n       * The local item of the association\n       * @property commonData.localItem\n       * @type String\n       */\n      localItem: commonData.localItem || null,\n\n      /**\n       * Whether or not the item is a grouping item\n       * @property commonData.isGrouping\n       * @type Boolean\n       */\n      isGrouping: commonData.isGrouping || false,\n\n      /**\n       * The GUID of the association\n       * @property commonData.ID\n       * @type String\n       */\n      // GUID is generated upon construction\n      ID: XooMLUtil.generateGUID(),\n\n      publicURL: commonData.publicURL || null\n    };\n\n    /**\n     * Data for the namespaces. Stored as a key pair value, with each\n     * namespace referencing the namespace association element for the\n     * corresponding namespace.\n     *\n     * @property namespace\n     * @type Object\n     */\n    self.namespace = {};\n    /**\n     * The attributes of the current namespace, with each attribute\n     * having a corresponding value.\n     * @property namespace.URI.attributes\n     * @type Object\n     */\n\n    /**\n     * This is the namespace data stored within the namespace\n     * element. Anything can be put here, and it will be stored as a\n     * string. ItemMirror will not do anything with the data here and\n     * doesn't interact with it at all. It is the responsibility of\n     * other applications to properly store information here.\n     *\n     * @property namespace.URI.data\n     * @type String\n     */\n  }\n\nmodule.exports = AssociationEditor;\n},{\"./XooMLExceptions\":6,\"./XooMLUtil\":7}],2:[function(require,module,exports){\n/**\n * Constructs a FragmentWrapper for a XooML fragment. In the following cases.\n *\n * 1. XooMLFragment String is passed in and is used as the XooMLFragment\n * 2. XooMLFragment Element is passed in and is used as the XooMLFragment.\n * 2. Associations, XooMLDriver, ItemDriver, SyncDriver,\n * groupingItemURI are given and used to create a new XooMLFragment with\n * the given data.\n *\n * The FragmentWrapper is merely a representation of a XooML fragment,\n * and is used by an itemMirror that actually handles the details of\n * creating deleting and modifying associations.\n *\n * For ItemMirror core developers only. Enable protected to see.\n *\n * @class FragmentEditor\n * @constructor\n *\n * @param {Object} options Data to construct a new FragmentWrapper with\n *  @param {String} options.text Unparsed XML directly from a storage\n *  platform.\n *  @param {Element} options.element XML Element representing a XooML\n *                   fragment. Required for case 1.\n *  @param {AssociationEditor[]} options.associations List of associations for\n *          the newly constructed XooMLFragment in case 2. <br/>__optional__\n *  @param {Object} options.commonData Common data for the\n *  fragment. Look at the constructor for more details. Required for case 2\n *  @param {String} options.groupingItemURI The URI for the grouping\n *  item of the fragment. Required for case 2.\n *\n * @protected\n **/\n\n\n'use strict'\n\nvar XooMLExceptions = require('./XooMLExceptions');\nvar XooMLUtil = require('./XooMLUtil');\nvar AssociationEditor = require('./AssociationEditor');\n\n  var _ELEMENT_NAME = \"fragment\",\n      _ASSOCIATION_ELEMENT_NAME = \"association\",\n      _ASSOCIATION_ID_ATTR = \"ID\",\n      _NAMESPACE_ELEMENT_NAME = \"fragmentNamespaceElement\",\n      _SCHEMA_VERSION_ATTR = \"schemaVersion\",\n      _SCHEMA_LOCATION_ATTR = \"schemaLocation\",\n      _ITEM_DESCRIBED_ATTR = \"itemDescribed\",\n      _DISPLAY_NAME_ATTR = \"displayName\",\n      _ITEM_DRIVER_ATTR = \"itemDriver\",\n      _SYNC_DRIVER_ATTR = \"syncDriver\",\n      _XOOML_DRIVER_ATTR = \"xooMLDriver\",\n      _GUID_ATTR = \"GUIDGeneratedOnLastWrite\",\n      _ITEM_MIRROR_NS = \"http://kftf.ischool.washington.edu/xmlns/xooml\";\n\n  function FragmentEditor(options) {\n    var self = this;\n\n    if (options.text) {\n      _fromString(options.text, self);\n    } else if (options.element) {\n      _fromElement(options.element, self);\n    } else if (options.commonData) {\n      _fromOptions(options.commonData, options.associations, self);\n    } else {\n      throw new Error(XooMLExceptions.missingParameter);\n    }\n  }\n\n  /**\n   * Updates the GUID of the Fragment\n   *\n   * @method updateID\n   * @return {String} The new GUID of the fragment\n   * @private\n   * @protected\n   */\n  FragmentEditor.prototype.updateID = function() {\n    var guid = XooMLUtil.generateGUID();\n    this.commonData.GUIDGeneratedOnLastWrite = guid;\n    return guid;\n  };\n\n  /**\n   * Converts a FragmentEditor object into an XML element, which can\n   * then be serialized and saved as a string, or further manipulated\n   * with DOM methods\n   * @method toElement\n   * @return {Element} The XooML fragment as an XML element\n   * @protected\n   */\n  FragmentEditor.prototype.toElement = function() {\n    var self = this,\n        fragmentElem = document.createElementNS(_ITEM_MIRROR_NS, _ELEMENT_NAME);\n\n    // common data\n    Object.keys(self.commonData).forEach( function(attrName) {\n      var attrValue = self.commonData[attrName];\n      if (attrValue) { // Don't set null attributes\n        fragmentElem.setAttribute(attrName, attrValue);\n      }\n    });\n\n    // namespace data\n    Object.keys(self.namespace).forEach( function(uri) {\n      var nsElem = document.createElementNS(uri, _NAMESPACE_ELEMENT_NAME);\n      // Attributes\n      Object.keys(self.namespace[uri].attributes).forEach( function(attrName) {\n        nsElem.setAttributeNS(uri, attrName, self.namespace[ uri ].attributes[ attrName ]);\n      });\n\n      nsElem.textContent = self.namespace[ uri ].data;\n\n      fragmentElem.appendChild(nsElem);\n    });\n\n    // associations\n    Object.keys(self.associations).forEach( function(id) {\n      fragmentElem.appendChild( self.associations[id].toElement() );\n    });\n\n    return fragmentElem;\n  };\n\n  /**\n   * Returns the XML of a fragment as a string, _not_ the string\n   * version of the object. This is used for persisting the fragment\n   * across multiple platforms\n   * @method toString\n   * @return {String} Fragment XML\n   */\n  FragmentEditor.prototype.toString = function() {\n    var serializer = new XMLSerializer();\n    return serializer.serializeToString( this.toElement() );\n  };\n\n  /**\n   * Constructs a fragmentEditor based on data passed into the\n   * parameters\n   *\n   * @method _fromOptions\n   *\n   * @param {Object} commonData An object containing common data for the association\n   *  @param {String} commonData.schemaVersion The version of the schema <br/> __required__\n   *  @param {String} commonData.schemaLocation The location of the schema\n   *  @param {String} commonData.itemDescribed URI pointing to item for which the\n   *  XooML fragment is metadata.\n   *  @param {String} commonData.displayName Display name of the fragment\n   *  @param {String} commonData.itemDriver The URI of the item driver for the fragment\n   *  @param {String} commonData.syncDriver The URI of the sync driver for the fragment\n   *  @param {String} commonData.xooMLDriver The URI of the XooML driver for the fragment\n   *  @param {String} commonData.GUIDGeneratedOnLastWrite The GUID generated the last time the fragment was written\n   * @param {AssociationEditor[]} associations An array of associations that the fragment has\n   * @param {String} namespace The namespace URI that an app will use for it's own private data\n   * @param {FragmentEditor} self\n   *\n   * @private\n   */\n  function _fromOptions(commonData, associations, self) {\n    if (!commonData) {\n      throw XooMLExceptions.nullArgument;\n    }\n\n    // Properties from the common data\n    /**\n     * Common Data of the association that is accessible to all applications\n     * @property commonData\n     * @type Object\n     */\n    self.commonData = {\n      /**\n       * Text that describes the fragment\n       * @property commonData.displayName\n       * @type String\n       */\n      displayName: commonData.displayName || null,\n\n      /**\n       * The schema location for the fragment\n       * @property commonData.schemaLocation\n       * @type String\n       */\n      schemaLocation: commonData.schemaLocation || null,\n\n      /**\n       * The schema version for the fragment\n       * @property commonData.schemaVersion\n       * @type String\n       */\n      schemaVersion: commonData.schemaVersion || null,\n\n      /**\n       * The item driver URI for the fragment\n       * @property commonData.itemDriver\n       * @type String\n       */\n      itemDriver: commonData.itemDriver || null,\n\n      /**\n       * The item described for the fragment. This is a URI that\n       * points to grouping item from wich the itemMirror was created\n       * @property commonData.\n       * @type String\n       */\n      itemDescribed: commonData.itemDescribed || null,\n\n      /**\n       * The sync driver URI for the fragment\n       * @property commonData.syncDriver\n       * @type String\n       */\n      syncDriver: commonData.syncDriver || null,\n\n      /**\n       * The XooML driver URI for the fragment\n       * @property commonData.xooMLDriver\n       * @type String\n       */\n      xooMLDriver: commonData.xooMLDriver || null,\n\n      /**\n       * The unique GUID for the fragment that is updated after every\n       * write\n       * @property commonData.GUIDGeneratedOnLastWrite\n       * @type String\n       */\n      GUIDGeneratedOnLastWrite: XooMLUtil.generateGUID()\n    };\n\n    /**\n     * The associations of the fragment. Each association is accessed\n     * by referencing it's ID, which then gives the corresponding\n     * AssociationEditor object for manipulating that association.\n     * @property associations\n     * @type Object\n     */\n    // Takes the association array and turns it into an associative\n    // array accessed by the GUID of an association\n    self.associations = {};\n    associations.forEach( function(assoc) {\n      var guid = assoc.commonData.ID;\n      self.associations[guid] = assoc;\n    });\n\n    /**\n     * The namespace data of the fragment. Holds both the URI as well\n     * as the namespace specific data for the fragment\n     * @property namespace\n     * @type Object\n     */\n    self.namespace = {};\n      /**\n       * The namespace URI for the fragment. Used to set namespace data\n       * for both the fragment and it's associations\n       * @property namespace.uri\n       * @type String\n       */\n\n      /**\n       * The attributes of the namespace. This is app specific data\n       * that is set for the fragment. Each key pair in the object\n       * represents an attribute name and it's corresponding value\n       * @property namespace.attributes\n       * @type Object\n       */\n  }\n\n  /**\n   * Takes a fragment in the form of a string and then parses that\n   * into XML. From there it converts that element into an object\n   * using the _fromElement method\n   * \n   * @method _fromString\n   *\n   * @param {String} text The text representing the fragment. Should\n   * be obtained directly from a storage platform like dropbox or a\n   * local filesystem\n   * @param {String} namespace The URI of the namespace that will\n   * initially be used for the fragment when handling any namespace\n   * data\n   * @param {FragmentEditor} self\n   */\n  function _fromString(text, namespace, self) {\n    var parser = new DOMParser();\n    var doc = parser.parseFromString(text, \"application/xml\");\n    _fromElement(doc.children[0], namespace, self);\n  }\n\n  /**\n   * Takes a fragment element in XML and then converts that into a\n   * FragmentEditor object. Intended to be one of the ways the object\n   * is constructed\n   *\n   * @method _fromElement\n   *\n   * @param {Element} element The XML element that represents an association.\n   * @param {FragmentEditor} self\n   * @private\n   */\n  function _fromElement(element, self) {\n    var dataElems, i, associationElems, guid, elem, uri;\n    // Sets all common data attributes\n    self.commonData = {\n      fragmentNamespaceElement: element.getAttribute(_NAMESPACE_ELEMENT_NAME),\n      schemaVersion: element.getAttribute(_SCHEMA_VERSION_ATTR),\n      schemaLocation: element.getAttribute(_SCHEMA_LOCATION_ATTR),\n      itemDescribed: element.getAttribute(_ITEM_DESCRIBED_ATTR),\n      displayName: element.getAttribute(_DISPLAY_NAME_ATTR),\n      itemDriver: element.getAttribute(_ITEM_DRIVER_ATTR),\n      syncDriver: element.getAttribute(_SYNC_DRIVER_ATTR),\n      xooMLDriver: element.getAttribute(_XOOML_DRIVER_ATTR),\n      GUIDGeneratedOnLastWrite: element.getAttribute(_GUID_ATTR)\n    };\n\n    /**\n     * The namespace object is an associated array with each key being\n     * a namespace URI. These can thene be used to modify fragment\n     * namespace attributes and data\n     * @property namespace\n     * @type Object\n     */\n    self.namespace = {};\n\n    dataElems = element.getElementsByTagName(_NAMESPACE_ELEMENT_NAME);\n    for (i = 0; i < dataElems.length; i += 1) {\n      elem = dataElems[i];\n      uri = elem.namespaceURI;\n\n      /**\n       * The information for a given namespace. Includes both the\n       * data, and the attributes. Namespaces URIs must be unique or\n       * they will overwrite data from another namespace\n       * @property namespace.URI\n       * @type Object\n       */\n      self.namespace[ uri ] = {};\n      self.namespace[ uri ].attributes = {};\n\n      for (i = 0; i < elem.attributes.length; i += 1) {\n        // We have to filter out the special namespace attribute We\n        // let the namespace methods handle the namespace, and we\n        // don't deal with it\n        if (elem.attributes[i].name !== \"xmlns\") {\n          /**\n           * The attributes of the current namespace, with each attribute\n           * having a corresponding value.\n           * @property namespace.URI.attributes\n           * @type Object\n           */\n          self.namespace[ uri ].attributes[ elem.attributes[i].localName ] =\n            elem.getAttributeNS(uri, elem.attributes[i].localName);\n        }\n      }\n\n    /**\n     * This is the namespace data stored within the namespace\n     * element. Anything can be put here, and it will be stored as a\n     * string. ItemMirror will not do anything with the data here and\n     * doesn't interact with it at all. It is the responsibility of\n     * other applications to properly store information here.\n     * @property namespace.URI.data\n     * @type String\n     */\n      self.namespace[ uri ].data = elem.textContent;\n    }\n\n    // associations\n    self.associations = {};\n    associationElems = element.getElementsByTagName(_ASSOCIATION_ELEMENT_NAME);\n    for (i = 0; i < associationElems.length; i += 1) {\n      guid = associationElems[i].getAttribute(_ASSOCIATION_ID_ATTR);\n      self.associations[guid] = new AssociationEditor({\n        element: associationElems[i]\n      });\n    }\n  }\n\nmodule.exports = FragmentEditor;\n},{\"./AssociationEditor\":1,\"./XooMLExceptions\":6,\"./XooMLUtil\":7}],3:[function(require,module,exports){\n/**\n * ItemMirror represents an Item according to the XooML2 specification.\n *\n * It can be instantiated using one of the following two cases based on the\n * given arguments.\n *\n * 1. XooMLFragment already exists. Given xooMLFragmentURI and xooMLDriver.\n * 2. The XooMLFragment is created from an existing groupingItemURI (e.g., a dropbox folder).\n * Given a groupingItemURI, itemDriver, and a xooMLDriver a new itemMirror will be constructed for given groupingItemURI.\n *\n * Throws NullArgumentException when options is null.\n *\n * Throws MissingParameterException when options is not null and a required\n * argument is missing.\n *\n * @class ItemMirror\n * @constructor\n *\n * @param {Object} options Data to construct a new ItemMirror with\n *\n *  @param {String} options.groupingItemURI URI to the grouping item. Required\n *                  for all cases.\n *\n *  @param {String} options.itemDriver Data for the ItemDriver to\n *                  construct ItemMirror with. Required for cases 2 & 3\n *                  Can contain any amount of optional key/value pairs for\n *                  the various Driver implementations.\n *   @param {String} options.itemDriver.driverURI URI of the driver.\n *\n *  @param {String} options.xooMLDriver Data for the XooMLDriver to\n *                  construct ItemMirror with. Required for all cases.\n *                  Can contain any amount of optional key/value pairs for\n *                  the various Driver implementations.\n *   @param {String} options.xooMLDriver.driverURI URI of the driver.\n *\n *  @param {String} options.syncDriver Data for the SyncDriver to\n *                  construct ItemMirror with. Required Case 2 & 3. Can\n *                  contain any amount of optional key/value pairs for\n *                  the various Driver implementations.\n *   @param {String} options.syncDriver.driverURI URI of the driver.\n *\n *  @param {Boolean} options.readIfExists True if ItemMirror\n *                   should create an ItemMirror if it does not exist,\n *                   else false. Required for Case 2 & 3.\n *\n *  @param {ItemMirror} options.creator If being created from another\n *  itemMirror, specifies that itemMirror which it comes from.\n *\n * @param {Function} callback Function to execute once finished.\n *  @param {Object}   callback.error Null if no error has occurred\n *                    in executing this function, else an contains\n *                    an object with the error that occurred.\n *  @param {ItemMirror} callback.itemMirror Newly constructed ItemMirror\n */\n\n'use strict'\n\n// Note: This is nothing more than the minified version of the older library.\n// It's used because the stability of the library is better, even though it's\n// more poorly implemented in the first place\n\n\n\nvar XooMLExceptions = require('./XooMLExceptions');\nvar XooMLUtil = require('./XooMLUtil');\nvar XooMLDriver = require('./google-xooml-driver');\nvar ItemDriver = require('./google-item-driver');\nvar SyncDriver = require('./SyncDriver');\nvar FragmentEditor = require('./FragmentEditor');\nvar AssociationEditor = require('./AssociationEditor');\n\n\nfunction ItemMirror(options, callback) {\n    XooMLUtil.checkCallback(callback);\n    if (!options) {\n      return callback(XooMLExceptions.nullArgument);\n    }\n\n   var self = this, xooMLFragmentURI, displayName;\n\n  if (typeof options === 'string') {\n    specialConstruction();\n  } else {\n    regularConstruction();\n  }\n\n    function specialConstruction() {\n      // Special case where we return a limited functionality itemMirror object that\n      // represents different informational stores\n      // A special XooML fragment, representing information stores\n      var xml = ['<fragment xmlns=\"http://kftf.ischool.washington.edu/xmlns/xooml\" itemDescribed=\"/\" displayName=\"Dropbox\" itemDriver=\"dropboxItemDriver\" syncDriver=\"itemMirrorSyncUtility\" xooMLDriver=\"dropboxXooMLDriver\" GUIDGeneratedOnLastWrite=\"771c1026-b8d8-4457-9594-01531b9f7ca0\">',\n      '<association ID=\"a02f53d2-18af-4faf-ace9-5305cb808ec5\" displayText=\"Dropbox\" associatedItem=\"Dropbox\" isGrouping=\"true\">',\n      '</association>',\n      '<association ID=\"27955628-7850-4c71-be12-6caed1c9463c\" displayText=\"Google Drive\" associatedItem=\"gapi\" isGrouping=\"true\">',\n      '</association>',\n      '</fragment>'].join('\\n');\n\n      self._fragment = new FragmentEditor({text: xml});\n      return callback(false, self);\n    }\n\n    function regularConstruction() {\n     self._xooMLDriverClient = options.xooMLDriver.clientInterface;\n     self._itemDriverClient = options.xooMLDriver.clientInterface;\n\n      // private variables\n      self._xooMLDriver = null;\n      self._itemDriver = null;\n      self._syncDriver = null;\n      self._creator = options.creator || null;\n      self._groupingItemURI = options.groupingItemURI;\n      self._newItemMirrorOptions = options;\n\n      // displayName for the fragment\n      // It may make more sense to set this later once we have the drivers loaded\n      // displayName = this._xooMLDriver.getDisplayName();\n      displayName = 'TBD';\n\n      self.fragmentURI = options.fragmentURI || null;\n      options.xooMLDriver.fragmentURI = xooMLFragmentURI;\n\n      // First load the XooML Driver\n      new XooMLDriver(options.xooMLDriver, loadXooMLDriver);\n    }\n\n\n\n    function loadXooMLDriver(error, driver) {\n      if (error) return callback(error);\n\n      self._xooMLDriver = driver; // actually sets the XooMLDriver\n\n      self._xooMLDriver.getXooMLFragment(processXooML);\n    }\n\n    function processXooML(error, fragmentString) {\n      // Case 2: Since the fragment doesn't exist, we need\n      // to construct it by using the itemDriver\n      if (error === 'XooML Not Found') {\n        new ItemDriver(options.itemDriver, createFromItemDriver);\n      } else if (error) {\n        return callback(error);\n      }\n\n      // Case 1: It already exists, and so all of the information\n      // can be constructed from the saved fragment\n      else {\n        createFromXML(fragmentString);\n      }\n    }\n\n    function createFromXML(fragmentString) {\n      self._fragment = new FragmentEditor({text: fragmentString});\n\n      new ItemDriver(options.itemDriver, function(error, driver) {\n        if (error) return callback(error);\n        self._itemDriver = driver;\n\n        self._syncDriver = new SyncDriver(self);\n\n        // Do a refresh in case something has been added or deleted in\n        // the directory since the last write\n        self.refresh(function() {\n          return callback(false, self);\n        });\n      });\n    }\n\n    function createFromItemDriver(error, driver) {\n      self._itemDriver = driver;\n\n      self._itemDriver.listItems(self._groupingItemURI, buildFragment);\n    }\n\n    function buildFragment(error, associations){\n      if (error) return callback(error);\n\n      self._fragment = new FragmentEditor({\n        commonData: {\n          itemDescribed: self._groupingItemURI,\n          displayName: displayName,\n          itemDriver: \"dropboxItemDriver\",\n          xooMLDriver: \"dropboxXooMLDriver\",\n          syncDriver: \"itemMirrorSyncUtility\"\n        },\n        associations: associations\n      });\n\n      self._syncDriver = new SyncDriver(self);\n\n      // Because the fragment is being built from scratch, it's safe\n      // to save it directly via the driver.\n      self._xooMLDriver.setXooMLFragment(self._fragment.toString(), function(error) {\n        if (error) {\n          throw new Error(error);\n        }\n      });\n\n      return callback(false, self);\n    }\n  }\n\n  /**\n   * @method getDisplayName\n   * @return {String} The display name of the fragment.\n   */\n  ItemMirror.prototype.getDisplayName = function() {\n    return this._fragment.commonData.displayName;\n  };\n\n  /**\n   * @method setDisplayName\n   * @param {String} name The display text to set for the fragment\n   */\n  ItemMirror.prototype.setDisplayName = function(name) {\n    this._fragment.commonData.displayName = name;\n  };\n\n  /**\n   *\n   * @method getSchemaVersion\n   * @return {String} XooML schema version.\n   */\n  ItemMirror.prototype.getSchemaVersion = function() {\n    return this._fragment.commonData.schemaVersion;\n  };\n\n  /**\n   *\n   * @method getSchemaLocation\n   * @return {String} XooML schema location.\n   */\n  ItemMirror.prototype.getSchemaLocation = function() {\n    return this._fragment.commonData.schemaLocation;\n  };\n\n  /**\n   * Returns URI pointing to item described by the metadata of a fragment. A URI\n   * might point to just about anything that can be interpreted as a grouping\n   * item. For example: a conventional file system folder or a tag as\n   * supported by any of several applications.\n   *\n   * @method getURIforItemDescribed\n   * @return {String} A URI pointing to item described by the metadata\n   * of a fragment if it exists, else returns null.\n   *\n   */\n  ItemMirror.prototype.getURIforItemDescribed = function() {\n    return this._fragment.commonData.itemDescribed;\n  };\n\n  ItemMirror.prototype.getPublicURL = function(GUID) {\n    return this._fragment.associations[GUID].commonData.publicURL;\n  }\n\n  /**\n   * Throws NullArgumentException if GUID is null. <br/>\n   * Throws InvalidTypeException if GUID is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   *\n   * @method getAssociationDisplayText\n   * @return {String} The display text for the association with the given GUID.\n   *\n   * @param {String} GUID GUID representing the desired association.\n   */\n    ItemMirror.prototype.getAssociationDisplayText = function(GUID) {\n    return this._fragment.associations[GUID].commonData.displayText;\n  };\n\n  /**\n   * Sets the display text for the association with the given GUID.\n   *\n   * Throws NullArgumentException if GUID or displayName is null. <br/>\n   * Throws InvalidTypeException if GUID or displayName is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method setAssociationDisplayText\n   *\n   * @param {String}   GUID        GUID of the association to set.\n   * @param {String}   displayText Display text to be set.\n   */\n    ItemMirror.prototype.setAssociationDisplayText = function(GUID, displayText) {\n    this._fragment.associations[GUID].commonData.displayText = displayText;\n  };\n\n  /**\n   * Throws NullArgumentException if GUID is null. <br/>\n   * Throws InvalidTypeException if GUID is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method getAssociationLocalItem\n   * @return {String} The local item for the association with the given GUID.\n   *\n   * @param {String} GUID GUID of the association to get.\n   */\n    ItemMirror.prototype.getAssociationLocalItem = function(GUID) {\n    return this._fragment.associations[GUID].commonData.localItem;\n  };\n\n  /**\n   * Throws NullArgumentException if GUID is null. <br/>\n   * Throws InvalidTypeException if GUID is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method getAssociationAssociatedItem\n   * @return {String} The associated item for the association with the given GUID.\n   * @param {String} GUID GUID of the association to get.\n   */\n    ItemMirror.prototype.getAssociationAssociatedItem = function(GUID) {\n    return this._fragment.associations[GUID].commonData.associatedItem;\n  };\n\n  /**\n   * @method getFragmentNamespaceAttribute\n   * @return {String} Returns the value of the given attributeName for the\n   * fragmentNamespaceData with the given namespaceURI.\n   * @param {String} attributeName Name of the attribute to be returned.\n   * @param {String} uri Namespace URI\n   */\n  ItemMirror.prototype.getFragmentNamespaceAttribute = function(attributeName, uri) {\n    var ns = this._fragment.namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    return this._fragment.namespace[uri].attributes[attributeName];\n  };\n\n  /**\n   * Sets the value of the given attributeName with the given attributeValue\n   * for the fragmentNamespaceData with the given namespaceURI.\n   *\n   * Throws NullArgumentException if attributeName, attributeValue, or\n   * namespaceURI is null. <br/>\n   * Throws InvalidTypeException if attributeName, attributeValue, or\n   * namespaceURI is not a String. <br/>\n   *\n   * @method setFragmentNamespaceAttribute\n   * @param {String} attributeName  Name of the attribute to be set.\n   * @param {String} attributeValue Value of the attribute to be set.\n   * @param {String} uri Namespace URI\n   */\n  ItemMirror.prototype.setFragmentNamespaceAttribute = function(attributeName, attributeValue, uri) {\n    var ns = this._fragment.namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    this._fragment.namespace[uri].attributes[attributeName] = attributeValue;\n  };\n\n  /**\n   * Adds the given attributeName to the fragment's current namespace\n   *\n   * Throws an InvalidStateException when the attribute already exists\n   *\n   * @method addFragmentNamespaceAttribute\n   *\n   * @param {String} attributeName Name of the attribute.\n   * @param {String} uri Namespace URI\n   */\n  // TODO: Possibly remove? Why not just get and set\n  ItemMirror.prototype.addFragmentNamespaceAttribute = function(attributeName, uri) {\n    var ns = this._fragment.namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    if (this._fragment.namespace[uri].attributes[attributeName]) {\n      throw XooMLExceptions.invalidState;\n    }\n    this.setFragmentNamespaceAttribute(attributeName, uri);\n  };\n\n  /**\n   * Removes the fragment namespace attribute with the given namespaceURI.\n   *\n   * Throws NullArgumentException if attributeName, or namespaceURI is\n   * null. <br/>\n   * Throws InvalidTypeException if attributeName, or namespaceURI is not\n   * a String. <br/>\n   * Throws an InvalidStateException when the given attributeName is not an\n   * attribute. <br/>\n   *\n   * @method removeFragmentNamespaceAttribute\n   * @param {String} attributeName Name of the attribute.\n   * @param {String} uri  Namespace URI\n   *\n   */\n  ItemMirror.prototype.removeFragmentNamespaceAttribute = function(attributeName, uri) {\n    delete this._fragment.namespace[uri].attributes[attributeName];\n  };\n\n  /**\n   * Checks if the fragment has the given namespaceURI.\n   *\n   * Currently cannot find a way to list the namespaces (no DOM\n   * standard method for doing so). So this fuction will ALWAYS RETURN\n   * FALSE for now.\n   *\n   * @method hasFragmentNamespace\n   * @return {Boolean} True if the fragment has the given\n   * namespaceURI, otherwise false.\n   *\n   * @param {String} uri URI of the namespace for the association.\n   *\n   */\n  ItemMirror.prototype.hasFragmentNamespace = function (uri) {\n    var namespace = this._fragment.namespace[uri];\n    if (namespace) { return true; }\n    else { return false; }\n  };\n\n  /**\n   * @method listFragmentNamespaceAttributes\n   * @return {String[]} An array of the attributes within the\n   * fragmentNamespaceData with the given namespaceURI.\n   * @param {String} uri Namespace URI\n   *\n  */\n  ItemMirror.prototype.listFragmentNamespaceAttributes = function(uri) {\n    return Object.keys(this._fragment.namespace[uri].attributes);\n  };\n\n  /**\n   * @method getFragmentNamespaceData\n   * @return {String} The fragment namespace data with the given namespace URI.\n   * @param {String} uri Namespace URI\n   */\n  ItemMirror.prototype.getFragmentNamespaceData = function(uri) {\n    return this._fragment.namespace[uri].data;\n  };\n\n  /**\n   * Sets the fragment namespace data with the given namespaceURI.\n   *\n   * @method setFragmentNamespaceData\n   *\n   * @param {String} data Fragment namespace data to be set.\n   * @param {String} uri Namespace URI\n   */\n  ItemMirror.prototype.setFragmentNamespaceData = function (data, uri) {\n    var ns = this._fragment.namespace;\n    ns[uri] = ns[uri] || {};\n\n    this._fragment.namespace[uri].data = data;\n  };\n\n  /**\n   * Creates an ItemMirror from the associated grouping item represented by\n   * the given GUID.\n   *\n   * Throws NullArgumentException if GUID or callback is null. <br/>\n   * Throws InvalidTypeException if GUID is not a string, and callback is\n   * not a function. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method createItemMirrorForAssociatedGroupingItem\n   * @return {ItemMirror} Possibly return an itemMirror if the GUID is a grouping item\n   *\n   * @param {String} GUID GUID of the association to create the ItemMirror\n   *                 from.\n   *\n   */\n  ItemMirror.prototype.createItemMirrorForAssociatedGroupingItem = function (GUID, callback) {\n\n    // Handle Special cases for the unique stores:\n    var self = this,\n        isGrouping,\n        xooMLOptions,\n        itemOptions,\n        syncOptions,\n        uri;\n\n    var association = self.getAssociationAssociatedItem(GUID);\n\n    // Dropbox root construction\n    if (association === 'Dropbox') {\n        var dropboxXooMLUtility = {\n          fragmentURI: '/XooML2.xml',\n          driverURI: 'DropboxXooMLUtility',\n          dropboxClient: dropboxClient\n        };\n        var dropboxItemUtility = {\n          driverURI: 'DropboxItemUtility',\n          dropboxClient: dropboxClient\n        };\n        var mirrorSyncUtility = {\n          utilityURI: 'MirrorSyncUtility'\n        };\n        var options = {\n          groupingItemURI: '/',\n          xooMLDriver: dropboxXooMLUtility,\n          itemDriver: dropboxItemUtility,\n          syncDriver: mirrorSyncUtility\n        };\n        return new DropboxItemMirror(options, callback);\n    }\n\n    // Google root Construction\n    if (association === 'gapi') {\n      var driveXooMLUtility = {\n        clientInterface: gapi\n      };\n      var driveItemUtility = {\n        clientInterface: gapi\n      };\n      mirrorSyncUtility = {\n        utilityURI: 'MirrorSyncUtility'\n      };\n      options = {\n        groupingItemURI: \"root\",\n        xooMLDriver: driveXooMLUtility,\n        itemDriver: driveItemUtility,\n        syncDriver: mirrorSyncUtility\n      };\n      return new ItemMirror(options, callback);\n    }\n\n    itemOptions = {\n      driverURI: \"GoogleItemUtility\",\n      clientInterface: this._itemDriverClient,\n      // Note that this needs to be changed, we want to point to the grouping item's id\n      associatedItem: self.getAssociationAssociatedItem(GUID)\n    };\n    xooMLOptions = {\n      fragmentURI: uri,\n      driverURI: \"GoogleXooMLUtility\",\n      clientInterface: this._xooMLDriverClient,\n      associatedItem: self.getAssociationAssociatedItem(GUID)\n    };\n    syncOptions = {\n      utilityURI: \"SyncUtility\"\n    };\n\n    isGrouping = self.isAssociationAssociatedItemGrouping(GUID);\n    if (!isGrouping) {\n      // Need to standardize this error\n      return callback(\"Association not grouping, cannot continue\");\n    }\n\n    new ItemMirror(\n      {groupingItemURI: self.getAssociationAssociatedItem(GUID),\n       xooMLDriver: xooMLOptions,\n       itemDriver: itemOptions,\n       syncDriver: syncOptions,\n       creator: self\n      },\n      function (error, itemMirror) {\n        return callback(error, itemMirror);\n      }\n    );\n  };\n\n  /**\n   * Creates an association based on the given options and the following\n   * cases.\n   *\n   * Cases 1, 2, 7 implemented. All else are not implemented.\n   *\n   * 1. Simple text association declared phantom. <br/>\n   * 2. Link to existing non-grouping item, phantom. This can be a URL <br/>\n   * 3. Link to existing non-grouping item, real. <br/>\n   * 4. Link to existing grouping item, phantom. <br/>\n   * 5. Link to existing grouping item, real. <br/>\n   * 6. Create new local non-grouping item. <br/>\n   * 7. Create new local grouping item. <br/>\n   *\n   * Throws NullArgumentException when options, or callback is null. <br/>\n   * Throws InvalidTypeException when options is not an object and callback\n   * is not a function. <br/>\n   * Throws MissingParameterException when an argument is missing for an expected\n   * case. <br/>\n   *\n   * @method createAssociation\n   *\n   * @param {Object} options Data to create an new association for.\n   *\n   *  @param {String}  options.displayText Display text for the association.\n   *                   Required in all cases.\n   *\n   *  @param {String}  options.itemURI URI of the item. Required for case 2 & 3. Note: Please ensure \"http://\" prefix exists at the beginning of the string when referencing a Web URL and not an Item.\n   *\n   *  @param {Boolean} options.localItemRequested True if the local item is\n   *                   requested, else false. Required for cases 2 & 3.\n   *\n   *  @param {String}  options.groupingItemURI URI of the grouping item.\n   *                   Required for cases 4 & 5.\n   *\n   *  @param {String}  options.xooMLDriverURI URI of the XooML driver for the\n   *                   association. Required for cases 4 & 5.\n   *\n   *  @param {String}  options.localItem URI of the new local\n   *                   non-grouping/grouping item. Required for cases 6 & 7.\n   *\n   *  @param {String}  options.isGroupingItem True if the item is a grouping\n   *                   item, else false. Required for cases 6 & 7.\n   *\n   * @param {Function} callback Function to execute once finished.\n   *  @param {Object}   callback.error Null if no error has occurred\n   *                    in executing this function, else an contains\n   *                    an object with the error that occurred.\n   *  @param {String}   callback.GUID GUID of the association created.\n   */\n  ItemMirror.prototype.createAssociation = function (options, callback) {\n    var self = this,\n        association,\n        saveOutFragment;\n\n    saveOutFragment = function(association){\n      var guid = association.commonData.ID;\n      // adds the association to the fragment\n      self._fragment.associations[guid] = association;\n\n      // Save changes out the actual XooML Fragment\n      self.save( function(error){\n        return callback(error, guid);\n      });\n    };\n\n    if (!XooMLUtil.isFunction(callback)) {\n      throw XooMLExceptions.invalidType;\n    }\n    if (!XooMLUtil.isObject(options)) {\n      return callback(XooMLExceptions.invalidType);\n    }\n\n    // Case 7\n    if (options.displayText && options.localItem && options.isGroupingItem) {\n      association = new AssociationEditor({\n        commonData: {\n          displayText: options.displayText,\n          isGrouping: true,\n          localItem: options.localItem,\n          // Changed this part, and need to test folder creation to insure safety\n          associatedItem: options.associatedItem\n        }\n      });\n\n      // Now we use the itemDriver to actually create the folder\n      // NOTE: untested\n      self._itemDriver.createGroupingItem(options.displayText, function(error){\n        if (error) return callback(error);\n\n        return saveOutFragment(association);\n      });\n    }\n    // Synchronous cases\n    else {\n      // Case 2\n      if (options.displayText && options.itemURI) {\n        association = new AssociationEditor({\n          commonData: {\n            displayText: options.displayText,\n            associatedItem: options.itemURI,\n            isGrouping: false\n          }\n        });\n      }\n      // Case 1\n      else if (options.displayText) {\n        association = new AssociationEditor({\n          commonData: {\n            displayText: options.displayText,\n            isGrouping: false\n          }\n        });\n      }\n\n      return saveOutFragment(association);\n    }\n  };\n\n  /**\n   * @method isAssociationPhantom\n   * @param {String} guid\n   * @return {Boolean} True if the association of the given GUID is a\n   * phantom association. False otherwise.\n   */\n  ItemMirror.prototype.isAssociationPhantom = function(guid) {\n    var data = this._fragment.associations[guid].commonData;\n    return !(data.isGrouping || data.localItem);\n  };\n\n  /**\n   * Duplicates (copies) an association to another ItemMirror Object (representing a grouping item)\n   *\n   *\n   * Throws NullArgumentException if GUID is null. <br/>\n   * Throws InvalidTypeException if GUID is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method copyAssociation\n   *\n   * @param {String} GUID GUID of the association you wish to copy/duplicate\n   * @param {ItemMirror} ItemMirror ItemMirror representing the grouping item you want to move the GUID object to\n   *\n   * @param {Function} callback Function to execute once finished.\n   * @param {Object} callback.error Null if no error Null if no error has occurred\n   *                 in executing this function, else it contains\n   *                 an object with the error that occurred.\n   */\n   ItemMirror.prototype.copyAssociation = function () {\n    throw new Error('Method not implemented');\n   };\n  /**\n   * Moves an association to another ItemMirror Object (representing a grouping item)\n   *\n   *\n   * Throws NullArgumentException if GUID is null. <br/>\n   * Throws InvalidTypeException if GUID is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method moveAssociation\n   *\n   * @param {String} GUID GUID of the item you want to paste or move\n   * @param {ItemMirror} ItemMirror ItemMirror representing the grouping item you want to move the GUID object to\n   *\n   * @param {Function} callback Function to execute once finished.\n   * @param {Object} callback.error Null if no error Null if no error has occurred\n   *                 in executing this function, else it contains\n   *                 an object with the error that occurred.\n   */\n   ItemMirror.prototype.moveAssociation = function () {\n    throw new Error('Method not implemented');\n   };\n\n  /**\n   * Deletes the association represented by the given GUID.\n   *\n   * Throws NullArgumentException if GUID is null. <br/>\n   * Throws InvalidTypeException if GUID is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method deleteAssociation\n   *\n   * @param GUID {String} GUID of the association to be deleted.\n   *\n   * @param {Function} callback Function to execute once finished.\n   *  @param {Object}   callback.error Null if no error has occurred\n   *                    in executing this function, else an contains\n   *                    an object with the error that occurred.\n   */\n  ItemMirror.prototype.deleteAssociation = function (GUID, callback) {\n    var self = this;\n\n    XooMLUtil.checkCallback(callback);\n    if (!GUID) {\n      return callback(XooMLExceptions.nullArgument);\n    }\n    if (!XooMLUtil.isGUID(GUID)) {\n      return callback(XooMLExceptions.invalidType);\n    }\n\n    // Save to ensure that the fragment is up to date\n    return self.save(deleteContent);\n\n    function deleteContent(error) {\n      if (error) return callback(error);\n\n      var isPhantom = self.isAssociationPhantom(GUID);\n\n      if (!isPhantom) {\n        var isGrouping = self.isAssociationAssociatedItemGrouping(GUID),\n            // For dropbox support, path should be the full path that is\n            // dynamically generated. Refer to case 39 for implementation\n            // details. UNTESTED\n            path = self.getAssociationAssociatedItem(GUID);\n\n        delete self._fragment.associations[GUID];\n        if (isGrouping) {\n          return self._itemDriver.deleteGroupingItem(path, postDelete);\n        } else {\n          return self._itemDriver.deleteNonGroupingItem(path, postDelete);\n        }\n      } else {\n        delete self._fragment.associations[GUID];\n\n        // Now do an unsafe_write to commit the XML. It's okay because\n        // save means that everything is synced, and this operation\n        // was extremely quick\n        return self._unsafeWrite(function(error) {\n          if (error) return callback(error);\n          else return callback();\n        });\n      }\n    }\n\n    // Now do a refresh since actual files were removed.\n    function postDelete(error) {\n      if (error) return callback(error);\n\n      return self.refresh(function(error) {\n        if (error) return callback(error);\n        return callback(error);\n      });\n    }\n\n  };\n\n  /**\n   * Upgrades a given association without a local item. Local item is named\n   * by a truncated form of the display name of this ItemMirror if the\n   * localItemURI is not given, else uses given localItemURI. Always\n   * truncated to 50 characters.\n   *\n   * ONLY SUPPORTS SIMPLE PHANTOM ASSOCIATION TO ASSOCIATION WITH GROUPING ITEM\n   *\n   * Throws NullArgumentException when options is null. <br/>\n   * Throws MissingParameterException when options is not null and a required\n   * argument is missing.<br/>\n   * Throws InvalidTypeException if GUID is not a string, and if callback\n   * is not a function. <br/>\n   * Throws InvalidState if the association with the given GUID cannot be\n   * upgraded. <br/>\n   *\n   * @method upgradeAssociation\n   *\n   * @param {Object} options Data to construct a new ItemMirror with\n   *\n   *  @param {String} options.GUID of the association to be upgraded. Required\n   *\n   *  @param {String} options.localItemURI URI of the local item to be used if\n   *                  a truncated display name is not the intended behavior.\n   *                  Optional.\n   *\n   * @param {Function} callback Function to execute once finished.\n   *\n   *  @param {String}   callback.error Null if no error has occurred\n   *                    in executing this function, else an contains\n   *                    an object with the error that occurred.\n   */\n  ItemMirror.prototype.upgradeAssociation = function () {\n    throw new Error('Method not implemented');\n  };\n\n  /**\n   * Renames the local item for the association with the given GUID.\n   *\n   * Throws NullArgumentException if GUID, callback is null. <br/>\n   * Throws InvalidTypeException if GUID is not a String, and if callback\n   * is not a function. <br/>\n   *\n   * @method renameAssocaitionLocalItem\n   *\n   * @param {String} GUID GUID of the association.\n   * @param {String} String String Name you want to rename the file to (including file extension)\n   * @param {Function} callback Function to execute once finished.\n   *  @param {Object}   callback.error Null if no error has occurred\n   *                    in executing this function, else an contains\n   *                    an object with the error that occurred.\n   * @param {String} callback.GUID The GUID of the association that was updated.\n   */\n  ItemMirror.prototype.renameAssociationLocalItem = function (GUID, newName, callback) {\n    // This method needs a redesign, and can't be properly implemented the way\n    // it is now. Instead, this needs to pass information to the acual item\n    // driver and that needs to implement an agnostic new name format. This\n    // path stuff is specific to dropbox and doesn't work\n    var self = this;\n    XooMLUtil.checkCallback(callback);\n    if (!GUID) {\n      return callback(XooMLExceptions.nullArgument);\n    }\n    if (!XooMLUtil.isGUID(GUID)) {\n      return callback(XooMLExceptions.invalidType);\n    }\n\n    self.save(postSave);\n\n    function postSave(error) {\n      if (error) return callback(error);\n\n      // This stuff needs to be replaced with a method that works for all stores\n          // oldPath = PathDriver.joinPath(self._groupingItemURI, localItem),\n          // newPath = PathDriver.joinPath(self._groupingItemURI, newName);\n\n      self._itemDriver.rename(newName, postMove);\n    }\n\n    function postMove(error) {\n      if (error) return callback(error);\n      // This also needs to be more agnostic\n      self._fragment.associations[GUID].commonData.localItem = newName;\n\n      self._unsafeWrite(postWrite);\n    }\n\n    function postWrite(error) {\n      if (error) return callback(error);\n\n      self.refresh(postRefresh);\n    }\n\n    function postRefresh(error) {\n      return callback(error, self._fragment.associations[GUID].commonData.ID);\n    }\n  };\n\n  /**\n   * A special method that is used for certain file operations where\n   * calling a sync won't work. Essentially it is the save function,\n   * sans syncing. This should __never__ be called be an application.\n   * @method _unsafeWrite\n   * @param callback\n   * @param calback.error\n   */\n  ItemMirror.prototype._unsafeWrite = function(callback) {\n    var self = this;\n\n    // Note (12/8/2015) This was never used, but seems like it has purpose. May need to investigate\n    //var tmpFragment = new FragmentEditor({text: content});\n    self._fragment.updateID();\n    return self._xooMLDriver.setXooMLFragment(self._fragment.toString(), function(error) {\n      if (error) return callback(error);\n      return callback(false);\n    });\n  };\n\n  /**\n   * Checks if an association's associatedItem is a grouping item\n   *\n   * Throws NullArgumentException if GUID, callback is null. <br/>\n   * Throws InvalidTypeException if GUID is not a String, and if callback\n   * is not an function. <br/>\n   *\n   * @method isAssociationAssociatedItemGrouping\n   * @return {Boolean} True if the association with the given GUID's associatedItem is a grouping\n   * item, otherwise false.\n   *\n   * @param GUID {String} GUID of the association to be to be checked.\n   *\n   */\n  ItemMirror.prototype.isAssociationAssociatedItemGrouping = function(GUID) {\n    return this._fragment.associations[GUID].commonData.isGrouping;\n  };\n\n  /**\n   * Lists the GUIDs of each association.\n   *\n   * @method listAssociations\n   *\n   * @return {String[]} Array of the GUIDs of each association\n   */\n  ItemMirror.prototype.listAssociations = function() {\n    return Object.keys(this._fragment.associations);\n  };\n\n  /**\n   *\n   * Throws NullArgumentException if attributeName, GUID, or namespaceURI is\n   * null. <br/>\n   * Throws InvalidTypeException if attributeName, GUID, or namespaceURI is not\n   * a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method getAssociationNamespaceAttribute\n   * @return {String} The association namespace attribute with\n   * the given attributeName and the given namespaceURI within the\n   * association with the given GUID.\n   *\n   * @param {String} attributeName Name of the attribute to be returned.\n   * @param {String} GUID          GUID of the association to return attribute from.\n   * @param {String} uri Namspace URI\n   *\n   */\n  ItemMirror.prototype.getAssociationNamespaceAttribute = function(attributeName, GUID, uri) {\n    var ns = this._fragment.associations[GUID].namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    return this._fragment.associations[GUID].namespace[uri].attributes[attributeName];\n  };\n\n  /**\n   * Sets the association namespace attribute with the given attributeName\n   * and the given namespaceURI within the association with the given GUID.\n   *\n   * Throws NullArgumentException if attributeName, attributeValue, GUID, or\n   * namespaceURI is null. <br/>\n   * Throws InvalidTypeException if attributeName, attributeValue, GUID, or\n   * namespaceURI is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method setAssociationNamespaceAttribute\n   *\n   * @param {String} attributeName  Name of the attribute to be set.\n   * @param {String} attributeValue Value of the attribute to be set\n   * @param {String} GUID           GUID of association to set attribute for.\n   * @param {String} uri Namespace URI\n   *\n   */\n  ItemMirror.prototype.setAssociationNamespaceAttribute = function(attributeName, attributeValue, GUID, uri) {\n    var ns = this._fragment.associations[GUID].namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    this._fragment.associations[GUID].namespace[uri].attributes[attributeName] = attributeValue;\n  };\n\n  /**\n   * Adds the given attributeName to the association with the given GUID and\n   * namespaceURI.\n   *\n   * Throws NullArgumentException if attributeName, GUID, or namespaceURI is\n   * null. <br/>\n   * Throws InvalidTypeException if attributeName, GUID, or namespaceURI is not\n   * a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   * Throws an InvalidStateException when the given attributeName has already\n   * been added. <br/>\n   *\n   * @method addAssociationNamespaceAttribute\n   *\n   * @param {String} attributeName Name of the attribute.\n   * @param {String} attributeValue Value of the attribe to be set\n   * @param {String} GUID          GUID of the association.\n   * @param {String} uri Namespace URI\n   */\n  ItemMirror.prototype.addAssociationNamespaceAttribute = function(attributeName, attributeValue, GUID, uri) {\n    var ns = this._fragment.associations[GUID].namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    if (this._fragment.associations[GUID].namespace[uri].attributes[attributeName]) {\n      throw XooMLExceptions.invalidState;\n    }\n    this.setAssociationNamespaceAttribute(attributeName, attributeValue, GUID, uri);\n  };\n\n  /**\n   * Removes the given attributeName to the association with the given GUID and\n   * namespaceURI.\n   *\n   * Throws NullArgumentException if attributeName, GUID, or namespaceURI is\n   * null. <br/>\n   * Throws InvalidTypeException if attributeName, GUID, or namespaceURI is not\n   * a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   * Throws an InvalidStateException when the given attributeName is not an\n   * attribute. <br/>\n   *\n   * @method removeAssociationNamespaceAttribute\n   *\n   * @param {String} attributeName Name of the attribute.\n   * @param {String} GUID          GUID of the association.\n   * @param {String} uri Namespace URI\n   */\n  ItemMirror.prototype.removeAssociationNamespaceAttribute = function(attributeName, GUID, uri) {\n    delete this._fragment.associations[GUID].namespace[uri].attributes[attributeName];\n  };\n\n  /**\n   * @method hasAssociationNamespace\n   * @return {Boolean} True if the association has the given\n   * namespaceURI, else false.\n   *\n   * @param {String} GUID          GUID of the association.\n   * @param {String} uri  Namespace URI\n   *\n   */\n  ItemMirror.prototype.hasAssociationNamespace = function(GUID, uri) {\n    var namespace = this._fragment.associations[GUID].namespace[uri];\n    if (namespace) { return true; }\n    else { return false; }\n  };\n\n  /**\n   *\n   * Throws NullArgumentException if GUID, namespaceURI is null. <br/>\n   * Throws InvalidTypeException if GUID, namespaceURI is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method listAssociationNamespaceAttributes\n   * @return {String[]} An array of the association namespace\n   * attributes with the given attributeName and the given\n   * namespaceURI within the association with the given GUID.\n   *\n   * @param {String} GUID          GUID of association to list attributes for.\n   * @param {String} uri Namespace URI\n   */\n  ItemMirror.prototype.listAssociationNamespaceAttributes = function (GUID, uri) {\n    var ns = this._fragment.associations[GUID].namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    return Object.keys(this._fragment.associations[GUID].namespace[uri].attributes);\n  };\n\n  /**\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method getAssociationNamespaceData\n   * @return {String} The association namespace data for an\n   * association with the given GUID and the given namespaceURI.\n   *\n   * @param {String} GUID GUID of the association namespace data to\n   * returned.\n   * @param {String} uri Namespace URI\n   */\n  self.getAssociationNamespaceData = function (GUID, uri) {\n    var ns = this._fragment.associations[GUID].namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    return this._fragment.associations[GUID].namespace[uri].data;\n  };\n\n  /**\n   * Sets the association namespace data for an association with the given GUID\n   * and given namespaceURI using the given data.\n   *\n   * Throws NullArgumentException if data, GUID, or namespaceURI is null. <br/>\n   * Throws InvalidTypeException if data, GUID, or namespaceURI is not a\n   * String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method setAssociationNamespaceData\n   *\n   * @param {String} data          Association namespace data to set. Must be\n   *                               valid fragmentNamespaceData.\n   * @param {String} GUID          GUID of the association namespace data to set.\n   */\n  ItemMirror.prototype.setAssociationNamespaceData = function (data, GUID, uri) {\n    var ns = this._fragment.associations[GUID].namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    this._fragment.associations[GUID].namespace[uri].data = data;\n  };\n\n  /**\n   * Uses the specified ItemDriver and SyncDriver to synchronize the\n   * local ItemMirror object changes. This is an implmentation of Synchronization\n   * Driver which modifies the XooML Fragment according to the real structure\n   * under the item described.\n   *\n   * @method sync\n   *\n   * @param {Function} callback Function to execute once finished.\n   *  @param {Object}   callback.error Null if no error has occurred\n   *                    in executing this function, else an contains\n   *                    an object with the error that occurred.\n   * @private\n   */\n  ItemMirror.prototype._sync = function (callback) {\n    var self = this;\n\n    self._syncDriver.sync(callback);\n  };\n\n  /**\n   * Reloads the XooML Fragment\n   *\n   * @method refresh\n   *\n   * @param {Function} callback Function to execute once finished.\n   *  @param {Object}   callback.error Null if no error has occurred\n   *                    in executing this function, else an contains\n   *                    an object with the error that occurred.\n   */\n  ItemMirror.prototype.refresh = function(callback) {\n    var self = this;\n\n    self._sync( function(error) {\n      // This error means that sync changed the fragment\n      // We then will reload the fragment based on the new XooML\n      if (error === XooMLExceptions.itemMirrorNotCurrent) {\n        self._xooMLDriver.getXooMLFragment(resetFragment);\n      } else if (error) {\n        callback(error);\n      } else {\n        self._xooMLDriver.getXooMLFragment(resetFragment);\n      }\n    });\n\n    function resetFragment(error, content){\n      if (error) return callback(error);\n\n      self._fragment = new FragmentEditor({text: content});\n      return callback(false);\n    }\n  };\n\n  /**\n   * @method getCreator\n   *\n   * @return {Object} The itemMirror that created this current\n   * itemMirror, if it has one. Note that this isn't the same as\n   * asking for a 'parent,' since multiple itemMirrors can possibly\n   * link to the same one\n   *\n   */\n  ItemMirror.prototype.getCreator = function () {\n    return this._creator;\n  };\n\n\n  /**\n   * Saves the itemMirror object, writing it out to the\n   * fragment. Fails if the GUID generated on last write for the\n   * itemMirror and the XooML fragment don't match.\n   *\n   * @method save\n   *\n   * @param callback\n   *  @param callback.error Returns false if everything went ok,\n   *  otherwise returns the error\n   */\n  ItemMirror.prototype.save = function(callback) {\n    var self = this;\n\n    self._sync(postSync);\n\n    function postSync(error) {\n      if (error) return callback(error);\n\n      return self._unsafeWrite(postWrite);\n    }\n\n    function postWrite(error) {\n      return callback(error);\n    }\n  };\n\n/**\n * Checks if the AssociatedItem String passed into it is a URL or not.\n *\n * @method _isURL\n * @return {Boolean} True if it is an HTTP URL, false otherwise\n * (HTTPS will fail)\n * @private\n * @param {String} URL\n */\n  self._isURL = function (URL){\n    return /^http:\\/\\//.exec(URL);\n  };\n\n\n// This makes the pacakge accessible as a node module\nmodule.exports = ItemMirror;\n\n// This attaches the library as a global if it doesn't already exist\nif (window) { // Checks for window object so we don't break potential node usage\n  window.ItemMirror = window.ItemMirror || ItemMirror\n}\n},{\"./AssociationEditor\":1,\"./FragmentEditor\":2,\"./SyncDriver\":4,\"./XooMLExceptions\":6,\"./XooMLUtil\":7,\"./google-item-driver\":8,\"./google-xooml-driver\":9}],4:[function(require,module,exports){\n/**\n * An implementation of SyncDriver which syncronizes the XooML so that\n * it reflects the storage. This implementation ensures that only the\n * XooML is modified, and that the user's storage is never modified,\n * safely protecting any data.\n *\n * For ItemMirror core developers only. Enable protected to see.\n *\n * @class SyncDriver\n *\n * @constructor\n * @param {Object} itemMirror The itemMirror object which you wish to\n * synchronize\n *\n * @protected\n */\n\n\n'use strict'\n\nvar FragmentEditor = require('./FragmentEditor');\n\n  function SyncDriver(itemMirror) {\n    var self = this;\n    self._itemMirror = itemMirror;\n    self._itemDriver = itemMirror._itemDriver;\n    self._xooMLDriver = itemMirror._xooMLDriver;\n  }\n\n  /**\n   * Helper method that allows for sorting of objects by the localItem\n   *\n   * @method _nameCompare\n   * @private\n   * @protected\n   */\n  function _localItemCompare(a, b) {\n    if (a.commonData.localItem > b.commonData.localItem) return 1;\n    else if (a.commonData.localItem < b.commonData.localItem) return -1;\n    else return 0;\n  }\n\n  /**\n   * Synchonizes the itemMirror object.\n   *\n   * @method sync\n   *\n   * @param {Function} callback Function to execute once finished.\n   *  @param {Object}   callback.error Null if no error has occurred\n   *                    in executing this function, else an contains\n   *                    an object with the error that occurred.\n   *\n   * @protected\n   */\n  SyncDriver.prototype.sync = function(callback) {\n    var self = this,\n        itemAssociations;\n\n    self._itemDriver.listItems(self._itemMirror._groupingItemURI,\n                               processItems);\n\n    function processItems(error, associations){\n      if (error) return callback(error);\n\n      itemAssociations = associations;\n      self._xooMLDriver.getXooMLFragment(processXooML);\n    }\n\n    function processXooML(error, xooMLContent) {\n      // A 404 error is dropbox telling us that the file doesn't\n      // exist. In that case we just write the file\n      if (error === 404) {\n        var fragmentString = self._itemMirror._fragment.toString();\n        return self._xooMLDriver.setXooMLFragment( fragmentString, function(error) {\n          if (error) callback(error);\n          else callback(false);\n        });\n      } else if (error) {\n        return callback(error);\n      }\n\n      // Keeps track of the index in the xooMLassociations so that\n      // we don't waste time searching from the beginning\n      var xooMLIdx = 0;\n      // Keeps track of whether there are any changes that need to be made\n      var synchronized = true;\n      var xooMLAssociations;\n\n      self._fragmentEditor = new FragmentEditor({text: xooMLContent});\n\n      xooMLAssociations = Object.keys(self._fragmentEditor.associations)\n      // Turns the associative array into a regular array for iteration\n        .map( function(guid) {\n          return self._fragmentEditor.associations[guid];\n        })\n      // filters out any phantoms\n  .filter( function(assoc) {\n    return assoc.commonData.localItem !== null;\n  });\n\n      // No guarantee that the storage API sends results sorted\n      itemAssociations.sort(_localItemCompare);\n      xooMLAssociations.sort(_localItemCompare);\n\n      // Gets the localItems in a separate array, but in needed sorted order\n      var itemLocals = itemAssociations.map( function (assoc) {return assoc.commonData.localItem;} );\n      var xooMLLocals = xooMLAssociations.map( function (assoc) {return assoc.commonData.localItem;} );\n\n      itemLocals.forEach( function(localItem, itemIdx) {\n  var search = xooMLLocals.lastIndexOf(localItem, xooMLIdx);\n  // Create association\n  if (search === -1) {\n    synchronized = false;\n    // Case 6/7 only, other cases won't be handled\n          var association = itemAssociations[itemIdx];\n          self._fragmentEditor.associations[association.commonData.ID] = association;\n  } else {\n    // Deletes any extraneous associations\n    xooMLAssociations\n      .slice(xooMLIdx, search)\n      .forEach( function(assoc) {\n        synchronized = false;\n              delete self._fragmentEditor.associations[assoc.guid];\n      });\n    xooMLIdx = search + 1;\n  }\n      });\n      // Any remaining associations need to be deleted because they don't exist\n      xooMLAssociations\n  .slice(xooMLIdx, xooMLLocals.length)\n  .forEach( function(assoc) {\n    synchronized = false;\n          delete self._fragmentEditor.associations[assoc.commonData.ID];\n  });\n\n      // Only save fragment if needed\n      if (!synchronized) {\n        self._fragmentEditor.updateID(); // generate a new guid for GUIDGeneratedOnLastWrite;\n        // Writes out the fragment\n        self._xooMLDriver.setXooMLFragment(self._fragmentEditor.toString(), function(error) {\n          if (error) return callback(error);\n\n          return callback(false);\n        });\n      } else return callback(false);\n    }\n  };\n\nmodule.exports = SyncDriver;\n},{\"./FragmentEditor\":2}],5:[function(require,module,exports){\n/**\n * Configuration variables for XooML.js\n *\n * For ItemMirror core developers only. Enable protected to see.\n *\n * @class XooMLConfig\n * @static\n *\n * @protected\n */\nmodule.exports = {\n  // default schema version\n  schemaVersion: \"0.54\",\n\n  // default schema location\n  schemaLocation: \"http://kftf.ischool.washington.edu/xmlns/xooml\",\n\n  // XooMLFragment file name for XooML2.xmlns\n  xooMLFragmentFileName: \"XooML2.xml\",\n\n  // Maximum file length for upgradeAssociation localItemURI truncation\n  maxFileLength: 50,\n\n  // Case 1\n  createAssociationSimple: {\n    \"displayText\": true\n  },\n\n  // Case 2 and 3\n  // localItemRequested exists:> case 3\n  createAssociationLinkNonGrouping: {\n    \"displayText\": true,        // String\n    \"itemURI\": true,            // String\n    \"localItemRequested\": false // String\n  },\n\n  // Case 4 and 5\n  // localItemRequested:== true:> Case 5\n  createAssociationLinkGrouping: { // Case 3\n    \"displayText\": true,\n    \"groupingItemURI\": true,\n    \"xooMLDriverURI\": true\n  },\n\n  // Case 6 and 7\n  createAssociationCreate: {\n    \"displayText\": true,\n    \"itemName\": true,\n    \"isGroupingItem\": true\n  }\n}\n},{}],6:[function(require,module,exports){\n/**\n * Collection of exceptions associated with the XooML tools.\n *\n * For ItemMirror core developers only. Enable protected to see.\n *\n * @class XooMLExceptions\n * @static\n *\n * @protected\n */\nmodule.exports = {\n  /**\n   * Thrown when a method is not yet implemented.\n   *\n   * @event NotImplementedException\n   *\n   * @protected\n   */\n  notImplemented: \"NotImplementedException\",\n\n  /**\n   * Thrown when a required property from a method's options is missing.\n   *\n   * @event MissingParameterException\n   *\n   * @protected\n   */\n  missingParameter: \"MissingParameterException\",\n\n  /**\n   * Thrown when an argument is given a null value when it does not accept null\n   * values.\n   *\n   * @event NullArgumentException\n   *\n   * @protected\n   */\n  nullArgument: \"NullArgumentException\",\n\n  /**\n   * Thrown when an argument is given a value with a different type from the\n   * expected type.\n   *\n   * @event InvalidTypeException\n   *\n   * @protected\n   */\n  invalidType: \"InvalidTypeException\",\n\n  /**\n   * Thrown when an a method is called when the object is in invalid state\n   * given what the method expected.\n   *\n   * @event InvalidStateArgument\n   *\n   * @protected\n   */\n  invalidState: \"InvalidStateArgument\",\n\n  /**\n   * Thrown after receiving an exception from XooMLU Storage\n   *\n   * @event XooMLUException\n   *\n   * @protected\n   */\n  xooMLUException: \"XooMLUException\",\n\n  /**\n   * Thrown after receiving an exception from ItemU Storage\n   *\n   * @event ItemUException\n   *\n   * @protected\n   */\n  itemUException: \"ItemUException\",\n\n  /**\n   * Thrown after an association was upgraded that could not be upgraded.\n   *\n   * @event NonUpgradeableAssociationException\n   *\n   * @protected\n   */\n  nonUpgradeableAssociationException: \"NonUpgradeableAssociationException\",\n\n  /**\n   * Thrown after an argument was passed in an invalid state than expected.\n   *\n   * @event InvalidArgumentException\n   *\n   * @protected\n   */\n  invalidArgument: \"InvalidOptionsException\",\n\n  /**\n   * Thrown after expecting a file or folder not to exist when it does.\n   *\n   * @event FileOrFolderAlreadyExistsException\n   *\n   * @protected\n   */\n  itemAlreadyExists: \"ItemAlreadyExistsException\",\n\n  /**\n   * Thrown when expecting the ItemMirror to be current, and it is not.\n   *\n   * @event FileOrFolderAlreadyExistsException\n   *\n   * @protected\n   */\n  itemMirrorNotCurrent: \"ItemMirrorNotCurrent\"\n}\n},{}],7:[function(require,module,exports){\n/**\n * Collection of type checking, exception throwing, utility methods for the\n * XooML tools.\n *\n * For ItemMirror core developers only. Enable protected to see.\n *\n * @class XooMLUtil\n * @static\n *\n * @protected\n */\n\n 'use strict'\n\n var XooMLExceptions = require('./XooMLExceptions');\n\n  var\n    _TYPES = {\n      \"[object Boolean]\": \"boolean\",\n      \"[object Number]\": \"number\",\n      \"[object String]\": \"string\",\n      \"[object Function]\": \"function\",\n      \"[object Array]\": \"array\",\n      \"[object Date]\": \"date\",\n      \"[object RegExp]\": \"regexp\",\n      \"[object Object]\": \"object\",\n      \"[object Error]\": \"error\"\n    };\n\n  var XooMLUtil = {\n    /**\n     * Checks if each option within the given checkedOptions is a property of\n     * the given options.\n     *\n     * @method hasOptions\n     *\n     * @param {Object}  checkedOptions Array of strings for each expected option.\n     * @param {Object} options         Options given to a function.\n     *\n     * @protected\n     */\n    hasOptions: function (checkedOptions, options) {\n      if (!checkedOptions || !options) {\n        throw XooMLExceptions.nullArgument;\n      }\n      if (!XooMLUtil.isObject(checkedOptions) ||\n          !XooMLUtil.isObject(options)) {\n        throw XooMLExceptions.invalidType;\n      }\n      var checkedOption, isRequiredOption, missingOptionalParamCount;\n\n      missingOptionalParamCount = 0;\n\n      if (Object.keys(options).length <= Object.keys(checkedOptions).length) {\n        for (checkedOption in checkedOptions) {\n          if (checkedOptions.hasOwnProperty(checkedOption)) {\n            isRequiredOption = checkedOptions[checkedOption];\n\n            if (!options.hasOwnProperty(checkedOption)) {\n              if (isRequiredOption) {\n                return false;\n              } else {\n                missingOptionalParamCount += 1;\n              }\n            }\n          }\n        }\n      } else {\n        return false;\n      }\n\n      return Object.keys(options).length <=\n        Object.keys(checkedOptions).length - missingOptionalParamCount;\n    },\n\n    // throws exceptions for callbacks since null callbacks mean the program can't continue\n    checkCallback: function (callback) {\n      if (callback) {\n        if (!XooMLUtil.isFunction(callback)) {\n          throw XooMLExceptions.invalidType;\n        }\n      } else {\n        throw XooMLExceptions.nullArgument;\n      }\n    },\n\n    isGUID: function (GUID) {\n      if (XooMLUtil.getType(GUID) === \"string\") {\n        return true; // TODO implement guid checking\n      } else {\n        return false;\n      }\n    },\n\n    /**\n     * Returns if the given value is an array.\n     *\n     * Throws NullArgumentException when value is null. <br/>\n     *\n     * @method isArray\n     *\n     * @param {Object} value Given object have it's type checked.\n     *\n     * @protected\n     */\n    isArray: function (value) {\n      return XooMLUtil.getType(value) === \"array\";\n    },\n\n    /**\n     * Returns if the given value is an object.\n     *\n     * Throws NullArgumentException when value is null. <br/>\n     *\n     * @method isObject\n     *\n     * @param {Object} value Given object have it's type checked.\n     *\n     * @return {Boolean} True if the given value is an Object, else false.\n     *\n     * @protected\n     */\n    isObject: function (value) {\n      return XooMLUtil.getType(value) === \"object\";\n    },\n\n    /**\n     * Returns if the given value is an function.\n     *\n     * Throws NullArgumentException when value is null. <br/>\n     *\n     * @method isFunction\n     *\n     * @param {Object} value Given object have it's type checked.\n     *\n     * @return {Boolean} True if the given value is a Function, else false.\n     *\n     * @protected\n     */\n    isFunction: function (value) {\n      return value !== null;\n      //return XooMLUtil.getType(value) === \"function\"; TODO figure out why this doesn't work\n    },\n\n    /**\n     * Returns if the given value is an string.\n     *\n     * Throws NullArgumentException when value is null. <br/>\n     *\n     * @method isString\n     *\n     * @param {Object} value Given object have it's type checked.\n     *\n     * @return {Boolean} True if the given value is a String, else false.\n     *\n     * @protected\n     */\n    isString: function (value) {\n      return XooMLUtil.getType(value) === \"string\";\n    },\n\n    isBoolean: function (value) {\n      return XooMLUtil.getType(value) === \"boolean\";\n    },\n\n    /**\n     * Generates a GUID.\n     *\n     * @method generateGUID\n     *\n     * @return {String} Randomly generated GUID.\n     *\n     * @protected\n     */\n    generateGUID: function () {\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n      });\n    },\n\n    getType: function (obj) {\n      if (obj === null) {\n        return String(obj);\n      }\n      return typeof obj === \"object\" ||\n        typeof obj === \"function\" ? _TYPES[obj.toString()] || \"object\" : typeof obj;\n    },\n\n    endsWith: function (string, suffix) {\n      return string.indexOf(suffix, string.length - suffix.length) !== -1;\n    },\n\n    // http://stackoverflow.com/questions/728360/most-elegant-way-to-clone-a-javascript-object\n    clone: function (obj) {\n      var copy;\n      // Handle the 3 simple types, and null or undefined\n      if (null === obj || \"object\" != typeof obj) return obj;\n\n      // Handle Date\n      if (obj instanceof Date) {\n        copy = new Date();\n        copy.setTime(obj.getTime());\n        return copy;\n      }\n\n      // Handle Array\n      if (obj instanceof Array) {\n        copy = [];\n        for (var i = 0, len = obj.length; i < len; i++) {\n          copy[i] = XooMLUtil.clone(obj[i]);\n        }\n        return copy;\n      }\n\n      // Handle Object\n      if (obj instanceof Object) {\n        copy = {};\n        for (var attr in obj) {\n          if (obj.hasOwnProperty(attr)) copy[attr] = XooMLUtil.clone(obj[attr]);\n        }\n        return copy;\n      }\n\n      throw XooMLExceptions.invalidType;\n    }\n  };\n\nmodule.exports = XooMLUtil;\n},{\"./XooMLExceptions\":6}],8:[function(require,module,exports){\n/**\n * An item utility interacts with the item storage and is responsible for\n * creating and deleting items. This is an implementation of item utility\n * using Dropbox as the item storage.\n *\n * For ItemMirror core developers only. Enable protected to see.\n *\n * @class ItemDriver\n * @constructor\n *\n * @param {Object} options Data to construct a new ItemU with\n * @param {String} options.utilityURI URI of the utility\n * @param {Object} options.dropboxClient Authenticated dropbox client\n *\n * @protected\n */\n\n'use strict'\n\nvar XooMLConfig = require('./XooMLConfig');\nvar AssociationEditor = require('./AssociationEditor');\n\n  /**\n   * Constructs a ItemDriver for reading/writing Item Storage\n   *\n   * @method ItemDriver\n   *\n   * @param {Object} options Options passed for construction\n   * @param {Function} callback The function to call after completion\n   *\n   * @protected\n   */\n  function ItemDriver(options, callback) {\n    var self = this;\n\n    // client (google drive in this case)\n    if (!options.clientInterface) {\n      throw new Error('Client parameter missing');\n    }\n    this.clientInterface = options.clientInterface;\n\n    var authResponse = this.clientInterface.auth2.getAuthInstance()\n      .currentUser.get()\n      .getAuthResponse();\n\n    // These are the same across multple files, and so should be put in a common configuration somewhere\n    this._AUTH_HEADER = { Authorization: 'Bearer ' + authResponse.access_token };\n    this._DRIVE_FILE_API = 'https://www.googleapis.com/drive/v2/files/';\n\n    self._FOLDER_MIMETYPE = 'application/vnd.google-apps.folder';\n\n    return callback(false, self);\n  }\n\n  ItemDriver.prototype.isGroupingItem = function (id, callback) {\n    var self = this;\n\n    // do a simple get request, and see if it's a folder\n    $.get({\n      url: self._DRIVE_FILE_API + id,\n      headers: self._AUTH_HEADER\n    }).then(function(resp) {\n      // This is the specific mimetype that google counts as a 'folder'\n      callback(false, self._FOLDER_MIMETYPE === resp.mimeType);\n    }).fail(function() {\n      callback('No response from GET: ' + id);\n    });\n  };\n\n  /**\n   * Creates a grouping item at the location\n   * @method createGroupingItem\n   * @param {String} path the path to the location that the grouping item will be created\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\n   *\n   * @protected\n   */\n  ItemDriver.prototype.createGroupingItem = function (parentURI, title, callback) {\n    var self = this;\n\n    $.post({\n      url: self._DRIVE_FILE_API,\n      headers: self._AUTH_HEADER,\n      body: {\n        mimeType: self._FOLDER_MIMETYPE,\n        title: title,\n        parents: [parentURI]\n      }\n    }).then(function(resp) {\n      // Callback with ID of the newly created folder so we have a reference\n      callback(false, resp.id);\n    }).fail(function() {\n      callback('Failed to make POST request for new grouping item. Check network requests for more deatils');\n    });\n  };\n\n  /**\n   * Creates or uploads a non-grouping item at the location\n   * @method createNonGroupingItem\n   * @param {String} path the path to the location that the non-grouping item will be created\n   * @param {String} file the contents to be written to the non-grouping item\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\n   *\n   * @protected\n   */\n  ItemDriver.prototype.createNonGroupingItem = function (fileName, file, callback) {\n    var self = this;\n\n    function insertFile(fileData, callback) {\n      var boundary = '-------314159265358979323846';\n      var delimiter = \"\\r\\n--\" + boundary + \"\\r\\n\";\n      var close_delim = \"\\r\\n--\" + boundary + \"--\";\n\n      var reader = new FileReader();\n      reader.readAsBinaryString(fileData);\n      reader.onload = function() {\n        var contentType = fileData.type || 'application/octet-stream';\n        var metadata = {\n          'title': XooMLConfig.xooMLFragmentFileName,\n          'mimeType': contentType,\n          'parents': [{\n            \"kind\": \"drive#parentReference\",\n            \"id\": self._parentURI\n          }]\n        };\n\n        var base64Data = btoa(reader.result);\n        var multipartRequestBody =\n            delimiter +\n            'Content-Type: application/json\\r\\n\\r\\n' +\n            JSON.stringify(metadata) +\n            delimiter +\n            'Content-Type: ' + contentType + '\\r\\n' +\n            'Content-Transfer-Encoding: base64\\r\\n' +\n            '\\r\\n' +\n            base64Data +\n            close_delim;\n\n        var request = this.gapi.client.request({\n            'path': '/upload/drive/v2/files',\n            'method': 'POST',\n            'params': {'uploadType': 'multipart'},\n            'headers': {\n              'Content-Type': 'multipart/mixed; boundary=\"' + boundary + '\"'\n            },\n            'body': multipartRequestBody});\n        request.execute(function(response) {\n          callback(false, response);\n        }, function(response) {\n          callback('Could not write out File', response);\n        });\n      };\n    }\n\n    var blob = new Blob([file], {type: 'text/plain', fileName: fileName});\n\n    return insertFile(blob, callback);\n  };\n\n\n  // Helper function for deleting files, since no distinction is needed\n  // between grouping items and non grouping items in google drive\n  ItemDriver.prototype._deleteID = function (id, callback) {\n    var self = this;\n\n    $.delete({\n      url: self._DRIVE_FILE_API + '/' + id,\n      headers: self._AUTH_HEADER\n    }).then(function(resp) {\n      callback(false, resp);\n    }).fail(function(resp) {\n      callback('Failed to make DELETE request for new grouping item. Check network requests for more deatils', resp);\n    });\n  }\n  /**\n   * Deletes a grouping item with the specified ID\n   * @method deleteGroupingItem\n   * @param {String} id the id of the file that will be deleted. This is specific to google\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\n   *\n   * @protected\n   */\n  ItemDriver.prototype.deleteGroupingItem = function (id, callback) {\n    this._deleteID(id, callback);\n  };\n\n  /**\n   * Deletes a non-grouping item at the location\n   * @method deleteNonGroupingItem\n   * @param {String} id the id of the file that will be deleted. This is specific to google\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\n   *\n   * @protected\n   */\n  ItemDriver.prototype.deleteNonGroupingItem = function (id, callback) {\n    this._deleteID(id, callback);\n  };\n  \n  /**\n   * Lists the items under the grouping item\n   * @method listItems\n   * @param {String} path the path to the grouping item\n   * @param {Function} callback(output) Function to be called when self function is finished with it's operation. Output is an array of AssociationEditors.\n   *\n   * @protected\n   */\n  ItemDriver.prototype.listItems = function (parentURI, callback) {\n    var self = this;\n\n    var query = '\\'' + parentURI + '\\' in ' + 'parents';\n    var request = this.clientInterface.client.drive.files.list({\n      'maxResults': 1000,\n      'q': query\n    });\n    request.execute(function(resp) {\n      if (resp.error) {\n        return callback('Error: Bad Response / Request');  \n      }\n\n      var items = resp.items.filter(function(item) {\n        return item.title !== XooMLConfig.xooMLFragmentFileName;\n      })\n      .map(function(item) {\n        return new AssociationEditor({\n          commonData: {\n            // Change this to be the ID of the XooML.xml file eventually\n            // Will need another parameter for that\n            associatedXooMLFragment: null, \n            associatedItem: item.id,\n            associatedItemDriver: 'GoogleItemDriver',\n            associatedXooMLDriver: 'GoogleXooMLDriver',\n            associatedSyncDriver: 'MirrorSyncDriver', \n            isGrouping: item.mimeType === self._FOLDER_MIMETYPE,\n            localItem: item.id,\n            displayText: item.title,\n            publicURL: item.alternateLink\n          }\n        });\n      });\n\n      callback(false, items);\n    });\n  };\n\n  /**\n   * Check if the item is existed\n   * @method checkExisted\n   * @param {String} path the path to the location that the item is located\n   * @param {String} name the name of the item\n   * @param {Function} callback(result) Function to be called when self function is finished with it's operation. Result is the bollean value for whether existed.\n   *\n   * @protected\n   */\n  ItemDriver.prototype.checkExisted = function(path, callback){\n    var self = this, result;\n\n    self._dropboxClient.stat(path, function (error,stat){\n      if (error) {\n        return self._showDropboxError(error, callback);\n      }\n      result = !(error !== null && error.status === 404) || (error === null && stat.isRemoved);\n\n      return callback(false, result);\n    });\n  };\n\nmodule.exports = ItemDriver;\n},{\"./AssociationEditor\":1,\"./XooMLConfig\":5}],9:[function(require,module,exports){\n/**\n * An XooML utility interacts with an storage and is responsible for\n * reading and writing XooML fragments. This is an implementation of XooML utility\n * using Dropbox as the storage.\n *\n * This specific version is for google drive\n *\n * For ItemMirror core developers only. Enable protected to see.\n *\n * @class XooMLDriver\n * @constructor\n *\n * @param {Object} options Data to construct a new XooMLU with\n * @param {String} options.fragmentURI The URI of fragment\n * contains the XooML\n * @param {String} options.utilityURI URI of the utility\n * @param {Object} options.dropboxClient Authenticated dropbox client\n *\n * @protected\n */\n\nvar XooMLConfig = require('./XooMLConfig');\n  /**\n   * Constructs a XooMLDriver for reading/writing XooML fragment.\n   *\n   * @method XooMLDriver\n   *\n   * @param {Object} options A list of options for construction\n   * @param {Function} callback A function to call after completion\n   *\n   * @protected\n   */\n  function XooMLDriver(options, callback) {\n    var self = this;\n\n    if (!options.clientInterface) {\n      throw new Error('Missing client interface in options!');\n    }\n\n    // The parent URI tells us what 'folder', the XooML should be put inside\n    // of. Root is a special URI for google drive, otherwise it should be an\n    // id\n    this._parentURI = options.associatedItem || 'root';\n\n    // Client Interface is whatever object that a given client hands back\n    // after the authorization step. We use it to make sending and recieving\n    // requests extremely simple.\n\n    // Note: This does assume that the client has already been authenticated\n    // If not it could lead to potential errors. gapi should be set to the\n    // clientInterface\n    this.clientInterface = options.clientInterface;\n    // To avoid confusion, we should remove the above and any references to\n    // it. It makes the code way easier to read\n    this.gapi = this.clientInterface;\n\n    // The fragmentURI is the id of the XooML file. It may or may not exist\n    this._fragmentURI = options.fragmentURI ? options.fragmentURI : null;\n\n    // This comes from the usage of teh updated API, we have to jump through\n    // several hoops to geth the authentication token that we're looking for\n    var authResponse = this.clientInterface.auth2.getAuthInstance()\n      .currentUser.get()\n      .getAuthResponse();\n\n    // This is the authorized header, so we can easily make requests via ajax.\n    // If we get request errors, make sure that this header is correct, and\n    // doesn't constantly change\n    this._AUTH_HEADER = { Authorization: 'Bearer ' + authResponse.access_token };\n    this._DRIVE_FILE_API = 'https://www.googleapis.com/drive/v2/files/';\n\n    return callback(false, self);\n  }\n\n\n  /**\n   * Creates a request for a given fileID and executes the request\n   * @method _readFile\n   * @param  {Function} callback Function with the XML string response\n   * @param {String} id ID of the file you want to get download\n   */\n  XooMLDriver.prototype._readFile = function(callback) {\n    var self = this;\n\n    $.ajax({\n      url:  self._DRIVE_FILE_API + self._fragmentURI,\n      // Required to actually initiate a download\n      data: 'alt=media',\n      // If this isn't specified, we get an XMLDocument back. We want a\n      // string for maximum flexibility.\n      dataType: 'text',\n      // Note, if the authorization header is messed up, it will give us\n      // an error that tells us we need to sign in and have reached our\n      // limit.\n      headers: self._AUTH_HEADER\n    }).then(function(xml_text) {\n      callback(false, xml_text);\n    });\n  };\n\n  // This is a helper function that searches for the xml file in a folder when\n  // necessary\n  XooMLDriver.prototype._searchXooML = function(callback, folderID) {\n    var self = this;\n\n    // This query means return the file with the title XooML2.xml in the\n    // root directory.\n    // Details on the gapi query syntax: https://developers.google.com/drive/web/search-parameters\n    var query = 'title = \\'' + XooMLConfig.xooMLFragmentFileName + '\\' and \\'' + folderID + '\\' in parents';\n    var request = this.clientInterface.client.drive.files.list({\n      'maxResults': 10,\n      'q': query\n    });\n    request.execute(function(resp) {\n      // Now that we've made the request, we can extract the fileID and\n      // read the file contents\n      var xoomlItem = resp.items[0];\n\n      // This means that there currently is no XooML file\n      if (!xoomlItem) {\n        // This error should be standardized somewhere and made into a number\n        // that way all drivers can  share it\n        return callback('XooML Not Found'); \n      }\n\n      self._fragmentURI = xoomlItem.id;\n      self._readFile(callback);\n    });\n  }\n\n  /**\n   * Reads and returns a XooML fragment\n   * @method getXooMLFragment\n   * @param {Function} callback(content) Function to be called when self function is finished with it's operation. content is the content of the XooML fragment.\n   *\n   * @protected\n   */\n  XooMLDriver.prototype.getXooMLFragment = function (callback) {\n    // If we don't have the fragmentURI, we need this for searching\n    if (!this._fragmentURI) {\n      return this._searchXooML(callback, this._parentURI);\n    } else {\n      // General case, where we don't need to do a query\n      this._readFile(callback, this._fragmentURI);\n    }\n  };\n\n  /**\n   * Writes a XooML fragment\n   * @method setXooMLFragment\n   * @param {String} xmlString the content of the XooML fragment\n   * @param {Function} callback(content) Function to be called when self function is finished with it's operation. content is the content of the XooML fragment.\n   *\n   * @protected\n   */\n  XooMLDriver.prototype.setXooMLFragment = function (xmlString, callback) {\n    var self = this;\n    var mimeType = 'text/xml';\n\n    // Used when updating an already existing XooML.xml\n    function updateFile(callback) {\n      var request = this.gapi.client.request({\n        path: '/upload/drive/v2/files/' + self._fragmentURI,\n        method: 'PUT',\n        params: {'uploadType': 'media'},\n        body: xmlString\n      });\n\n      request.execute(function() {\n        callback(false);\n      }, function(error) {\n        callback(error);\n      });\n    }\n\n    // Used when writing a new XooML file\n    function insertFile(fileData, callback) {\n      var boundary = '-------314159265358979323846';\n      var delimiter = \"\\r\\n--\" + boundary + \"\\r\\n\";\n      var close_delim = \"\\r\\n--\" + boundary + \"--\";\n\n      var reader = new FileReader();\n      reader.readAsBinaryString(fileData);\n      reader.onload = function() {\n        var contentType = fileData.type || 'application/octet-stream';\n        var metadata = {\n          'title': XooMLConfig.xooMLFragmentFileName,\n          'mimeType': contentType,\n          'parents': [{\n            \"kind\": \"drive#parentReference\",\n            \"id\": self._parentURI\n          }]\n        };\n\n        var base64Data = btoa(reader.result);\n        var multipartRequestBody =\n            delimiter +\n            'Content-Type: application/json\\r\\n\\r\\n' +\n            JSON.stringify(metadata) +\n            delimiter +\n            'Content-Type: ' + contentType + '\\r\\n' +\n            'Content-Transfer-Encoding: base64\\r\\n' +\n            '\\r\\n' +\n            base64Data +\n            close_delim;\n\n        var request = self.gapi.client.request({\n            'path': '/upload/drive/v2/files',\n            'method': 'POST',\n            'params': {'uploadType': 'multipart'},\n            'headers': {\n              'Content-Type': 'multipart/mixed; boundary=\"' + boundary + '\"'\n            },\n            'body': multipartRequestBody});\n        request.execute(function(response) {\n          // The response is the newly created file, and we set the fragment ID to that\n          // so that future requests don't require additional searches\n          self._fragmentURI = response.id\n          callback(false);\n        }, function(response) {\n          callback('Could not write out XooML Fragment', response);\n        });\n      };\n    }\n\n    var blob = new Blob([xmlString], {type: mimeType, fileName: XooMLConfig.xooMLFragmentFileName});\n\n\n    // Update or create the file depending on the circumstances\n    if (self._fragmentURI) {\n      updateFile(callback);\n    } else {\n      insertFile(blob, callback);\n    }\n  };\n\n  /**\n   * Check if the XooML fragment exists\n   * @method checkExists\n   * @param {Function} callback Function to be called when\n   * self function is finished with it's operation.\n   *  @param {String} callback.error Dropbox error if there is one\n   *  @param {Boolean} callback.result True if the fragment exists and\n   *  false otherwis\n   *\n   * @protected\n   */\n  XooMLDriver.prototype.checkExists = function (callback) {\n    var self = this;\n\n    // If we have the URI, first make a direct request for that\n    if (this._fragmentURI) {\n      // A simple get request will suffice\n      $.get({\n        url: this._DRIVE_FILE_API + self._fragmentURI,\n        headers: this._AUTH_HEADER\n      }).then(function() {\n        callback(false);\n      }).fail(function() {\n        callback('XooML file: ' + self._fragmentURI + ' not found');\n      });\n    // In this case, we do a search for XooML in the folder\n    } else {\n      var query = 'title = \\'' + XooMLConfig.xooMLFragmentFileName + '\\' and \\'' + self._parentURI + '\\' in parents';\n      var request = this.clientInterface.client.drive.files.list({\n        'maxResults': 1,\n        'q': query\n      });\n      request.execute(function(resp) {\n        // Simply check if there were any results\n        if (resp.items[0]) {\n          callback(false);\n        } else {\n          callback('XooML file not found in directory: ' + self._parentURI);\n        }\n      });\n    }\n  };\n\nmodule.exports = XooMLDriver;\n},{\"./XooMLConfig\":5}]},{},[3])\n\n","/**\n * Constructs a FragmentWrapper for a XooML fragment. In the following cases.\n *\n * 1. XooMLFragment String is passed in and is used as the XooMLFragment\n * 2. XooMLFragment Element is passed in and is used as the XooMLFragment.\n * 2. Associations, XooMLDriver, ItemDriver, SyncDriver,\n * groupingItemURI are given and used to create a new XooMLFragment with\n * the given data.\n *\n * The FragmentWrapper is merely a representation of a XooML fragment,\n * and is used by an itemMirror that actually handles the details of\n * creating deleting and modifying associations.\n *\n * For ItemMirror core developers only. Enable protected to see.\n *\n * @class FragmentEditor\n * @constructor\n *\n * @param {Object} options Data to construct a new FragmentWrapper with\n *  @param {String} options.text Unparsed XML directly from a storage\n *  platform.\n *  @param {Element} options.element XML Element representing a XooML\n *                   fragment. Required for case 1.\n *  @param {AssociationEditor[]} options.associations List of associations for\n *          the newly constructed XooMLFragment in case 2. <br/>__optional__\n *  @param {Object} options.commonData Common data for the\n *  fragment. Look at the constructor for more details. Required for case 2\n *  @param {String} options.groupingItemURI The URI for the grouping\n *  item of the fragment. Required for case 2.\n *\n * @protected\n **/\n\n\n'use strict'\n\nvar XooMLExceptions = require('./XooMLExceptions');\nvar XooMLUtil = require('./XooMLUtil');\nvar AssociationEditor = require('./AssociationEditor');\n\n  var _ELEMENT_NAME = \"fragment\",\n      _ASSOCIATION_ELEMENT_NAME = \"association\",\n      _ASSOCIATION_ID_ATTR = \"ID\",\n      _NAMESPACE_ELEMENT_NAME = \"fragmentNamespaceElement\",\n      _SCHEMA_VERSION_ATTR = \"schemaVersion\",\n      _SCHEMA_LOCATION_ATTR = \"schemaLocation\",\n      _ITEM_DESCRIBED_ATTR = \"itemDescribed\",\n      _DISPLAY_NAME_ATTR = \"displayName\",\n      _ITEM_DRIVER_ATTR = \"itemDriver\",\n      _SYNC_DRIVER_ATTR = \"syncDriver\",\n      _XOOML_DRIVER_ATTR = \"xooMLDriver\",\n      _GUID_ATTR = \"GUIDGeneratedOnLastWrite\",\n      _ITEM_MIRROR_NS = \"http://kftf.ischool.washington.edu/xmlns/xooml\";\n\n  function FragmentEditor(options) {\n    var self = this;\n\n    if (options.text) {\n      _fromString(options.text, self);\n    } else if (options.element) {\n      _fromElement(options.element, self);\n    } else if (options.commonData) {\n      _fromOptions(options.commonData, options.associations, self);\n    } else {\n      throw new Error(XooMLExceptions.missingParameter);\n    }\n  }\n\n  /**\n   * Updates the GUID of the Fragment\n   *\n   * @method updateID\n   * @return {String} The new GUID of the fragment\n   * @private\n   * @protected\n   */\n  FragmentEditor.prototype.updateID = function() {\n    var guid = XooMLUtil.generateGUID();\n    this.commonData.GUIDGeneratedOnLastWrite = guid;\n    return guid;\n  };\n\n  /**\n   * Converts a FragmentEditor object into an XML element, which can\n   * then be serialized and saved as a string, or further manipulated\n   * with DOM methods\n   * @method toElement\n   * @return {Element} The XooML fragment as an XML element\n   * @protected\n   */\n  FragmentEditor.prototype.toElement = function() {\n    var self = this,\n        fragmentElem = document.createElementNS(_ITEM_MIRROR_NS, _ELEMENT_NAME);\n\n    // common data\n    Object.keys(self.commonData).forEach( function(attrName) {\n      var attrValue = self.commonData[attrName];\n      if (attrValue) { // Don't set null attributes\n        fragmentElem.setAttribute(attrName, attrValue);\n      }\n    });\n\n    // namespace data\n    Object.keys(self.namespace).forEach( function(uri) {\n      var nsElem = document.createElementNS(uri, _NAMESPACE_ELEMENT_NAME);\n      // Attributes\n      Object.keys(self.namespace[uri].attributes).forEach( function(attrName) {\n        nsElem.setAttributeNS(uri, attrName, self.namespace[ uri ].attributes[ attrName ]);\n      });\n\n      nsElem.textContent = self.namespace[ uri ].data;\n\n      fragmentElem.appendChild(nsElem);\n    });\n\n    // associations\n    Object.keys(self.associations).forEach( function(id) {\n      fragmentElem.appendChild( self.associations[id].toElement() );\n    });\n\n    return fragmentElem;\n  };\n\n  /**\n   * Returns the XML of a fragment as a string, _not_ the string\n   * version of the object. This is used for persisting the fragment\n   * across multiple platforms\n   * @method toString\n   * @return {String} Fragment XML\n   */\n  FragmentEditor.prototype.toString = function() {\n    var serializer = new XMLSerializer();\n    return serializer.serializeToString( this.toElement() );\n  };\n\n  /**\n   * Constructs a fragmentEditor based on data passed into the\n   * parameters\n   *\n   * @method _fromOptions\n   *\n   * @param {Object} commonData An object containing common data for the association\n   *  @param {String} commonData.schemaVersion The version of the schema <br/> __required__\n   *  @param {String} commonData.schemaLocation The location of the schema\n   *  @param {String} commonData.itemDescribed URI pointing to item for which the\n   *  XooML fragment is metadata.\n   *  @param {String} commonData.displayName Display name of the fragment\n   *  @param {String} commonData.itemDriver The URI of the item driver for the fragment\n   *  @param {String} commonData.syncDriver The URI of the sync driver for the fragment\n   *  @param {String} commonData.xooMLDriver The URI of the XooML driver for the fragment\n   *  @param {String} commonData.GUIDGeneratedOnLastWrite The GUID generated the last time the fragment was written\n   * @param {AssociationEditor[]} associations An array of associations that the fragment has\n   * @param {String} namespace The namespace URI that an app will use for it's own private data\n   * @param {FragmentEditor} self\n   *\n   * @private\n   */\n  function _fromOptions(commonData, associations, self) {\n    if (!commonData) {\n      throw XooMLExceptions.nullArgument;\n    }\n\n    // Properties from the common data\n    /**\n     * Common Data of the association that is accessible to all applications\n     * @property commonData\n     * @type Object\n     */\n    self.commonData = {\n      /**\n       * Text that describes the fragment\n       * @property commonData.displayName\n       * @type String\n       */\n      displayName: commonData.displayName || null,\n\n      /**\n       * The schema location for the fragment\n       * @property commonData.schemaLocation\n       * @type String\n       */\n      schemaLocation: commonData.schemaLocation || null,\n\n      /**\n       * The schema version for the fragment\n       * @property commonData.schemaVersion\n       * @type String\n       */\n      schemaVersion: commonData.schemaVersion || null,\n\n      /**\n       * The item driver URI for the fragment\n       * @property commonData.itemDriver\n       * @type String\n       */\n      itemDriver: commonData.itemDriver || null,\n\n      /**\n       * The item described for the fragment. This is a URI that\n       * points to grouping item from wich the itemMirror was created\n       * @property commonData.\n       * @type String\n       */\n      itemDescribed: commonData.itemDescribed || null,\n\n      /**\n       * The sync driver URI for the fragment\n       * @property commonData.syncDriver\n       * @type String\n       */\n      syncDriver: commonData.syncDriver || null,\n\n      /**\n       * The XooML driver URI for the fragment\n       * @property commonData.xooMLDriver\n       * @type String\n       */\n      xooMLDriver: commonData.xooMLDriver || null,\n\n      /**\n       * The unique GUID for the fragment that is updated after every\n       * write\n       * @property commonData.GUIDGeneratedOnLastWrite\n       * @type String\n       */\n      GUIDGeneratedOnLastWrite: XooMLUtil.generateGUID()\n    };\n\n    /**\n     * The associations of the fragment. Each association is accessed\n     * by referencing it's ID, which then gives the corresponding\n     * AssociationEditor object for manipulating that association.\n     * @property associations\n     * @type Object\n     */\n    // Takes the association array and turns it into an associative\n    // array accessed by the GUID of an association\n    self.associations = {};\n    associations.forEach( function(assoc) {\n      var guid = assoc.commonData.ID;\n      self.associations[guid] = assoc;\n    });\n\n    /**\n     * The namespace data of the fragment. Holds both the URI as well\n     * as the namespace specific data for the fragment\n     * @property namespace\n     * @type Object\n     */\n    self.namespace = {};\n      /**\n       * The namespace URI for the fragment. Used to set namespace data\n       * for both the fragment and it's associations\n       * @property namespace.uri\n       * @type String\n       */\n\n      /**\n       * The attributes of the namespace. This is app specific data\n       * that is set for the fragment. Each key pair in the object\n       * represents an attribute name and it's corresponding value\n       * @property namespace.attributes\n       * @type Object\n       */\n  }\n\n  /**\n   * Takes a fragment in the form of a string and then parses that\n   * into XML. From there it converts that element into an object\n   * using the _fromElement method\n   * \n   * @method _fromString\n   *\n   * @param {String} text The text representing the fragment. Should\n   * be obtained directly from a storage platform like dropbox or a\n   * local filesystem\n   * @param {String} namespace The URI of the namespace that will\n   * initially be used for the fragment when handling any namespace\n   * data\n   * @param {FragmentEditor} self\n   */\n  function _fromString(text, namespace, self) {\n    var parser = new DOMParser();\n    var doc = parser.parseFromString(text, \"application/xml\");\n    _fromElement(doc.children[0], namespace, self);\n  }\n\n  /**\n   * Takes a fragment element in XML and then converts that into a\n   * FragmentEditor object. Intended to be one of the ways the object\n   * is constructed\n   *\n   * @method _fromElement\n   *\n   * @param {Element} element The XML element that represents an association.\n   * @param {FragmentEditor} self\n   * @private\n   */\n  function _fromElement(element, self) {\n    var dataElems, i, associationElems, guid, elem, uri;\n    // Sets all common data attributes\n    self.commonData = {\n      fragmentNamespaceElement: element.getAttribute(_NAMESPACE_ELEMENT_NAME),\n      schemaVersion: element.getAttribute(_SCHEMA_VERSION_ATTR),\n      schemaLocation: element.getAttribute(_SCHEMA_LOCATION_ATTR),\n      itemDescribed: element.getAttribute(_ITEM_DESCRIBED_ATTR),\n      displayName: element.getAttribute(_DISPLAY_NAME_ATTR),\n      itemDriver: element.getAttribute(_ITEM_DRIVER_ATTR),\n      syncDriver: element.getAttribute(_SYNC_DRIVER_ATTR),\n      xooMLDriver: element.getAttribute(_XOOML_DRIVER_ATTR),\n      GUIDGeneratedOnLastWrite: element.getAttribute(_GUID_ATTR)\n    };\n\n    /**\n     * The namespace object is an associated array with each key being\n     * a namespace URI. These can thene be used to modify fragment\n     * namespace attributes and data\n     * @property namespace\n     * @type Object\n     */\n    self.namespace = {};\n\n    dataElems = element.getElementsByTagName(_NAMESPACE_ELEMENT_NAME);\n    for (i = 0; i < dataElems.length; i += 1) {\n      elem = dataElems[i];\n      uri = elem.namespaceURI;\n\n      /**\n       * The information for a given namespace. Includes both the\n       * data, and the attributes. Namespaces URIs must be unique or\n       * they will overwrite data from another namespace\n       * @property namespace.URI\n       * @type Object\n       */\n      self.namespace[ uri ] = {};\n      self.namespace[ uri ].attributes = {};\n\n      for (i = 0; i < elem.attributes.length; i += 1) {\n        // We have to filter out the special namespace attribute We\n        // let the namespace methods handle the namespace, and we\n        // don't deal with it\n        if (elem.attributes[i].name !== \"xmlns\") {\n          /**\n           * The attributes of the current namespace, with each attribute\n           * having a corresponding value.\n           * @property namespace.URI.attributes\n           * @type Object\n           */\n          self.namespace[ uri ].attributes[ elem.attributes[i].localName ] =\n            elem.getAttributeNS(uri, elem.attributes[i].localName);\n        }\n      }\n\n    /**\n     * This is the namespace data stored within the namespace\n     * element. Anything can be put here, and it will be stored as a\n     * string. ItemMirror will not do anything with the data here and\n     * doesn't interact with it at all. It is the responsibility of\n     * other applications to properly store information here.\n     * @property namespace.URI.data\n     * @type String\n     */\n      self.namespace[ uri ].data = elem.textContent;\n    }\n\n    // associations\n    self.associations = {};\n    associationElems = element.getElementsByTagName(_ASSOCIATION_ELEMENT_NAME);\n    for (i = 0; i < associationElems.length; i += 1) {\n      guid = associationElems[i].getAttribute(_ASSOCIATION_ID_ATTR);\n      self.associations[guid] = new AssociationEditor({\n        element: associationElems[i]\n      });\n    }\n  }\n\nmodule.exports = FragmentEditor;","/**\n * ItemMirror represents an Item according to the XooML2 specification.\n *\n * It can be instantiated using one of the following two cases based on the\n * given arguments.\n *\n * 1. XooMLFragment already exists. Given xooMLFragmentURI and xooMLDriver.\n * 2. The XooMLFragment is created from an existing groupingItemURI (e.g., a dropbox folder).\n * Given a groupingItemURI, itemDriver, and a xooMLDriver a new itemMirror will be constructed for given groupingItemURI.\n *\n * Throws NullArgumentException when options is null.\n *\n * Throws MissingParameterException when options is not null and a required\n * argument is missing.\n *\n * @class ItemMirror\n * @constructor\n *\n * @param {Object} options Data to construct a new ItemMirror with\n *\n *  @param {String} options.groupingItemURI URI to the grouping item. Required\n *                  for all cases.\n *\n *  @param {String} options.itemDriver Data for the ItemDriver to\n *                  construct ItemMirror with. Required for cases 2 & 3\n *                  Can contain any amount of optional key/value pairs for\n *                  the various Driver implementations.\n *   @param {String} options.itemDriver.driverURI URI of the driver.\n *\n *  @param {String} options.xooMLDriver Data for the XooMLDriver to\n *                  construct ItemMirror with. Required for all cases.\n *                  Can contain any amount of optional key/value pairs for\n *                  the various Driver implementations.\n *   @param {String} options.xooMLDriver.driverURI URI of the driver.\n *\n *  @param {String} options.syncDriver Data for the SyncDriver to\n *                  construct ItemMirror with. Required Case 2 & 3. Can\n *                  contain any amount of optional key/value pairs for\n *                  the various Driver implementations.\n *   @param {String} options.syncDriver.driverURI URI of the driver.\n *\n *  @param {Boolean} options.readIfExists True if ItemMirror\n *                   should create an ItemMirror if it does not exist,\n *                   else false. Required for Case 2 & 3.\n *\n *  @param {ItemMirror} options.creator If being created from another\n *  itemMirror, specifies that itemMirror which it comes from.\n *\n * @param {Function} callback Function to execute once finished.\n *  @param {Object}   callback.error Null if no error has occurred\n *                    in executing this function, else an contains\n *                    an object with the error that occurred.\n *  @param {ItemMirror} callback.itemMirror Newly constructed ItemMirror\n */\n\n'use strict'\n\n// Note: This is nothing more than the minified version of the older library.\n// It's used because the stability of the library is better, even though it's\n// more poorly implemented in the first place\n\n\n\nvar XooMLExceptions = require('./XooMLExceptions');\nvar XooMLUtil = require('./XooMLUtil');\nvar XooMLDriver = require('./google-xooml-driver');\nvar ItemDriver = require('./google-item-driver');\nvar SyncDriver = require('./SyncDriver');\nvar FragmentEditor = require('./FragmentEditor');\nvar AssociationEditor = require('./AssociationEditor');\n\n\nfunction ItemMirror(options, callback) {\n    XooMLUtil.checkCallback(callback);\n    if (!options) {\n      return callback(XooMLExceptions.nullArgument);\n    }\n\n   var self = this, xooMLFragmentURI, displayName;\n\n  if (typeof options === 'string') {\n    specialConstruction();\n  } else {\n    regularConstruction();\n  }\n\n    function specialConstruction() {\n      // Special case where we return a limited functionality itemMirror object that\n      // represents different informational stores\n      // A special XooML fragment, representing information stores\n      var xml = ['<fragment xmlns=\"http://kftf.ischool.washington.edu/xmlns/xooml\" itemDescribed=\"/\" displayName=\"Dropbox\" itemDriver=\"dropboxItemDriver\" syncDriver=\"itemMirrorSyncUtility\" xooMLDriver=\"dropboxXooMLDriver\" GUIDGeneratedOnLastWrite=\"771c1026-b8d8-4457-9594-01531b9f7ca0\">',\n      '<association ID=\"a02f53d2-18af-4faf-ace9-5305cb808ec5\" displayText=\"Dropbox\" associatedItem=\"Dropbox\" isGrouping=\"true\">',\n      '</association>',\n      '<association ID=\"27955628-7850-4c71-be12-6caed1c9463c\" displayText=\"Google Drive\" associatedItem=\"gapi\" isGrouping=\"true\">',\n      '</association>',\n      '</fragment>'].join('\\n');\n\n      self._fragment = new FragmentEditor({text: xml});\n      return callback(false, self);\n    }\n\n    function regularConstruction() {\n     self._xooMLDriverClient = options.xooMLDriver.clientInterface;\n     self._itemDriverClient = options.xooMLDriver.clientInterface;\n\n      // private variables\n      self._xooMLDriver = null;\n      self._itemDriver = null;\n      self._syncDriver = null;\n      self._creator = options.creator || null;\n      self._groupingItemURI = options.groupingItemURI;\n      self._newItemMirrorOptions = options;\n\n      // displayName for the fragment\n      // It may make more sense to set this later once we have the drivers loaded\n      // displayName = this._xooMLDriver.getDisplayName();\n      displayName = 'TBD';\n\n      self.fragmentURI = options.fragmentURI || null;\n      options.xooMLDriver.fragmentURI = xooMLFragmentURI;\n\n      // First load the XooML Driver\n      new XooMLDriver(options.xooMLDriver, loadXooMLDriver);\n    }\n\n\n\n    function loadXooMLDriver(error, driver) {\n      if (error) return callback(error);\n\n      self._xooMLDriver = driver; // actually sets the XooMLDriver\n\n      self._xooMLDriver.getXooMLFragment(processXooML);\n    }\n\n    function processXooML(error, fragmentString) {\n      // Case 2: Since the fragment doesn't exist, we need\n      // to construct it by using the itemDriver\n      if (error === 'XooML Not Found') {\n        new ItemDriver(options.itemDriver, createFromItemDriver);\n      } else if (error) {\n        return callback(error);\n      }\n\n      // Case 1: It already exists, and so all of the information\n      // can be constructed from the saved fragment\n      else {\n        createFromXML(fragmentString);\n      }\n    }\n\n    function createFromXML(fragmentString) {\n      self._fragment = new FragmentEditor({text: fragmentString});\n\n      new ItemDriver(options.itemDriver, function(error, driver) {\n        if (error) return callback(error);\n        self._itemDriver = driver;\n\n        self._syncDriver = new SyncDriver(self);\n\n        // Do a refresh in case something has been added or deleted in\n        // the directory since the last write\n        self.refresh(function() {\n          return callback(false, self);\n        });\n      });\n    }\n\n    function createFromItemDriver(error, driver) {\n      self._itemDriver = driver;\n\n      self._itemDriver.listItems(self._groupingItemURI, buildFragment);\n    }\n\n    function buildFragment(error, associations){\n      if (error) return callback(error);\n\n      self._fragment = new FragmentEditor({\n        commonData: {\n          itemDescribed: self._groupingItemURI,\n          displayName: displayName,\n          itemDriver: \"dropboxItemDriver\",\n          xooMLDriver: \"dropboxXooMLDriver\",\n          syncDriver: \"itemMirrorSyncUtility\"\n        },\n        associations: associations\n      });\n\n      self._syncDriver = new SyncDriver(self);\n\n      // Because the fragment is being built from scratch, it's safe\n      // to save it directly via the driver.\n      self._xooMLDriver.setXooMLFragment(self._fragment.toString(), function(error) {\n        if (error) {\n          throw new Error(error);\n        }\n      });\n\n      return callback(false, self);\n    }\n  }\n\n  /**\n   * @method getDisplayName\n   * @return {String} The display name of the fragment.\n   */\n  ItemMirror.prototype.getDisplayName = function() {\n    return this._fragment.commonData.displayName;\n  };\n\n  /**\n   * @method setDisplayName\n   * @param {String} name The display text to set for the fragment\n   */\n  ItemMirror.prototype.setDisplayName = function(name) {\n    this._fragment.commonData.displayName = name;\n  };\n\n  /**\n   *\n   * @method getSchemaVersion\n   * @return {String} XooML schema version.\n   */\n  ItemMirror.prototype.getSchemaVersion = function() {\n    return this._fragment.commonData.schemaVersion;\n  };\n\n  /**\n   *\n   * @method getSchemaLocation\n   * @return {String} XooML schema location.\n   */\n  ItemMirror.prototype.getSchemaLocation = function() {\n    return this._fragment.commonData.schemaLocation;\n  };\n\n  /**\n   * Returns URI pointing to item described by the metadata of a fragment. A URI\n   * might point to just about anything that can be interpreted as a grouping\n   * item. For example: a conventional file system folder or a tag as\n   * supported by any of several applications.\n   *\n   * @method getURIforItemDescribed\n   * @return {String} A URI pointing to item described by the metadata\n   * of a fragment if it exists, else returns null.\n   *\n   */\n  ItemMirror.prototype.getURIforItemDescribed = function() {\n    return this._fragment.commonData.itemDescribed;\n  };\n\n  ItemMirror.prototype.getPublicURL = function(GUID) {\n    return this._fragment.associations[GUID].commonData.publicURL;\n  }\n\n  /**\n   * Throws NullArgumentException if GUID is null. <br/>\n   * Throws InvalidTypeException if GUID is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   *\n   * @method getAssociationDisplayText\n   * @return {String} The display text for the association with the given GUID.\n   *\n   * @param {String} GUID GUID representing the desired association.\n   */\n    ItemMirror.prototype.getAssociationDisplayText = function(GUID) {\n    return this._fragment.associations[GUID].commonData.displayText;\n  };\n\n  /**\n   * Sets the display text for the association with the given GUID.\n   *\n   * Throws NullArgumentException if GUID or displayName is null. <br/>\n   * Throws InvalidTypeException if GUID or displayName is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method setAssociationDisplayText\n   *\n   * @param {String}   GUID        GUID of the association to set.\n   * @param {String}   displayText Display text to be set.\n   */\n    ItemMirror.prototype.setAssociationDisplayText = function(GUID, displayText) {\n    this._fragment.associations[GUID].commonData.displayText = displayText;\n  };\n\n  /**\n   * Throws NullArgumentException if GUID is null. <br/>\n   * Throws InvalidTypeException if GUID is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method getAssociationLocalItem\n   * @return {String} The local item for the association with the given GUID.\n   *\n   * @param {String} GUID GUID of the association to get.\n   */\n    ItemMirror.prototype.getAssociationLocalItem = function(GUID) {\n    return this._fragment.associations[GUID].commonData.localItem;\n  };\n\n  /**\n   * Throws NullArgumentException if GUID is null. <br/>\n   * Throws InvalidTypeException if GUID is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method getAssociationAssociatedItem\n   * @return {String} The associated item for the association with the given GUID.\n   * @param {String} GUID GUID of the association to get.\n   */\n    ItemMirror.prototype.getAssociationAssociatedItem = function(GUID) {\n    return this._fragment.associations[GUID].commonData.associatedItem;\n  };\n\n  /**\n   * @method getFragmentNamespaceAttribute\n   * @return {String} Returns the value of the given attributeName for the\n   * fragmentNamespaceData with the given namespaceURI.\n   * @param {String} attributeName Name of the attribute to be returned.\n   * @param {String} uri Namespace URI\n   */\n  ItemMirror.prototype.getFragmentNamespaceAttribute = function(attributeName, uri) {\n    var ns = this._fragment.namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    return this._fragment.namespace[uri].attributes[attributeName];\n  };\n\n  /**\n   * Sets the value of the given attributeName with the given attributeValue\n   * for the fragmentNamespaceData with the given namespaceURI.\n   *\n   * Throws NullArgumentException if attributeName, attributeValue, or\n   * namespaceURI is null. <br/>\n   * Throws InvalidTypeException if attributeName, attributeValue, or\n   * namespaceURI is not a String. <br/>\n   *\n   * @method setFragmentNamespaceAttribute\n   * @param {String} attributeName  Name of the attribute to be set.\n   * @param {String} attributeValue Value of the attribute to be set.\n   * @param {String} uri Namespace URI\n   */\n  ItemMirror.prototype.setFragmentNamespaceAttribute = function(attributeName, attributeValue, uri) {\n    var ns = this._fragment.namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    this._fragment.namespace[uri].attributes[attributeName] = attributeValue;\n  };\n\n  /**\n   * Adds the given attributeName to the fragment's current namespace\n   *\n   * Throws an InvalidStateException when the attribute already exists\n   *\n   * @method addFragmentNamespaceAttribute\n   *\n   * @param {String} attributeName Name of the attribute.\n   * @param {String} uri Namespace URI\n   */\n  // TODO: Possibly remove? Why not just get and set\n  ItemMirror.prototype.addFragmentNamespaceAttribute = function(attributeName, uri) {\n    var ns = this._fragment.namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    if (this._fragment.namespace[uri].attributes[attributeName]) {\n      throw XooMLExceptions.invalidState;\n    }\n    this.setFragmentNamespaceAttribute(attributeName, uri);\n  };\n\n  /**\n   * Removes the fragment namespace attribute with the given namespaceURI.\n   *\n   * Throws NullArgumentException if attributeName, or namespaceURI is\n   * null. <br/>\n   * Throws InvalidTypeException if attributeName, or namespaceURI is not\n   * a String. <br/>\n   * Throws an InvalidStateException when the given attributeName is not an\n   * attribute. <br/>\n   *\n   * @method removeFragmentNamespaceAttribute\n   * @param {String} attributeName Name of the attribute.\n   * @param {String} uri  Namespace URI\n   *\n   */\n  ItemMirror.prototype.removeFragmentNamespaceAttribute = function(attributeName, uri) {\n    delete this._fragment.namespace[uri].attributes[attributeName];\n  };\n\n  /**\n   * Checks if the fragment has the given namespaceURI.\n   *\n   * Currently cannot find a way to list the namespaces (no DOM\n   * standard method for doing so). So this fuction will ALWAYS RETURN\n   * FALSE for now.\n   *\n   * @method hasFragmentNamespace\n   * @return {Boolean} True if the fragment has the given\n   * namespaceURI, otherwise false.\n   *\n   * @param {String} uri URI of the namespace for the association.\n   *\n   */\n  ItemMirror.prototype.hasFragmentNamespace = function (uri) {\n    var namespace = this._fragment.namespace[uri];\n    if (namespace) { return true; }\n    else { return false; }\n  };\n\n  /**\n   * @method listFragmentNamespaceAttributes\n   * @return {String[]} An array of the attributes within the\n   * fragmentNamespaceData with the given namespaceURI.\n   * @param {String} uri Namespace URI\n   *\n  */\n  ItemMirror.prototype.listFragmentNamespaceAttributes = function(uri) {\n    return Object.keys(this._fragment.namespace[uri].attributes);\n  };\n\n  /**\n   * @method getFragmentNamespaceData\n   * @return {String} The fragment namespace data with the given namespace URI.\n   * @param {String} uri Namespace URI\n   */\n  ItemMirror.prototype.getFragmentNamespaceData = function(uri) {\n    return this._fragment.namespace[uri].data;\n  };\n\n  /**\n   * Sets the fragment namespace data with the given namespaceURI.\n   *\n   * @method setFragmentNamespaceData\n   *\n   * @param {String} data Fragment namespace data to be set.\n   * @param {String} uri Namespace URI\n   */\n  ItemMirror.prototype.setFragmentNamespaceData = function (data, uri) {\n    var ns = this._fragment.namespace;\n    ns[uri] = ns[uri] || {};\n\n    this._fragment.namespace[uri].data = data;\n  };\n\n  /**\n   * Creates an ItemMirror from the associated grouping item represented by\n   * the given GUID.\n   *\n   * Throws NullArgumentException if GUID or callback is null. <br/>\n   * Throws InvalidTypeException if GUID is not a string, and callback is\n   * not a function. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method createItemMirrorForAssociatedGroupingItem\n   * @return {ItemMirror} Possibly return an itemMirror if the GUID is a grouping item\n   *\n   * @param {String} GUID GUID of the association to create the ItemMirror\n   *                 from.\n   *\n   */\n  ItemMirror.prototype.createItemMirrorForAssociatedGroupingItem = function (GUID, callback) {\n\n    // Handle Special cases for the unique stores:\n    var self = this,\n        isGrouping,\n        xooMLOptions,\n        itemOptions,\n        syncOptions,\n        uri;\n\n    var association = self.getAssociationAssociatedItem(GUID);\n\n    // Dropbox root construction\n    if (association === 'Dropbox') {\n        var dropboxXooMLUtility = {\n          fragmentURI: '/XooML2.xml',\n          driverURI: 'DropboxXooMLUtility',\n          dropboxClient: dropboxClient\n        };\n        var dropboxItemUtility = {\n          driverURI: 'DropboxItemUtility',\n          dropboxClient: dropboxClient\n        };\n        var mirrorSyncUtility = {\n          utilityURI: 'MirrorSyncUtility'\n        };\n        var options = {\n          groupingItemURI: '/',\n          xooMLDriver: dropboxXooMLUtility,\n          itemDriver: dropboxItemUtility,\n          syncDriver: mirrorSyncUtility\n        };\n        return new DropboxItemMirror(options, callback);\n    }\n\n    // Google root Construction\n    if (association === 'gapi') {\n      var driveXooMLUtility = {\n        clientInterface: gapi\n      };\n      var driveItemUtility = {\n        clientInterface: gapi\n      };\n      mirrorSyncUtility = {\n        utilityURI: 'MirrorSyncUtility'\n      };\n      options = {\n        groupingItemURI: \"root\",\n        xooMLDriver: driveXooMLUtility,\n        itemDriver: driveItemUtility,\n        syncDriver: mirrorSyncUtility\n      };\n      return new ItemMirror(options, callback);\n    }\n\n    itemOptions = {\n      driverURI: \"GoogleItemUtility\",\n      clientInterface: this._itemDriverClient,\n      // Note that this needs to be changed, we want to point to the grouping item's id\n      associatedItem: self.getAssociationAssociatedItem(GUID)\n    };\n    xooMLOptions = {\n      fragmentURI: uri,\n      driverURI: \"GoogleXooMLUtility\",\n      clientInterface: this._xooMLDriverClient,\n      associatedItem: self.getAssociationAssociatedItem(GUID)\n    };\n    syncOptions = {\n      utilityURI: \"SyncUtility\"\n    };\n\n    isGrouping = self.isAssociationAssociatedItemGrouping(GUID);\n    if (!isGrouping) {\n      // Need to standardize this error\n      return callback(\"Association not grouping, cannot continue\");\n    }\n\n    new ItemMirror(\n      {groupingItemURI: self.getAssociationAssociatedItem(GUID),\n       xooMLDriver: xooMLOptions,\n       itemDriver: itemOptions,\n       syncDriver: syncOptions,\n       creator: self\n      },\n      function (error, itemMirror) {\n        return callback(error, itemMirror);\n      }\n    );\n  };\n\n  /**\n   * Creates an association based on the given options and the following\n   * cases.\n   *\n   * Cases 1, 2, 7 implemented. All else are not implemented.\n   *\n   * 1. Simple text association declared phantom. <br/>\n   * 2. Link to existing non-grouping item, phantom. This can be a URL <br/>\n   * 3. Link to existing non-grouping item, real. <br/>\n   * 4. Link to existing grouping item, phantom. <br/>\n   * 5. Link to existing grouping item, real. <br/>\n   * 6. Create new local non-grouping item. <br/>\n   * 7. Create new local grouping item. <br/>\n   *\n   * Throws NullArgumentException when options, or callback is null. <br/>\n   * Throws InvalidTypeException when options is not an object and callback\n   * is not a function. <br/>\n   * Throws MissingParameterException when an argument is missing for an expected\n   * case. <br/>\n   *\n   * @method createAssociation\n   *\n   * @param {Object} options Data to create an new association for.\n   *\n   *  @param {String}  options.displayText Display text for the association.\n   *                   Required in all cases.\n   *\n   *  @param {String}  options.itemURI URI of the item. Required for case 2 & 3. Note: Please ensure \"http://\" prefix exists at the beginning of the string when referencing a Web URL and not an Item.\n   *\n   *  @param {Boolean} options.localItemRequested True if the local item is\n   *                   requested, else false. Required for cases 2 & 3.\n   *\n   *  @param {String}  options.groupingItemURI URI of the grouping item.\n   *                   Required for cases 4 & 5.\n   *\n   *  @param {String}  options.xooMLDriverURI URI of the XooML driver for the\n   *                   association. Required for cases 4 & 5.\n   *\n   *  @param {String}  options.localItem URI of the new local\n   *                   non-grouping/grouping item. Required for cases 6 & 7.\n   *\n   *  @param {String}  options.isGroupingItem True if the item is a grouping\n   *                   item, else false. Required for cases 6 & 7.\n   *\n   * @param {Function} callback Function to execute once finished.\n   *  @param {Object}   callback.error Null if no error has occurred\n   *                    in executing this function, else an contains\n   *                    an object with the error that occurred.\n   *  @param {String}   callback.GUID GUID of the association created.\n   */\n  ItemMirror.prototype.createAssociation = function (options, callback) {\n    var self = this,\n        association,\n        saveOutFragment;\n\n    saveOutFragment = function(association){\n      var guid = association.commonData.ID;\n      // adds the association to the fragment\n      self._fragment.associations[guid] = association;\n\n      // Save changes out the actual XooML Fragment\n      self.save( function(error){\n        return callback(error, guid);\n      });\n    };\n\n    if (!XooMLUtil.isFunction(callback)) {\n      throw XooMLExceptions.invalidType;\n    }\n    if (!XooMLUtil.isObject(options)) {\n      return callback(XooMLExceptions.invalidType);\n    }\n\n    // Case 7\n    if (options.displayText && options.localItem && options.isGroupingItem) {\n      association = new AssociationEditor({\n        commonData: {\n          displayText: options.displayText,\n          isGrouping: true,\n          localItem: options.localItem,\n          // Changed this part, and need to test folder creation to insure safety\n          associatedItem: options.associatedItem\n        }\n      });\n\n      // Now we use the itemDriver to actually create the folder\n      // NOTE: untested\n      self._itemDriver.createGroupingItem(options.displayText, function(error){\n        if (error) return callback(error);\n\n        return saveOutFragment(association);\n      });\n    }\n    // Synchronous cases\n    else {\n      // Case 2\n      if (options.displayText && options.itemURI) {\n        association = new AssociationEditor({\n          commonData: {\n            displayText: options.displayText,\n            associatedItem: options.itemURI,\n            isGrouping: false\n          }\n        });\n      }\n      // Case 1\n      else if (options.displayText) {\n        association = new AssociationEditor({\n          commonData: {\n            displayText: options.displayText,\n            isGrouping: false\n          }\n        });\n      }\n\n      return saveOutFragment(association);\n    }\n  };\n\n  /**\n   * @method isAssociationPhantom\n   * @param {String} guid\n   * @return {Boolean} True if the association of the given GUID is a\n   * phantom association. False otherwise.\n   */\n  ItemMirror.prototype.isAssociationPhantom = function(guid) {\n    var data = this._fragment.associations[guid].commonData;\n    return !(data.isGrouping || data.localItem);\n  };\n\n  /**\n   * Duplicates (copies) an association to another ItemMirror Object (representing a grouping item)\n   *\n   *\n   * Throws NullArgumentException if GUID is null. <br/>\n   * Throws InvalidTypeException if GUID is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method copyAssociation\n   *\n   * @param {String} GUID GUID of the association you wish to copy/duplicate\n   * @param {ItemMirror} ItemMirror ItemMirror representing the grouping item you want to move the GUID object to\n   *\n   * @param {Function} callback Function to execute once finished.\n   * @param {Object} callback.error Null if no error Null if no error has occurred\n   *                 in executing this function, else it contains\n   *                 an object with the error that occurred.\n   */\n   ItemMirror.prototype.copyAssociation = function () {\n    throw new Error('Method not implemented');\n   };\n  /**\n   * Moves an association to another ItemMirror Object (representing a grouping item)\n   *\n   *\n   * Throws NullArgumentException if GUID is null. <br/>\n   * Throws InvalidTypeException if GUID is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method moveAssociation\n   *\n   * @param {String} GUID GUID of the item you want to paste or move\n   * @param {ItemMirror} ItemMirror ItemMirror representing the grouping item you want to move the GUID object to\n   *\n   * @param {Function} callback Function to execute once finished.\n   * @param {Object} callback.error Null if no error Null if no error has occurred\n   *                 in executing this function, else it contains\n   *                 an object with the error that occurred.\n   */\n   ItemMirror.prototype.moveAssociation = function () {\n    throw new Error('Method not implemented');\n   };\n\n  /**\n   * Deletes the association represented by the given GUID.\n   *\n   * Throws NullArgumentException if GUID is null. <br/>\n   * Throws InvalidTypeException if GUID is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method deleteAssociation\n   *\n   * @param GUID {String} GUID of the association to be deleted.\n   *\n   * @param {Function} callback Function to execute once finished.\n   *  @param {Object}   callback.error Null if no error has occurred\n   *                    in executing this function, else an contains\n   *                    an object with the error that occurred.\n   */\n  ItemMirror.prototype.deleteAssociation = function (GUID, callback) {\n    var self = this;\n\n    XooMLUtil.checkCallback(callback);\n    if (!GUID) {\n      return callback(XooMLExceptions.nullArgument);\n    }\n    if (!XooMLUtil.isGUID(GUID)) {\n      return callback(XooMLExceptions.invalidType);\n    }\n\n    // Save to ensure that the fragment is up to date\n    return self.save(deleteContent);\n\n    function deleteContent(error) {\n      if (error) return callback(error);\n\n      var isPhantom = self.isAssociationPhantom(GUID);\n\n      if (!isPhantom) {\n        var isGrouping = self.isAssociationAssociatedItemGrouping(GUID),\n            // For dropbox support, path should be the full path that is\n            // dynamically generated. Refer to case 39 for implementation\n            // details. UNTESTED\n            path = self.getAssociationAssociatedItem(GUID);\n\n        delete self._fragment.associations[GUID];\n        if (isGrouping) {\n          return self._itemDriver.deleteGroupingItem(path, postDelete);\n        } else {\n          return self._itemDriver.deleteNonGroupingItem(path, postDelete);\n        }\n      } else {\n        delete self._fragment.associations[GUID];\n\n        // Now do an unsafe_write to commit the XML. It's okay because\n        // save means that everything is synced, and this operation\n        // was extremely quick\n        return self._unsafeWrite(function(error) {\n          if (error) return callback(error);\n          else return callback();\n        });\n      }\n    }\n\n    // Now do a refresh since actual files were removed.\n    function postDelete(error) {\n      if (error) return callback(error);\n\n      return self.refresh(function(error) {\n        if (error) return callback(error);\n        return callback(error);\n      });\n    }\n\n  };\n\n  /**\n   * Upgrades a given association without a local item. Local item is named\n   * by a truncated form of the display name of this ItemMirror if the\n   * localItemURI is not given, else uses given localItemURI. Always\n   * truncated to 50 characters.\n   *\n   * ONLY SUPPORTS SIMPLE PHANTOM ASSOCIATION TO ASSOCIATION WITH GROUPING ITEM\n   *\n   * Throws NullArgumentException when options is null. <br/>\n   * Throws MissingParameterException when options is not null and a required\n   * argument is missing.<br/>\n   * Throws InvalidTypeException if GUID is not a string, and if callback\n   * is not a function. <br/>\n   * Throws InvalidState if the association with the given GUID cannot be\n   * upgraded. <br/>\n   *\n   * @method upgradeAssociation\n   *\n   * @param {Object} options Data to construct a new ItemMirror with\n   *\n   *  @param {String} options.GUID of the association to be upgraded. Required\n   *\n   *  @param {String} options.localItemURI URI of the local item to be used if\n   *                  a truncated display name is not the intended behavior.\n   *                  Optional.\n   *\n   * @param {Function} callback Function to execute once finished.\n   *\n   *  @param {String}   callback.error Null if no error has occurred\n   *                    in executing this function, else an contains\n   *                    an object with the error that occurred.\n   */\n  ItemMirror.prototype.upgradeAssociation = function () {\n    throw new Error('Method not implemented');\n  };\n\n  /**\n   * Renames the local item for the association with the given GUID.\n   *\n   * Throws NullArgumentException if GUID, callback is null. <br/>\n   * Throws InvalidTypeException if GUID is not a String, and if callback\n   * is not a function. <br/>\n   *\n   * @method renameAssocaitionLocalItem\n   *\n   * @param {String} GUID GUID of the association.\n   * @param {String} String String Name you want to rename the file to (including file extension)\n   * @param {Function} callback Function to execute once finished.\n   *  @param {Object}   callback.error Null if no error has occurred\n   *                    in executing this function, else an contains\n   *                    an object with the error that occurred.\n   * @param {String} callback.GUID The GUID of the association that was updated.\n   */\n  ItemMirror.prototype.renameAssociationLocalItem = function (GUID, newName, callback) {\n    // This method needs a redesign, and can't be properly implemented the way\n    // it is now. Instead, this needs to pass information to the acual item\n    // driver and that needs to implement an agnostic new name format. This\n    // path stuff is specific to dropbox and doesn't work\n    var self = this;\n    XooMLUtil.checkCallback(callback);\n    if (!GUID) {\n      return callback(XooMLExceptions.nullArgument);\n    }\n    if (!XooMLUtil.isGUID(GUID)) {\n      return callback(XooMLExceptions.invalidType);\n    }\n\n    self.save(postSave);\n\n    function postSave(error) {\n      if (error) return callback(error);\n\n      // This stuff needs to be replaced with a method that works for all stores\n          // oldPath = PathDriver.joinPath(self._groupingItemURI, localItem),\n          // newPath = PathDriver.joinPath(self._groupingItemURI, newName);\n\n      self._itemDriver.rename(newName, postMove);\n    }\n\n    function postMove(error) {\n      if (error) return callback(error);\n      // This also needs to be more agnostic\n      self._fragment.associations[GUID].commonData.localItem = newName;\n\n      self._unsafeWrite(postWrite);\n    }\n\n    function postWrite(error) {\n      if (error) return callback(error);\n\n      self.refresh(postRefresh);\n    }\n\n    function postRefresh(error) {\n      return callback(error, self._fragment.associations[GUID].commonData.ID);\n    }\n  };\n\n  /**\n   * A special method that is used for certain file operations where\n   * calling a sync won't work. Essentially it is the save function,\n   * sans syncing. This should __never__ be called be an application.\n   * @method _unsafeWrite\n   * @param callback\n   * @param calback.error\n   */\n  ItemMirror.prototype._unsafeWrite = function(callback) {\n    var self = this;\n\n    // Note (12/8/2015) This was never used, but seems like it has purpose. May need to investigate\n    //var tmpFragment = new FragmentEditor({text: content});\n    self._fragment.updateID();\n    return self._xooMLDriver.setXooMLFragment(self._fragment.toString(), function(error) {\n      if (error) return callback(error);\n      return callback(false);\n    });\n  };\n\n  /**\n   * Checks if an association's associatedItem is a grouping item\n   *\n   * Throws NullArgumentException if GUID, callback is null. <br/>\n   * Throws InvalidTypeException if GUID is not a String, and if callback\n   * is not an function. <br/>\n   *\n   * @method isAssociationAssociatedItemGrouping\n   * @return {Boolean} True if the association with the given GUID's associatedItem is a grouping\n   * item, otherwise false.\n   *\n   * @param GUID {String} GUID of the association to be to be checked.\n   *\n   */\n  ItemMirror.prototype.isAssociationAssociatedItemGrouping = function(GUID) {\n    return this._fragment.associations[GUID].commonData.isGrouping;\n  };\n\n  /**\n   * Lists the GUIDs of each association.\n   *\n   * @method listAssociations\n   *\n   * @return {String[]} Array of the GUIDs of each association\n   */\n  ItemMirror.prototype.listAssociations = function() {\n    return Object.keys(this._fragment.associations);\n  };\n\n  /**\n   *\n   * Throws NullArgumentException if attributeName, GUID, or namespaceURI is\n   * null. <br/>\n   * Throws InvalidTypeException if attributeName, GUID, or namespaceURI is not\n   * a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method getAssociationNamespaceAttribute\n   * @return {String} The association namespace attribute with\n   * the given attributeName and the given namespaceURI within the\n   * association with the given GUID.\n   *\n   * @param {String} attributeName Name of the attribute to be returned.\n   * @param {String} GUID          GUID of the association to return attribute from.\n   * @param {String} uri Namspace URI\n   *\n   */\n  ItemMirror.prototype.getAssociationNamespaceAttribute = function(attributeName, GUID, uri) {\n    var ns = this._fragment.associations[GUID].namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    return this._fragment.associations[GUID].namespace[uri].attributes[attributeName];\n  };\n\n  /**\n   * Sets the association namespace attribute with the given attributeName\n   * and the given namespaceURI within the association with the given GUID.\n   *\n   * Throws NullArgumentException if attributeName, attributeValue, GUID, or\n   * namespaceURI is null. <br/>\n   * Throws InvalidTypeException if attributeName, attributeValue, GUID, or\n   * namespaceURI is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method setAssociationNamespaceAttribute\n   *\n   * @param {String} attributeName  Name of the attribute to be set.\n   * @param {String} attributeValue Value of the attribute to be set\n   * @param {String} GUID           GUID of association to set attribute for.\n   * @param {String} uri Namespace URI\n   *\n   */\n  ItemMirror.prototype.setAssociationNamespaceAttribute = function(attributeName, attributeValue, GUID, uri) {\n    var ns = this._fragment.associations[GUID].namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    this._fragment.associations[GUID].namespace[uri].attributes[attributeName] = attributeValue;\n  };\n\n  /**\n   * Adds the given attributeName to the association with the given GUID and\n   * namespaceURI.\n   *\n   * Throws NullArgumentException if attributeName, GUID, or namespaceURI is\n   * null. <br/>\n   * Throws InvalidTypeException if attributeName, GUID, or namespaceURI is not\n   * a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   * Throws an InvalidStateException when the given attributeName has already\n   * been added. <br/>\n   *\n   * @method addAssociationNamespaceAttribute\n   *\n   * @param {String} attributeName Name of the attribute.\n   * @param {String} attributeValue Value of the attribe to be set\n   * @param {String} GUID          GUID of the association.\n   * @param {String} uri Namespace URI\n   */\n  ItemMirror.prototype.addAssociationNamespaceAttribute = function(attributeName, attributeValue, GUID, uri) {\n    var ns = this._fragment.associations[GUID].namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    if (this._fragment.associations[GUID].namespace[uri].attributes[attributeName]) {\n      throw XooMLExceptions.invalidState;\n    }\n    this.setAssociationNamespaceAttribute(attributeName, attributeValue, GUID, uri);\n  };\n\n  /**\n   * Removes the given attributeName to the association with the given GUID and\n   * namespaceURI.\n   *\n   * Throws NullArgumentException if attributeName, GUID, or namespaceURI is\n   * null. <br/>\n   * Throws InvalidTypeException if attributeName, GUID, or namespaceURI is not\n   * a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   * Throws an InvalidStateException when the given attributeName is not an\n   * attribute. <br/>\n   *\n   * @method removeAssociationNamespaceAttribute\n   *\n   * @param {String} attributeName Name of the attribute.\n   * @param {String} GUID          GUID of the association.\n   * @param {String} uri Namespace URI\n   */\n  ItemMirror.prototype.removeAssociationNamespaceAttribute = function(attributeName, GUID, uri) {\n    delete this._fragment.associations[GUID].namespace[uri].attributes[attributeName];\n  };\n\n  /**\n   * @method hasAssociationNamespace\n   * @return {Boolean} True if the association has the given\n   * namespaceURI, else false.\n   *\n   * @param {String} GUID          GUID of the association.\n   * @param {String} uri  Namespace URI\n   *\n   */\n  ItemMirror.prototype.hasAssociationNamespace = function(GUID, uri) {\n    var namespace = this._fragment.associations[GUID].namespace[uri];\n    if (namespace) { return true; }\n    else { return false; }\n  };\n\n  /**\n   *\n   * Throws NullArgumentException if GUID, namespaceURI is null. <br/>\n   * Throws InvalidTypeException if GUID, namespaceURI is not a String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method listAssociationNamespaceAttributes\n   * @return {String[]} An array of the association namespace\n   * attributes with the given attributeName and the given\n   * namespaceURI within the association with the given GUID.\n   *\n   * @param {String} GUID          GUID of association to list attributes for.\n   * @param {String} uri Namespace URI\n   */\n  ItemMirror.prototype.listAssociationNamespaceAttributes = function (GUID, uri) {\n    var ns = this._fragment.associations[GUID].namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    return Object.keys(this._fragment.associations[GUID].namespace[uri].attributes);\n  };\n\n  /**\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method getAssociationNamespaceData\n   * @return {String} The association namespace data for an\n   * association with the given GUID and the given namespaceURI.\n   *\n   * @param {String} GUID GUID of the association namespace data to\n   * returned.\n   * @param {String} uri Namespace URI\n   */\n  self.getAssociationNamespaceData = function (GUID, uri) {\n    var ns = this._fragment.associations[GUID].namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    return this._fragment.associations[GUID].namespace[uri].data;\n  };\n\n  /**\n   * Sets the association namespace data for an association with the given GUID\n   * and given namespaceURI using the given data.\n   *\n   * Throws NullArgumentException if data, GUID, or namespaceURI is null. <br/>\n   * Throws InvalidTypeException if data, GUID, or namespaceURI is not a\n   * String. <br/>\n   * Throws InvalidGUIDException if GUID is not a valid GUID. <br/>\n   *\n   * @method setAssociationNamespaceData\n   *\n   * @param {String} data          Association namespace data to set. Must be\n   *                               valid fragmentNamespaceData.\n   * @param {String} GUID          GUID of the association namespace data to set.\n   */\n  ItemMirror.prototype.setAssociationNamespaceData = function (data, GUID, uri) {\n    var ns = this._fragment.associations[GUID].namespace;\n    ns[uri] = ns[uri] || {};\n    ns[uri].attributes = ns[uri].attributes || {};\n\n    this._fragment.associations[GUID].namespace[uri].data = data;\n  };\n\n  /**\n   * Uses the specified ItemDriver and SyncDriver to synchronize the\n   * local ItemMirror object changes. This is an implmentation of Synchronization\n   * Driver which modifies the XooML Fragment according to the real structure\n   * under the item described.\n   *\n   * @method sync\n   *\n   * @param {Function} callback Function to execute once finished.\n   *  @param {Object}   callback.error Null if no error has occurred\n   *                    in executing this function, else an contains\n   *                    an object with the error that occurred.\n   * @private\n   */\n  ItemMirror.prototype._sync = function (callback) {\n    var self = this;\n\n    self._syncDriver.sync(callback);\n  };\n\n  /**\n   * Reloads the XooML Fragment\n   *\n   * @method refresh\n   *\n   * @param {Function} callback Function to execute once finished.\n   *  @param {Object}   callback.error Null if no error has occurred\n   *                    in executing this function, else an contains\n   *                    an object with the error that occurred.\n   */\n  ItemMirror.prototype.refresh = function(callback) {\n    var self = this;\n\n    self._sync( function(error) {\n      // This error means that sync changed the fragment\n      // We then will reload the fragment based on the new XooML\n      if (error === XooMLExceptions.itemMirrorNotCurrent) {\n        self._xooMLDriver.getXooMLFragment(resetFragment);\n      } else if (error) {\n        callback(error);\n      } else {\n        self._xooMLDriver.getXooMLFragment(resetFragment);\n      }\n    });\n\n    function resetFragment(error, content){\n      if (error) return callback(error);\n\n      self._fragment = new FragmentEditor({text: content});\n      return callback(false);\n    }\n  };\n\n  /**\n   * @method getCreator\n   *\n   * @return {Object} The itemMirror that created this current\n   * itemMirror, if it has one. Note that this isn't the same as\n   * asking for a 'parent,' since multiple itemMirrors can possibly\n   * link to the same one\n   *\n   */\n  ItemMirror.prototype.getCreator = function () {\n    return this._creator;\n  };\n\n\n  /**\n   * Saves the itemMirror object, writing it out to the\n   * fragment. Fails if the GUID generated on last write for the\n   * itemMirror and the XooML fragment don't match.\n   *\n   * @method save\n   *\n   * @param callback\n   *  @param callback.error Returns false if everything went ok,\n   *  otherwise returns the error\n   */\n  ItemMirror.prototype.save = function(callback) {\n    var self = this;\n\n    self._sync(postSync);\n\n    function postSync(error) {\n      if (error) return callback(error);\n\n      return self._unsafeWrite(postWrite);\n    }\n\n    function postWrite(error) {\n      return callback(error);\n    }\n  };\n\n/**\n * Checks if the AssociatedItem String passed into it is a URL or not.\n *\n * @method _isURL\n * @return {Boolean} True if it is an HTTP URL, false otherwise\n * (HTTPS will fail)\n * @private\n * @param {String} URL\n */\n  self._isURL = function (URL){\n    return /^http:\\/\\//.exec(URL);\n  };\n\n\n// This makes the pacakge accessible as a node module\nmodule.exports = ItemMirror;\n\n// This attaches the library as a global if it doesn't already exist\nif (window) { // Checks for window object so we don't break potential node usage\n  window.ItemMirror = window.ItemMirror || ItemMirror\n}","/**\n * An implementation of SyncDriver which syncronizes the XooML so that\n * it reflects the storage. This implementation ensures that only the\n * XooML is modified, and that the user's storage is never modified,\n * safely protecting any data.\n *\n * For ItemMirror core developers only. Enable protected to see.\n *\n * @class SyncDriver\n *\n * @constructor\n * @param {Object} itemMirror The itemMirror object which you wish to\n * synchronize\n *\n * @protected\n */\n\n\n'use strict'\n\nvar FragmentEditor = require('./FragmentEditor');\n\n  function SyncDriver(itemMirror) {\n    var self = this;\n    self._itemMirror = itemMirror;\n    self._itemDriver = itemMirror._itemDriver;\n    self._xooMLDriver = itemMirror._xooMLDriver;\n  }\n\n  /**\n   * Helper method that allows for sorting of objects by the localItem\n   *\n   * @method _nameCompare\n   * @private\n   * @protected\n   */\n  function _localItemCompare(a, b) {\n    if (a.commonData.localItem > b.commonData.localItem) return 1;\n    else if (a.commonData.localItem < b.commonData.localItem) return -1;\n    else return 0;\n  }\n\n  /**\n   * Synchonizes the itemMirror object.\n   *\n   * @method sync\n   *\n   * @param {Function} callback Function to execute once finished.\n   *  @param {Object}   callback.error Null if no error has occurred\n   *                    in executing this function, else an contains\n   *                    an object with the error that occurred.\n   *\n   * @protected\n   */\n  SyncDriver.prototype.sync = function(callback) {\n    var self = this,\n        itemAssociations;\n\n    self._itemDriver.listItems(self._itemMirror._groupingItemURI,\n                               processItems);\n\n    function processItems(error, associations){\n      if (error) return callback(error);\n\n      itemAssociations = associations;\n      self._xooMLDriver.getXooMLFragment(processXooML);\n    }\n\n    function processXooML(error, xooMLContent) {\n      // A 404 error is dropbox telling us that the file doesn't\n      // exist. In that case we just write the file\n      if (error === 404) {\n        var fragmentString = self._itemMirror._fragment.toString();\n        return self._xooMLDriver.setXooMLFragment( fragmentString, function(error) {\n          if (error) callback(error);\n          else callback(false);\n        });\n      } else if (error) {\n        return callback(error);\n      }\n\n      // Keeps track of the index in the xooMLassociations so that\n      // we don't waste time searching from the beginning\n      var xooMLIdx = 0;\n      // Keeps track of whether there are any changes that need to be made\n      var synchronized = true;\n      var xooMLAssociations;\n\n      self._fragmentEditor = new FragmentEditor({text: xooMLContent});\n\n      xooMLAssociations = Object.keys(self._fragmentEditor.associations)\n      // Turns the associative array into a regular array for iteration\n        .map( function(guid) {\n          return self._fragmentEditor.associations[guid];\n        })\n      // filters out any phantoms\n  .filter( function(assoc) {\n    return assoc.commonData.localItem !== null;\n  });\n\n      // No guarantee that the storage API sends results sorted\n      itemAssociations.sort(_localItemCompare);\n      xooMLAssociations.sort(_localItemCompare);\n\n      // Gets the localItems in a separate array, but in needed sorted order\n      var itemLocals = itemAssociations.map( function (assoc) {return assoc.commonData.localItem;} );\n      var xooMLLocals = xooMLAssociations.map( function (assoc) {return assoc.commonData.localItem;} );\n\n      itemLocals.forEach( function(localItem, itemIdx) {\n  var search = xooMLLocals.lastIndexOf(localItem, xooMLIdx);\n  // Create association\n  if (search === -1) {\n    synchronized = false;\n    // Case 6/7 only, other cases won't be handled\n          var association = itemAssociations[itemIdx];\n          self._fragmentEditor.associations[association.commonData.ID] = association;\n  } else {\n    // Deletes any extraneous associations\n    xooMLAssociations\n      .slice(xooMLIdx, search)\n      .forEach( function(assoc) {\n        synchronized = false;\n              delete self._fragmentEditor.associations[assoc.guid];\n      });\n    xooMLIdx = search + 1;\n  }\n      });\n      // Any remaining associations need to be deleted because they don't exist\n      xooMLAssociations\n  .slice(xooMLIdx, xooMLLocals.length)\n  .forEach( function(assoc) {\n    synchronized = false;\n          delete self._fragmentEditor.associations[assoc.commonData.ID];\n  });\n\n      // Only save fragment if needed\n      if (!synchronized) {\n        self._fragmentEditor.updateID(); // generate a new guid for GUIDGeneratedOnLastWrite;\n        // Writes out the fragment\n        self._xooMLDriver.setXooMLFragment(self._fragmentEditor.toString(), function(error) {\n          if (error) return callback(error);\n\n          return callback(false);\n        });\n      } else return callback(false);\n    }\n  };\n\nmodule.exports = SyncDriver;","/**\n * Configuration variables for XooML.js\n *\n * For ItemMirror core developers only. Enable protected to see.\n *\n * @class XooMLConfig\n * @static\n *\n * @protected\n */\nmodule.exports = {\n  // default schema version\n  schemaVersion: \"0.54\",\n\n  // default schema location\n  schemaLocation: \"http://kftf.ischool.washington.edu/xmlns/xooml\",\n\n  // XooMLFragment file name for XooML2.xmlns\n  xooMLFragmentFileName: \"XooML2.xml\",\n\n  // Maximum file length for upgradeAssociation localItemURI truncation\n  maxFileLength: 50,\n\n  // Case 1\n  createAssociationSimple: {\n    \"displayText\": true\n  },\n\n  // Case 2 and 3\n  // localItemRequested exists:> case 3\n  createAssociationLinkNonGrouping: {\n    \"displayText\": true,        // String\n    \"itemURI\": true,            // String\n    \"localItemRequested\": false // String\n  },\n\n  // Case 4 and 5\n  // localItemRequested:== true:> Case 5\n  createAssociationLinkGrouping: { // Case 3\n    \"displayText\": true,\n    \"groupingItemURI\": true,\n    \"xooMLDriverURI\": true\n  },\n\n  // Case 6 and 7\n  createAssociationCreate: {\n    \"displayText\": true,\n    \"itemName\": true,\n    \"isGroupingItem\": true\n  }\n}","/**\n * Collection of exceptions associated with the XooML tools.\n *\n * For ItemMirror core developers only. Enable protected to see.\n *\n * @class XooMLExceptions\n * @static\n *\n * @protected\n */\nmodule.exports = {\n  /**\n   * Thrown when a method is not yet implemented.\n   *\n   * @event NotImplementedException\n   *\n   * @protected\n   */\n  notImplemented: \"NotImplementedException\",\n\n  /**\n   * Thrown when a required property from a method's options is missing.\n   *\n   * @event MissingParameterException\n   *\n   * @protected\n   */\n  missingParameter: \"MissingParameterException\",\n\n  /**\n   * Thrown when an argument is given a null value when it does not accept null\n   * values.\n   *\n   * @event NullArgumentException\n   *\n   * @protected\n   */\n  nullArgument: \"NullArgumentException\",\n\n  /**\n   * Thrown when an argument is given a value with a different type from the\n   * expected type.\n   *\n   * @event InvalidTypeException\n   *\n   * @protected\n   */\n  invalidType: \"InvalidTypeException\",\n\n  /**\n   * Thrown when an a method is called when the object is in invalid state\n   * given what the method expected.\n   *\n   * @event InvalidStateArgument\n   *\n   * @protected\n   */\n  invalidState: \"InvalidStateArgument\",\n\n  /**\n   * Thrown after receiving an exception from XooMLU Storage\n   *\n   * @event XooMLUException\n   *\n   * @protected\n   */\n  xooMLUException: \"XooMLUException\",\n\n  /**\n   * Thrown after receiving an exception from ItemU Storage\n   *\n   * @event ItemUException\n   *\n   * @protected\n   */\n  itemUException: \"ItemUException\",\n\n  /**\n   * Thrown after an association was upgraded that could not be upgraded.\n   *\n   * @event NonUpgradeableAssociationException\n   *\n   * @protected\n   */\n  nonUpgradeableAssociationException: \"NonUpgradeableAssociationException\",\n\n  /**\n   * Thrown after an argument was passed in an invalid state than expected.\n   *\n   * @event InvalidArgumentException\n   *\n   * @protected\n   */\n  invalidArgument: \"InvalidOptionsException\",\n\n  /**\n   * Thrown after expecting a file or folder not to exist when it does.\n   *\n   * @event FileOrFolderAlreadyExistsException\n   *\n   * @protected\n   */\n  itemAlreadyExists: \"ItemAlreadyExistsException\",\n\n  /**\n   * Thrown when expecting the ItemMirror to be current, and it is not.\n   *\n   * @event FileOrFolderAlreadyExistsException\n   *\n   * @protected\n   */\n  itemMirrorNotCurrent: \"ItemMirrorNotCurrent\"\n}","/**\n * Collection of type checking, exception throwing, utility methods for the\n * XooML tools.\n *\n * For ItemMirror core developers only. Enable protected to see.\n *\n * @class XooMLUtil\n * @static\n *\n * @protected\n */\n\n 'use strict'\n\n var XooMLExceptions = require('./XooMLExceptions');\n\n  var\n    _TYPES = {\n      \"[object Boolean]\": \"boolean\",\n      \"[object Number]\": \"number\",\n      \"[object String]\": \"string\",\n      \"[object Function]\": \"function\",\n      \"[object Array]\": \"array\",\n      \"[object Date]\": \"date\",\n      \"[object RegExp]\": \"regexp\",\n      \"[object Object]\": \"object\",\n      \"[object Error]\": \"error\"\n    };\n\n  var XooMLUtil = {\n    /**\n     * Checks if each option within the given checkedOptions is a property of\n     * the given options.\n     *\n     * @method hasOptions\n     *\n     * @param {Object}  checkedOptions Array of strings for each expected option.\n     * @param {Object} options         Options given to a function.\n     *\n     * @protected\n     */\n    hasOptions: function (checkedOptions, options) {\n      if (!checkedOptions || !options) {\n        throw XooMLExceptions.nullArgument;\n      }\n      if (!XooMLUtil.isObject(checkedOptions) ||\n          !XooMLUtil.isObject(options)) {\n        throw XooMLExceptions.invalidType;\n      }\n      var checkedOption, isRequiredOption, missingOptionalParamCount;\n\n      missingOptionalParamCount = 0;\n\n      if (Object.keys(options).length <= Object.keys(checkedOptions).length) {\n        for (checkedOption in checkedOptions) {\n          if (checkedOptions.hasOwnProperty(checkedOption)) {\n            isRequiredOption = checkedOptions[checkedOption];\n\n            if (!options.hasOwnProperty(checkedOption)) {\n              if (isRequiredOption) {\n                return false;\n              } else {\n                missingOptionalParamCount += 1;\n              }\n            }\n          }\n        }\n      } else {\n        return false;\n      }\n\n      return Object.keys(options).length <=\n        Object.keys(checkedOptions).length - missingOptionalParamCount;\n    },\n\n    // throws exceptions for callbacks since null callbacks mean the program can't continue\n    checkCallback: function (callback) {\n      if (callback) {\n        if (!XooMLUtil.isFunction(callback)) {\n          throw XooMLExceptions.invalidType;\n        }\n      } else {\n        throw XooMLExceptions.nullArgument;\n      }\n    },\n\n    isGUID: function (GUID) {\n      if (XooMLUtil.getType(GUID) === \"string\") {\n        return true; // TODO implement guid checking\n      } else {\n        return false;\n      }\n    },\n\n    /**\n     * Returns if the given value is an array.\n     *\n     * Throws NullArgumentException when value is null. <br/>\n     *\n     * @method isArray\n     *\n     * @param {Object} value Given object have it's type checked.\n     *\n     * @protected\n     */\n    isArray: function (value) {\n      return XooMLUtil.getType(value) === \"array\";\n    },\n\n    /**\n     * Returns if the given value is an object.\n     *\n     * Throws NullArgumentException when value is null. <br/>\n     *\n     * @method isObject\n     *\n     * @param {Object} value Given object have it's type checked.\n     *\n     * @return {Boolean} True if the given value is an Object, else false.\n     *\n     * @protected\n     */\n    isObject: function (value) {\n      return XooMLUtil.getType(value) === \"object\";\n    },\n\n    /**\n     * Returns if the given value is an function.\n     *\n     * Throws NullArgumentException when value is null. <br/>\n     *\n     * @method isFunction\n     *\n     * @param {Object} value Given object have it's type checked.\n     *\n     * @return {Boolean} True if the given value is a Function, else false.\n     *\n     * @protected\n     */\n    isFunction: function (value) {\n      return value !== null;\n      //return XooMLUtil.getType(value) === \"function\"; TODO figure out why this doesn't work\n    },\n\n    /**\n     * Returns if the given value is an string.\n     *\n     * Throws NullArgumentException when value is null. <br/>\n     *\n     * @method isString\n     *\n     * @param {Object} value Given object have it's type checked.\n     *\n     * @return {Boolean} True if the given value is a String, else false.\n     *\n     * @protected\n     */\n    isString: function (value) {\n      return XooMLUtil.getType(value) === \"string\";\n    },\n\n    isBoolean: function (value) {\n      return XooMLUtil.getType(value) === \"boolean\";\n    },\n\n    /**\n     * Generates a GUID.\n     *\n     * @method generateGUID\n     *\n     * @return {String} Randomly generated GUID.\n     *\n     * @protected\n     */\n    generateGUID: function () {\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n      });\n    },\n\n    getType: function (obj) {\n      if (obj === null) {\n        return String(obj);\n      }\n      return typeof obj === \"object\" ||\n        typeof obj === \"function\" ? _TYPES[obj.toString()] || \"object\" : typeof obj;\n    },\n\n    endsWith: function (string, suffix) {\n      return string.indexOf(suffix, string.length - suffix.length) !== -1;\n    },\n\n    // http://stackoverflow.com/questions/728360/most-elegant-way-to-clone-a-javascript-object\n    clone: function (obj) {\n      var copy;\n      // Handle the 3 simple types, and null or undefined\n      if (null === obj || \"object\" != typeof obj) return obj;\n\n      // Handle Date\n      if (obj instanceof Date) {\n        copy = new Date();\n        copy.setTime(obj.getTime());\n        return copy;\n      }\n\n      // Handle Array\n      if (obj instanceof Array) {\n        copy = [];\n        for (var i = 0, len = obj.length; i < len; i++) {\n          copy[i] = XooMLUtil.clone(obj[i]);\n        }\n        return copy;\n      }\n\n      // Handle Object\n      if (obj instanceof Object) {\n        copy = {};\n        for (var attr in obj) {\n          if (obj.hasOwnProperty(attr)) copy[attr] = XooMLUtil.clone(obj[attr]);\n        }\n        return copy;\n      }\n\n      throw XooMLExceptions.invalidType;\n    }\n  };\n\nmodule.exports = XooMLUtil;","/**\n * An item utility interacts with the item storage and is responsible for\n * creating and deleting items. This is an implementation of item utility\n * using Dropbox as the item storage.\n *\n * For ItemMirror core developers only. Enable protected to see.\n *\n * @class ItemDriver\n * @constructor\n *\n * @param {Object} options Data to construct a new ItemU with\n * @param {String} options.utilityURI URI of the utility\n * @param {Object} options.dropboxClient Authenticated dropbox client\n *\n * @protected\n */\n\n'use strict'\n\nvar XooMLConfig = require('./XooMLConfig');\nvar AssociationEditor = require('./AssociationEditor');\n\n  /**\n   * Constructs a ItemDriver for reading/writing Item Storage\n   *\n   * @method ItemDriver\n   *\n   * @param {Object} options Options passed for construction\n   * @param {Function} callback The function to call after completion\n   *\n   * @protected\n   */\n  function ItemDriver(options, callback) {\n    var self = this;\n\n    // client (google drive in this case)\n    if (!options.clientInterface) {\n      throw new Error('Client parameter missing');\n    }\n    this.clientInterface = options.clientInterface;\n\n    var authResponse = this.clientInterface.auth2.getAuthInstance()\n      .currentUser.get()\n      .getAuthResponse();\n\n    // These are the same across multple files, and so should be put in a common configuration somewhere\n    this._AUTH_HEADER = { Authorization: 'Bearer ' + authResponse.access_token };\n    this._DRIVE_FILE_API = 'https://www.googleapis.com/drive/v2/files/';\n\n    self._FOLDER_MIMETYPE = 'application/vnd.google-apps.folder';\n\n    return callback(false, self);\n  }\n\n  ItemDriver.prototype.isGroupingItem = function (id, callback) {\n    var self = this;\n\n    // do a simple get request, and see if it's a folder\n    $.get({\n      url: self._DRIVE_FILE_API + id,\n      headers: self._AUTH_HEADER\n    }).then(function(resp) {\n      // This is the specific mimetype that google counts as a 'folder'\n      callback(false, self._FOLDER_MIMETYPE === resp.mimeType);\n    }).fail(function() {\n      callback('No response from GET: ' + id);\n    });\n  };\n\n  /**\n   * Creates a grouping item at the location\n   * @method createGroupingItem\n   * @param {String} path the path to the location that the grouping item will be created\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\n   *\n   * @protected\n   */\n  ItemDriver.prototype.createGroupingItem = function (parentURI, title, callback) {\n    var self = this;\n\n    $.post({\n      url: self._DRIVE_FILE_API,\n      headers: self._AUTH_HEADER,\n      body: {\n        mimeType: self._FOLDER_MIMETYPE,\n        title: title,\n        parents: [parentURI]\n      }\n    }).then(function(resp) {\n      // Callback with ID of the newly created folder so we have a reference\n      callback(false, resp.id);\n    }).fail(function() {\n      callback('Failed to make POST request for new grouping item. Check network requests for more deatils');\n    });\n  };\n\n  /**\n   * Creates or uploads a non-grouping item at the location\n   * @method createNonGroupingItem\n   * @param {String} path the path to the location that the non-grouping item will be created\n   * @param {String} file the contents to be written to the non-grouping item\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\n   *\n   * @protected\n   */\n  ItemDriver.prototype.createNonGroupingItem = function (fileName, file, callback) {\n    var self = this;\n\n    function insertFile(fileData, callback) {\n      var boundary = '-------314159265358979323846';\n      var delimiter = \"\\r\\n--\" + boundary + \"\\r\\n\";\n      var close_delim = \"\\r\\n--\" + boundary + \"--\";\n\n      var reader = new FileReader();\n      reader.readAsBinaryString(fileData);\n      reader.onload = function() {\n        var contentType = fileData.type || 'application/octet-stream';\n        var metadata = {\n          'title': XooMLConfig.xooMLFragmentFileName,\n          'mimeType': contentType,\n          'parents': [{\n            \"kind\": \"drive#parentReference\",\n            \"id\": self._parentURI\n          }]\n        };\n\n        var base64Data = btoa(reader.result);\n        var multipartRequestBody =\n            delimiter +\n            'Content-Type: application/json\\r\\n\\r\\n' +\n            JSON.stringify(metadata) +\n            delimiter +\n            'Content-Type: ' + contentType + '\\r\\n' +\n            'Content-Transfer-Encoding: base64\\r\\n' +\n            '\\r\\n' +\n            base64Data +\n            close_delim;\n\n        var request = this.gapi.client.request({\n            'path': '/upload/drive/v2/files',\n            'method': 'POST',\n            'params': {'uploadType': 'multipart'},\n            'headers': {\n              'Content-Type': 'multipart/mixed; boundary=\"' + boundary + '\"'\n            },\n            'body': multipartRequestBody});\n        request.execute(function(response) {\n          callback(false, response);\n        }, function(response) {\n          callback('Could not write out File', response);\n        });\n      };\n    }\n\n    var blob = new Blob([file], {type: 'text/plain', fileName: fileName});\n\n    return insertFile(blob, callback);\n  };\n\n\n  // Helper function for deleting files, since no distinction is needed\n  // between grouping items and non grouping items in google drive\n  ItemDriver.prototype._deleteID = function (id, callback) {\n    var self = this;\n\n    $.delete({\n      url: self._DRIVE_FILE_API + '/' + id,\n      headers: self._AUTH_HEADER\n    }).then(function(resp) {\n      callback(false, resp);\n    }).fail(function(resp) {\n      callback('Failed to make DELETE request for new grouping item. Check network requests for more deatils', resp);\n    });\n  }\n  /**\n   * Deletes a grouping item with the specified ID\n   * @method deleteGroupingItem\n   * @param {String} id the id of the file that will be deleted. This is specific to google\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\n   *\n   * @protected\n   */\n  ItemDriver.prototype.deleteGroupingItem = function (id, callback) {\n    this._deleteID(id, callback);\n  };\n\n  /**\n   * Deletes a non-grouping item at the location\n   * @method deleteNonGroupingItem\n   * @param {String} id the id of the file that will be deleted. This is specific to google\n   * @param {Function} callback Function to be called when self function is finished with it's operation.\n   *\n   * @protected\n   */\n  ItemDriver.prototype.deleteNonGroupingItem = function (id, callback) {\n    this._deleteID(id, callback);\n  };\n  \n  /**\n   * Lists the items under the grouping item\n   * @method listItems\n   * @param {String} path the path to the grouping item\n   * @param {Function} callback(output) Function to be called when self function is finished with it's operation. Output is an array of AssociationEditors.\n   *\n   * @protected\n   */\n  ItemDriver.prototype.listItems = function (parentURI, callback) {\n    var self = this;\n\n    var query = '\\'' + parentURI + '\\' in ' + 'parents';\n    var request = this.clientInterface.client.drive.files.list({\n      'maxResults': 1000,\n      'q': query\n    });\n    request.execute(function(resp) {\n      if (resp.error) {\n        return callback('Error: Bad Response / Request');  \n      }\n\n      var items = resp.items.filter(function(item) {\n        return item.title !== XooMLConfig.xooMLFragmentFileName;\n      })\n      .map(function(item) {\n        return new AssociationEditor({\n          commonData: {\n            // Change this to be the ID of the XooML.xml file eventually\n            // Will need another parameter for that\n            associatedXooMLFragment: null, \n            associatedItem: item.id,\n            associatedItemDriver: 'GoogleItemDriver',\n            associatedXooMLDriver: 'GoogleXooMLDriver',\n            associatedSyncDriver: 'MirrorSyncDriver', \n            isGrouping: item.mimeType === self._FOLDER_MIMETYPE,\n            localItem: item.id,\n            displayText: item.title,\n            publicURL: item.alternateLink\n          }\n        });\n      });\n\n      callback(false, items);\n    });\n  };\n\n  /**\n   * Check if the item is existed\n   * @method checkExisted\n   * @param {String} path the path to the location that the item is located\n   * @param {String} name the name of the item\n   * @param {Function} callback(result) Function to be called when self function is finished with it's operation. Result is the bollean value for whether existed.\n   *\n   * @protected\n   */\n  ItemDriver.prototype.checkExisted = function(path, callback){\n    var self = this, result;\n\n    self._dropboxClient.stat(path, function (error,stat){\n      if (error) {\n        return self._showDropboxError(error, callback);\n      }\n      result = !(error !== null && error.status === 404) || (error === null && stat.isRemoved);\n\n      return callback(false, result);\n    });\n  };\n\nmodule.exports = ItemDriver;","/**\n * An XooML utility interacts with an storage and is responsible for\n * reading and writing XooML fragments. This is an implementation of XooML utility\n * using Dropbox as the storage.\n *\n * This specific version is for google drive\n *\n * For ItemMirror core developers only. Enable protected to see.\n *\n * @class XooMLDriver\n * @constructor\n *\n * @param {Object} options Data to construct a new XooMLU with\n * @param {String} options.fragmentURI The URI of fragment\n * contains the XooML\n * @param {String} options.utilityURI URI of the utility\n * @param {Object} options.dropboxClient Authenticated dropbox client\n *\n * @protected\n */\n\nvar XooMLConfig = require('./XooMLConfig');\n  /**\n   * Constructs a XooMLDriver for reading/writing XooML fragment.\n   *\n   * @method XooMLDriver\n   *\n   * @param {Object} options A list of options for construction\n   * @param {Function} callback A function to call after completion\n   *\n   * @protected\n   */\n  function XooMLDriver(options, callback) {\n    var self = this;\n\n    if (!options.clientInterface) {\n      throw new Error('Missing client interface in options!');\n    }\n\n    // The parent URI tells us what 'folder', the XooML should be put inside\n    // of. Root is a special URI for google drive, otherwise it should be an\n    // id\n    this._parentURI = options.associatedItem || 'root';\n\n    // Client Interface is whatever object that a given client hands back\n    // after the authorization step. We use it to make sending and recieving\n    // requests extremely simple.\n\n    // Note: This does assume that the client has already been authenticated\n    // If not it could lead to potential errors. gapi should be set to the\n    // clientInterface\n    this.clientInterface = options.clientInterface;\n    // To avoid confusion, we should remove the above and any references to\n    // it. It makes the code way easier to read\n    this.gapi = this.clientInterface;\n\n    // The fragmentURI is the id of the XooML file. It may or may not exist\n    this._fragmentURI = options.fragmentURI ? options.fragmentURI : null;\n\n    // This comes from the usage of teh updated API, we have to jump through\n    // several hoops to geth the authentication token that we're looking for\n    var authResponse = this.clientInterface.auth2.getAuthInstance()\n      .currentUser.get()\n      .getAuthResponse();\n\n    // This is the authorized header, so we can easily make requests via ajax.\n    // If we get request errors, make sure that this header is correct, and\n    // doesn't constantly change\n    this._AUTH_HEADER = { Authorization: 'Bearer ' + authResponse.access_token };\n    this._DRIVE_FILE_API = 'https://www.googleapis.com/drive/v2/files/';\n\n    return callback(false, self);\n  }\n\n\n  /**\n   * Creates a request for a given fileID and executes the request\n   * @method _readFile\n   * @param  {Function} callback Function with the XML string response\n   * @param {String} id ID of the file you want to get download\n   */\n  XooMLDriver.prototype._readFile = function(callback) {\n    var self = this;\n\n    $.ajax({\n      url:  self._DRIVE_FILE_API + self._fragmentURI,\n      // Required to actually initiate a download\n      data: 'alt=media',\n      // If this isn't specified, we get an XMLDocument back. We want a\n      // string for maximum flexibility.\n      dataType: 'text',\n      // Note, if the authorization header is messed up, it will give us\n      // an error that tells us we need to sign in and have reached our\n      // limit.\n      headers: self._AUTH_HEADER\n    }).then(function(xml_text) {\n      callback(false, xml_text);\n    });\n  };\n\n  // This is a helper function that searches for the xml file in a folder when\n  // necessary\n  XooMLDriver.prototype._searchXooML = function(callback, folderID) {\n    var self = this;\n\n    // This query means return the file with the title XooML2.xml in the\n    // root directory.\n    // Details on the gapi query syntax: https://developers.google.com/drive/web/search-parameters\n    var query = 'title = \\'' + XooMLConfig.xooMLFragmentFileName + '\\' and \\'' + folderID + '\\' in parents';\n    var request = this.clientInterface.client.drive.files.list({\n      'maxResults': 10,\n      'q': query\n    });\n    request.execute(function(resp) {\n      // Now that we've made the request, we can extract the fileID and\n      // read the file contents\n      var xoomlItem = resp.items[0];\n\n      // This means that there currently is no XooML file\n      if (!xoomlItem) {\n        // This error should be standardized somewhere and made into a number\n        // that way all drivers can  share it\n        return callback('XooML Not Found'); \n      }\n\n      self._fragmentURI = xoomlItem.id;\n      self._readFile(callback);\n    });\n  }\n\n  /**\n   * Reads and returns a XooML fragment\n   * @method getXooMLFragment\n   * @param {Function} callback(content) Function to be called when self function is finished with it's operation. content is the content of the XooML fragment.\n   *\n   * @protected\n   */\n  XooMLDriver.prototype.getXooMLFragment = function (callback) {\n    // If we don't have the fragmentURI, we need this for searching\n    if (!this._fragmentURI) {\n      return this._searchXooML(callback, this._parentURI);\n    } else {\n      // General case, where we don't need to do a query\n      this._readFile(callback, this._fragmentURI);\n    }\n  };\n\n  /**\n   * Writes a XooML fragment\n   * @method setXooMLFragment\n   * @param {String} xmlString the content of the XooML fragment\n   * @param {Function} callback(content) Function to be called when self function is finished with it's operation. content is the content of the XooML fragment.\n   *\n   * @protected\n   */\n  XooMLDriver.prototype.setXooMLFragment = function (xmlString, callback) {\n    var self = this;\n    var mimeType = 'text/xml';\n\n    // Used when updating an already existing XooML.xml\n    function updateFile(callback) {\n      var request = this.gapi.client.request({\n        path: '/upload/drive/v2/files/' + self._fragmentURI,\n        method: 'PUT',\n        params: {'uploadType': 'media'},\n        body: xmlString\n      });\n\n      request.execute(function() {\n        callback(false);\n      }, function(error) {\n        callback(error);\n      });\n    }\n\n    // Used when writing a new XooML file\n    function insertFile(fileData, callback) {\n      var boundary = '-------314159265358979323846';\n      var delimiter = \"\\r\\n--\" + boundary + \"\\r\\n\";\n      var close_delim = \"\\r\\n--\" + boundary + \"--\";\n\n      var reader = new FileReader();\n      reader.readAsBinaryString(fileData);\n      reader.onload = function() {\n        var contentType = fileData.type || 'application/octet-stream';\n        var metadata = {\n          'title': XooMLConfig.xooMLFragmentFileName,\n          'mimeType': contentType,\n          'parents': [{\n            \"kind\": \"drive#parentReference\",\n            \"id\": self._parentURI\n          }]\n        };\n\n        var base64Data = btoa(reader.result);\n        var multipartRequestBody =\n            delimiter +\n            'Content-Type: application/json\\r\\n\\r\\n' +\n            JSON.stringify(metadata) +\n            delimiter +\n            'Content-Type: ' + contentType + '\\r\\n' +\n            'Content-Transfer-Encoding: base64\\r\\n' +\n            '\\r\\n' +\n            base64Data +\n            close_delim;\n\n        var request = self.gapi.client.request({\n            'path': '/upload/drive/v2/files',\n            'method': 'POST',\n            'params': {'uploadType': 'multipart'},\n            'headers': {\n              'Content-Type': 'multipart/mixed; boundary=\"' + boundary + '\"'\n            },\n            'body': multipartRequestBody});\n        request.execute(function(response) {\n          // The response is the newly created file, and we set the fragment ID to that\n          // so that future requests don't require additional searches\n          self._fragmentURI = response.id\n          callback(false);\n        }, function(response) {\n          callback('Could not write out XooML Fragment', response);\n        });\n      };\n    }\n\n    var blob = new Blob([xmlString], {type: mimeType, fileName: XooMLConfig.xooMLFragmentFileName});\n\n\n    // Update or create the file depending on the circumstances\n    if (self._fragmentURI) {\n      updateFile(callback);\n    } else {\n      insertFile(blob, callback);\n    }\n  };\n\n  /**\n   * Check if the XooML fragment exists\n   * @method checkExists\n   * @param {Function} callback Function to be called when\n   * self function is finished with it's operation.\n   *  @param {String} callback.error Dropbox error if there is one\n   *  @param {Boolean} callback.result True if the fragment exists and\n   *  false otherwis\n   *\n   * @protected\n   */\n  XooMLDriver.prototype.checkExists = function (callback) {\n    var self = this;\n\n    // If we have the URI, first make a direct request for that\n    if (this._fragmentURI) {\n      // A simple get request will suffice\n      $.get({\n        url: this._DRIVE_FILE_API + self._fragmentURI,\n        headers: this._AUTH_HEADER\n      }).then(function() {\n        callback(false);\n      }).fail(function() {\n        callback('XooML file: ' + self._fragmentURI + ' not found');\n      });\n    // In this case, we do a search for XooML in the folder\n    } else {\n      var query = 'title = \\'' + XooMLConfig.xooMLFragmentFileName + '\\' and \\'' + self._parentURI + '\\' in parents';\n      var request = this.clientInterface.client.drive.files.list({\n        'maxResults': 1,\n        'q': query\n      });\n      request.execute(function(resp) {\n        // Simply check if there were any results\n        if (resp.items[0]) {\n          callback(false);\n        } else {\n          callback('XooML file not found in directory: ' + self._parentURI);\n        }\n      });\n    }\n  };\n\nmodule.exports = XooMLDriver;"],"sourceRoot":"/source/"}
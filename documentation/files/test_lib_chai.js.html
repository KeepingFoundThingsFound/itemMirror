<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>test/lib/chai.js - ItemMirror</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="ItemMirror"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.8.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/FragmentDriver.html">FragmentDriver</a></li>
            
                <li><a href="../classes/ItemDriver.html">ItemDriver</a></li>
            
                <li><a href="../classes/ItemMirror.html">ItemMirror</a></li>
            
                <li><a href="../classes/XooMLAssociation.html">XooMLAssociation</a></li>
            
                <li><a href="../classes/XooMLConfig.html">XooMLConfig</a></li>
            
                <li><a href="../classes/XooMLDriver.html">XooMLDriver</a></li>
            
                <li><a href="../classes/XooMLExceptions.html">XooMLExceptions</a></li>
            
                <li><a href="../classes/XooMLUtil.html">XooMLUtil</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: test/lib/chai.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
!function (name, context, definition) {
  if (typeof require === &#x27;function&#x27; &amp;&amp; typeof exports === &#x27;object&#x27; &amp;&amp; typeof module === &#x27;object&#x27;) {
    module.exports = definition();
  } else if (typeof define === &#x27;function&#x27; &amp;&amp; typeof define.amd  === &#x27;object&#x27;) {
    define(function () {
      return definition();
    });
  } else {
    context[name] = definition();
  }
}(&#x27;chai&#x27;, this, function () {

  function require(p) {
    var path = require.resolve(p)
      , mod = require.modules[path];
    if (!mod) throw new Error(&#x27;failed to require &quot;&#x27; + p + &#x27;&quot;&#x27;);
    if (!mod.exports) {
      mod.exports = {};
      mod.call(mod.exports, mod, mod.exports, require.relative(path));
    }
    return mod.exports;
  }

  require.modules = {};

  require.resolve = function (path) {
    var orig = path
      , reg = path + &#x27;.js&#x27;
      , index = path + &#x27;/index.js&#x27;;
    return require.modules[reg] &amp;&amp; reg
      || require.modules[index] &amp;&amp; index
      || orig;
  };

  require.register = function (path, fn) {
    require.modules[path] = fn;
  };

  require.relative = function (parent) {
    return function(p){
      if (&#x27;.&#x27; != p.charAt(0)) return require(p);

      var path = parent.split(&#x27;/&#x27;)
        , segs = p.split(&#x27;/&#x27;);
      path.pop();

      for (var i = 0; i &lt; segs.length; i++) {
        var seg = segs[i];
        if (&#x27;..&#x27; == seg) path.pop();
        else if (&#x27;.&#x27; != seg) path.push(seg);
      }

      return require(path.join(&#x27;/&#x27;));
    };
  };

  require.alias = function (from, to) {
    var fn = require.modules[from];
    require.modules[to] = fn;
  };


  require.register(&quot;chai.js&quot;, function(module, exports, require){
    /*!
     * chai
     * Copyright(c) 2011-2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    var used = []
      , exports = module.exports = {};

    /*!
     * Chai version
     */

    exports.version = &#x27;1.4.2&#x27;;

    /*!
     * Primary &#x60;Assertion&#x60; prototype
     */

    exports.Assertion = require(&#x27;./chai/assertion&#x27;);

    /*!
     * Assertion Error
     */

    exports.AssertionError = require(&#x27;./chai/error&#x27;);

    /*!
     * Utils for plugins (not exported)
     */

    var util = require(&#x27;./chai/utils&#x27;);

    /**
     * # .use(function)
     *
     * Provides a way to extend the internals of Chai
     *
     * @param {Function}
     * @returns {this} for chaining
     * @api public
     */

    exports.use = function (fn) {
      if (!~used.indexOf(fn)) {
        fn(this, util);
        used.push(fn);
      }

      return this;
    };

    /*!
     * Core Assertions
     */

    var core = require(&#x27;./chai/core/assertions&#x27;);
    exports.use(core);

    /*!
     * Expect interface
     */

    var expect = require(&#x27;./chai/interface/expect&#x27;);
    exports.use(expect);

    /*!
     * Should interface
     */

    var should = require(&#x27;./chai/interface/should&#x27;);
    exports.use(should);

    /*!
     * Assert interface
     */

    var assert = require(&#x27;./chai/interface/assert&#x27;);
    exports.use(assert);

  }); // module: chai.js

  require.register(&quot;chai/assertion.js&quot;, function(module, exports, require){
    /*!
     * chai
     * http://chaijs.com
     * Copyright(c) 2011-2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    /*!
     * Module dependencies.
     */

    var AssertionError = require(&#x27;./error&#x27;)
      , util = require(&#x27;./utils&#x27;)
      , flag = util.flag;

    /*!
     * Module export.
     */

    module.exports = Assertion;


    /*!
     * Assertion Constructor
     *
     * Creates object for chaining.
     *
     * @api private
     */

    function Assertion (obj, msg, stack) {
      flag(this, &#x27;ssfi&#x27;, stack || arguments.callee);
      flag(this, &#x27;object&#x27;, obj);
      flag(this, &#x27;message&#x27;, msg);
    }

    /*!
      * ### Assertion.includeStack
      *
      * User configurable property, influences whether stack trace
      * is included in Assertion error message. Default of false
      * suppresses stack trace in the error message
      *
      *     Assertion.includeStack = true;  // enable stack on error
      *
      * @api public
      */

    Assertion.includeStack = false;

    Assertion.addProperty = function (name, fn) {
      util.addProperty(this.prototype, name, fn);
    };

    Assertion.addMethod = function (name, fn) {
      util.addMethod(this.prototype, name, fn);
    };

    Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
      util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
    };

    Assertion.overwriteProperty = function (name, fn) {
      util.overwriteProperty(this.prototype, name, fn);
    };

    Assertion.overwriteMethod = function (name, fn) {
      util.overwriteMethod(this.prototype, name, fn);
    };

    /*!
     * ### .assert(expression, message, negateMessage, expected, actual)
     *
     * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn&#x27;t pass.
     *
     * @name assert
     * @param {Philosophical} expression to be tested
     * @param {String} message to display if fails
     * @param {String} negatedMessage to display if negated expression fails
     * @param {Mixed} expected value (remember to check for negation)
     * @param {Mixed} actual (optional) will default to &#x60;this.obj&#x60;
     * @api private
     */

    Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
      var ok = util.test(this, arguments);
      if (true !== showDiff) showDiff = false;

      if (!ok) {
        var msg = util.getMessage(this, arguments)
          , actual = util.getActual(this, arguments);
        throw new AssertionError({
            message: msg
          , actual: actual
          , expected: expected
          , stackStartFunction: (Assertion.includeStack) ? this.assert : flag(this, &#x27;ssfi&#x27;)
          , showDiff: showDiff
        });
      }
    };

    /*!
     * ### ._obj
     *
     * Quick reference to stored &#x60;actual&#x60; value for plugin developers.
     *
     * @api private
     */

    Object.defineProperty(Assertion.prototype, &#x27;_obj&#x27;,
      { get: function () {
          return flag(this, &#x27;object&#x27;);
        }
      , set: function (val) {
          flag(this, &#x27;object&#x27;, val);
        }
    });

  }); // module: chai/assertion.js

  require.register(&quot;chai/core/assertions.js&quot;, function(module, exports, require){
    /*!
     * chai
     * http://chaijs.com
     * Copyright(c) 2011-2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    module.exports = function (chai, _) {
      var Assertion = chai.Assertion
        , toString = Object.prototype.toString
        , flag = _.flag;

      /**
       * ### Language Chains
       *
       * The following are provide as chainable getters to
       * improve the readability of your assertions. They
       * do not provide an testing capability unless they
       * have been overwritten by a plugin.
       *
       * **Chains**
       *
       * - to
       * - be
       * - been
       * - is
       * - that
       * - and
       * - have
       * - with
       * - at
       * - of
       *
       * @name language chains
       * @api public
       */

      [ &#x27;to&#x27;, &#x27;be&#x27;, &#x27;been&#x27;
      , &#x27;is&#x27;, &#x27;and&#x27;, &#x27;have&#x27;
      , &#x27;with&#x27;, &#x27;that&#x27;, &#x27;at&#x27;
      , &#x27;of&#x27; ].forEach(function (chain) {
        Assertion.addProperty(chain, function () {
          return this;
        });
      });

      /**
       * ### .not
       *
       * Negates any of assertions following in the chain.
       *
       *     expect(foo).to.not.equal(&#x27;bar&#x27;);
       *     expect(goodFn).to.not.throw(Error);
       *     expect({ foo: &#x27;baz&#x27; }).to.have.property(&#x27;foo&#x27;)
       *       .and.not.equal(&#x27;bar&#x27;);
       *
       * @name not
       * @api public
       */

      Assertion.addProperty(&#x27;not&#x27;, function () {
        flag(this, &#x27;negate&#x27;, true);
      });

      /**
       * ### .deep
       *
       * Sets the &#x60;deep&#x60; flag, later used by the &#x60;equal&#x60; and
       * &#x60;property&#x60; assertions.
       *
       *     expect(foo).to.deep.equal({ bar: &#x27;baz&#x27; });
       *     expect({ foo: { bar: { baz: &#x27;quux&#x27; } } })
       *       .to.have.deep.property(&#x27;foo.bar.baz&#x27;, &#x27;quux&#x27;);
       *
       * @name deep
       * @api public
       */

      Assertion.addProperty(&#x27;deep&#x27;, function () {
        flag(this, &#x27;deep&#x27;, true);
      });

      /**
       * ### .a(type)
       *
       * The &#x60;a&#x60; and &#x60;an&#x60; assertions are aliases that can be
       * used either as language chains or to assert a value&#x27;s
       * type (as revealed by &#x60;Object.prototype.toString&#x60;).
       *
       *     // typeof
       *     expect(&#x27;test&#x27;).to.be.a(&#x27;string&#x27;);
       *     expect({ foo: &#x27;bar&#x27; }).to.be.an(&#x27;object&#x27;);
       *     expect(null).to.be.a(&#x27;null&#x27;);
       *     expect(undefined).to.be.an(&#x27;undefined&#x27;);
       *
       *     // language chain
       *     expect(foo).to.be.an.instanceof(Foo);
       *
       * @name a
       * @alias an
       * @param {String} type
       * @param {String} message _optional_
       * @api public
       */

      function an(type, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        var obj = flag(this, &#x27;object&#x27;)
          , klassStart = type.charAt(0).toUpperCase()
          , klass = klassStart + type.slice(1)
          , article = ~[ &#x27;A&#x27;, &#x27;E&#x27;, &#x27;I&#x27;, &#x27;O&#x27;, &#x27;U&#x27; ].indexOf(klassStart) ? &#x27;an &#x27; : &#x27;a &#x27;;

        this.assert(
            &#x27;[object &#x27; + klass + &#x27;]&#x27; === toString.call(obj)
          , &#x27;expected #{this} to be &#x27; + article + type
          , &#x27;expected #{this} not to be &#x27; + article + type
        );
      }

      Assertion.addChainableMethod(&#x27;an&#x27;, an);
      Assertion.addChainableMethod(&#x27;a&#x27;, an);

      /**
       * ### .include(value)
       *
       * The &#x60;include&#x60; and &#x60;contain&#x60; assertions can be used as either property
       * based language chains or as methods to assert the inclusion of an object
       * in an array or a substring in a string. When used as language chains,
       * they toggle the &#x60;contain&#x60; flag for the &#x60;keys&#x60; assertion.
       *
       *     expect([1,2,3]).to.include(2);
       *     expect(&#x27;foobar&#x27;).to.contain(&#x27;foo&#x27;);
       *     expect({ foo: &#x27;bar&#x27;, hello: &#x27;universe&#x27; }).to.include.keys(&#x27;foo&#x27;);
       *
       * @name include
       * @alias contain
       * @param {Object|String|Number} obj
       * @param {String} message _optional_
       * @api public
       */

      function includeChainingBehavior () {
        flag(this, &#x27;contains&#x27;, true);
      }

      function include (val, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        var obj = flag(this, &#x27;object&#x27;)
        this.assert(
            ~obj.indexOf(val)
          , &#x27;expected #{this} to include &#x27; + _.inspect(val)
          , &#x27;expected #{this} to not include &#x27; + _.inspect(val));
      }

      Assertion.addChainableMethod(&#x27;include&#x27;, include, includeChainingBehavior);
      Assertion.addChainableMethod(&#x27;contain&#x27;, include, includeChainingBehavior);

      /**
       * ### .ok
       *
       * Asserts that the target is truthy.
       *
       *     expect(&#x27;everthing&#x27;).to.be.ok;
       *     expect(1).to.be.ok;
       *     expect(false).to.not.be.ok;
       *     expect(undefined).to.not.be.ok;
       *     expect(null).to.not.be.ok;
       *
       * @name ok
       * @api public
       */

      Assertion.addProperty(&#x27;ok&#x27;, function () {
        this.assert(
            flag(this, &#x27;object&#x27;)
          , &#x27;expected #{this} to be truthy&#x27;
          , &#x27;expected #{this} to be falsy&#x27;);
      });

      /**
       * ### .true
       *
       * Asserts that the target is &#x60;true&#x60;.
       *
       *     expect(true).to.be.true;
       *     expect(1).to.not.be.true;
       *
       * @name true
       * @api public
       */

      Assertion.addProperty(&#x27;true&#x27;, function () {
        this.assert(
            true === flag(this, &#x27;object&#x27;)
          , &#x27;expected #{this} to be true&#x27;
          , &#x27;expected #{this} to be false&#x27;
          , this.negate ? false : true
        );
      });

      /**
       * ### .false
       *
       * Asserts that the target is &#x60;false&#x60;.
       *
       *     expect(false).to.be.false;
       *     expect(0).to.not.be.false;
       *
       * @name false
       * @api public
       */

      Assertion.addProperty(&#x27;false&#x27;, function () {
        this.assert(
            false === flag(this, &#x27;object&#x27;)
          , &#x27;expected #{this} to be false&#x27;
          , &#x27;expected #{this} to be true&#x27;
          , this.negate ? true : false
        );
      });

      /**
       * ### .null
       *
       * Asserts that the target is &#x60;null&#x60;.
       *
       *     expect(null).to.be.null;
       *     expect(undefined).not.to.be.null;
       *
       * @name null
       * @api public
       */

      Assertion.addProperty(&#x27;null&#x27;, function () {
        this.assert(
            null === flag(this, &#x27;object&#x27;)
          , &#x27;expected #{this} to be null&#x27;
          , &#x27;expected #{this} not to be null&#x27;
        );
      });

      /**
       * ### .undefined
       *
       * Asserts that the target is &#x60;undefined&#x60;.
       *
       *      expect(undefined).to.be.undefined;
       *      expect(null).to.not.be.undefined;
       *
       * @name undefined
       * @api public
       */

      Assertion.addProperty(&#x27;undefined&#x27;, function () {
        this.assert(
            undefined === flag(this, &#x27;object&#x27;)
          , &#x27;expected #{this} to be undefined&#x27;
          , &#x27;expected #{this} not to be undefined&#x27;
        );
      });

      /**
       * ### .exist
       *
       * Asserts that the target is neither &#x60;null&#x60; nor &#x60;undefined&#x60;.
       *
       *     var foo = &#x27;hi&#x27;
       *       , bar = null
       *       , baz;
       *
       *     expect(foo).to.exist;
       *     expect(bar).to.not.exist;
       *     expect(baz).to.not.exist;
       *
       * @name exist
       * @api public
       */

      Assertion.addProperty(&#x27;exist&#x27;, function () {
        this.assert(
            null != flag(this, &#x27;object&#x27;)
          , &#x27;expected #{this} to exist&#x27;
          , &#x27;expected #{this} to not exist&#x27;
        );
      });


      /**
       * ### .empty
       *
       * Asserts that the target&#x27;s length is &#x60;0&#x60;. For arrays, it checks
       * the &#x60;length&#x60; property. For objects, it gets the count of
       * enumerable keys.
       *
       *     expect([]).to.be.empty;
       *     expect(&#x27;&#x27;).to.be.empty;
       *     expect({}).to.be.empty;
       *
       * @name empty
       * @api public
       */

      Assertion.addProperty(&#x27;empty&#x27;, function () {
        var obj = flag(this, &#x27;object&#x27;)
          , expected = obj;

        if (Array.isArray(obj) || &#x27;string&#x27; === typeof object) {
          expected = obj.length;
        } else if (typeof obj === &#x27;object&#x27;) {
          expected = Object.keys(obj).length;
        }

        this.assert(
            !expected
          , &#x27;expected #{this} to be empty&#x27;
          , &#x27;expected #{this} not to be empty&#x27;
        );
      });

      /**
       * ### .arguments
       *
       * Asserts that the target is an arguments object.
       *
       *     function test () {
       *       expect(arguments).to.be.arguments;
       *     }
       *
       * @name arguments
       * @alias Arguments
       * @api public
       */

      function checkArguments () {
        var obj = flag(this, &#x27;object&#x27;)
          , type = Object.prototype.toString.call(obj);
        this.assert(
            &#x27;[object Arguments]&#x27; === type
          , &#x27;expected #{this} to be arguments but got &#x27; + type
          , &#x27;expected #{this} to not be arguments&#x27;
        );
      }

      Assertion.addProperty(&#x27;arguments&#x27;, checkArguments);
      Assertion.addProperty(&#x27;Arguments&#x27;, checkArguments);

      /**
       * ### .equal(value)
       *
       * Asserts that the target is strictly equal (&#x60;===&#x60;) to &#x60;value&#x60;.
       * Alternately, if the &#x60;deep&#x60; flag is set, asserts that
       * the target is deeply equal to &#x60;value&#x60;.
       *
       *     expect(&#x27;hello&#x27;).to.equal(&#x27;hello&#x27;);
       *     expect(42).to.equal(42);
       *     expect(1).to.not.equal(true);
       *     expect({ foo: &#x27;bar&#x27; }).to.not.equal({ foo: &#x27;bar&#x27; });
       *     expect({ foo: &#x27;bar&#x27; }).to.deep.equal({ foo: &#x27;bar&#x27; });
       *
       * @name equal
       * @alias equals
       * @alias eq
       * @alias deep.equal
       * @param {Mixed} value
       * @param {String} message _optional_
       * @api public
       */

      function assertEqual (val, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        var obj = flag(this, &#x27;object&#x27;);
        if (flag(this, &#x27;deep&#x27;)) {
          return this.eql(val);
        } else {
          this.assert(
              val === obj
            , &#x27;expected #{this} to equal #{exp}&#x27;
            , &#x27;expected #{this} to not equal #{exp}&#x27;
            , val
            , this._obj
            , true
          );
        }
      }

      Assertion.addMethod(&#x27;equal&#x27;, assertEqual);
      Assertion.addMethod(&#x27;equals&#x27;, assertEqual);
      Assertion.addMethod(&#x27;eq&#x27;, assertEqual);

      /**
       * ### .eql(value)
       *
       * Asserts that the target is deeply equal to &#x60;value&#x60;.
       *
       *     expect({ foo: &#x27;bar&#x27; }).to.eql({ foo: &#x27;bar&#x27; });
       *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
       *
       * @name eql
       * @param {Mixed} value
       * @param {String} message _optional_
       * @api public
       */

      Assertion.addMethod(&#x27;eql&#x27;, function (obj, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        this.assert(
            _.eql(obj, flag(this, &#x27;object&#x27;))
          , &#x27;expected #{this} to deeply equal #{exp}&#x27;
          , &#x27;expected #{this} to not deeply equal #{exp}&#x27;
          , obj
          , this._obj
          , true
        );
      });

      /**
       * ### .above(value)
       *
       * Asserts that the target is greater than &#x60;value&#x60;.
       *
       *     expect(10).to.be.above(5);
       *
       * Can also be used in conjunction with &#x60;length&#x60; to
       * assert a minimum length. The benefit being a
       * more informative error message than if the length
       * was supplied directly.
       *
       *     expect(&#x27;foo&#x27;).to.have.length.above(2);
       *     expect([ 1, 2, 3 ]).to.have.length.above(2);
       *
       * @name above
       * @alias gt
       * @alias greaterThan
       * @param {Number} value
       * @param {String} message _optional_
       * @api public
       */

      function assertAbove (n, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        var obj = flag(this, &#x27;object&#x27;);
        if (flag(this, &#x27;doLength&#x27;)) {
          new Assertion(obj, msg).to.have.property(&#x27;length&#x27;);
          var len = obj.length;
          this.assert(
              len &gt; n
            , &#x27;expected #{this} to have a length above #{exp} but got #{act}&#x27;
            , &#x27;expected #{this} to not have a length above #{exp}&#x27;
            , n
            , len
          );
        } else {
          this.assert(
              obj &gt; n
            , &#x27;expected #{this} to be above &#x27; + n
            , &#x27;expected #{this} to be at most &#x27; + n
          );
        }
      }

      Assertion.addMethod(&#x27;above&#x27;, assertAbove);
      Assertion.addMethod(&#x27;gt&#x27;, assertAbove);
      Assertion.addMethod(&#x27;greaterThan&#x27;, assertAbove);

      /**
       * ### .least(value)
       *
       * Asserts that the target is greater than or equal to &#x60;value&#x60;.
       *
       *     expect(10).to.be.at.least(10);
       *
       * Can also be used in conjunction with &#x60;length&#x60; to
       * assert a minimum length. The benefit being a
       * more informative error message than if the length
       * was supplied directly.
       *
       *     expect(&#x27;foo&#x27;).to.have.length.of.at.least(2);
       *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
       *
       * @name least
       * @alias gte
       * @param {Number} value
       * @param {String} message _optional_
       * @api public
       */

      function assertLeast (n, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        var obj = flag(this, &#x27;object&#x27;);
        if (flag(this, &#x27;doLength&#x27;)) {
          new Assertion(obj, msg).to.have.property(&#x27;length&#x27;);
          var len = obj.length;
          this.assert(
              len &gt;= n
            , &#x27;expected #{this} to have a length at least #{exp} but got #{act}&#x27;
            , &#x27;expected #{this} to not have a length below #{exp}&#x27;
            , n
            , len
          );
        } else {
          this.assert(
              obj &gt;= n
            , &#x27;expected #{this} to be at least &#x27; + n
            , &#x27;expected #{this} to be below &#x27; + n
          );
        }
      }

      Assertion.addMethod(&#x27;least&#x27;, assertLeast);
      Assertion.addMethod(&#x27;gte&#x27;, assertLeast);

      /**
       * ### .below(value)
       *
       * Asserts that the target is less than &#x60;value&#x60;.
       *
       *     expect(5).to.be.below(10);
       *
       * Can also be used in conjunction with &#x60;length&#x60; to
       * assert a maximum length. The benefit being a
       * more informative error message than if the length
       * was supplied directly.
       *
       *     expect(&#x27;foo&#x27;).to.have.length.below(4);
       *     expect([ 1, 2, 3 ]).to.have.length.below(4);
       *
       * @name below
       * @alias lt
       * @alias lessThan
       * @param {Number} value
       * @param {String} message _optional_
       * @api public
       */

      function assertBelow (n, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        var obj = flag(this, &#x27;object&#x27;);
        if (flag(this, &#x27;doLength&#x27;)) {
          new Assertion(obj, msg).to.have.property(&#x27;length&#x27;);
          var len = obj.length;
          this.assert(
              len &lt; n
            , &#x27;expected #{this} to have a length below #{exp} but got #{act}&#x27;
            , &#x27;expected #{this} to not have a length below #{exp}&#x27;
            , n
            , len
          );
        } else {
          this.assert(
              obj &lt; n
            , &#x27;expected #{this} to be below &#x27; + n
            , &#x27;expected #{this} to be at least &#x27; + n
          );
        }
      }

      Assertion.addMethod(&#x27;below&#x27;, assertBelow);
      Assertion.addMethod(&#x27;lt&#x27;, assertBelow);
      Assertion.addMethod(&#x27;lessThan&#x27;, assertBelow);

      /**
       * ### .most(value)
       *
       * Asserts that the target is less than or equal to &#x60;value&#x60;.
       *
       *     expect(5).to.be.at.most(5);
       *
       * Can also be used in conjunction with &#x60;length&#x60; to
       * assert a maximum length. The benefit being a
       * more informative error message than if the length
       * was supplied directly.
       *
       *     expect(&#x27;foo&#x27;).to.have.length.of.at.most(4);
       *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
       *
       * @name most
       * @alias lte
       * @param {Number} value
       * @param {String} message _optional_
       * @api public
       */

      function assertMost (n, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        var obj = flag(this, &#x27;object&#x27;);
        if (flag(this, &#x27;doLength&#x27;)) {
          new Assertion(obj, msg).to.have.property(&#x27;length&#x27;);
          var len = obj.length;
          this.assert(
              len &lt;= n
            , &#x27;expected #{this} to have a length at most #{exp} but got #{act}&#x27;
            , &#x27;expected #{this} to not have a length above #{exp}&#x27;
            , n
            , len
          );
        } else {
          this.assert(
              obj &lt;= n
            , &#x27;expected #{this} to be at most &#x27; + n
            , &#x27;expected #{this} to be above &#x27; + n
          );
        }
      }

      Assertion.addMethod(&#x27;most&#x27;, assertMost);
      Assertion.addMethod(&#x27;lte&#x27;, assertMost);

      /**
       * ### .within(start, finish)
       *
       * Asserts that the target is within a range.
       *
       *     expect(7).to.be.within(5,10);
       *
       * Can also be used in conjunction with &#x60;length&#x60; to
       * assert a length range. The benefit being a
       * more informative error message than if the length
       * was supplied directly.
       *
       *     expect(&#x27;foo&#x27;).to.have.length.within(2,4);
       *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
       *
       * @name within
       * @param {Number} start lowerbound inclusive
       * @param {Number} finish upperbound inclusive
       * @param {String} message _optional_
       * @api public
       */

      Assertion.addMethod(&#x27;within&#x27;, function (start, finish, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        var obj = flag(this, &#x27;object&#x27;)
          , range = start + &#x27;..&#x27; + finish;
        if (flag(this, &#x27;doLength&#x27;)) {
          new Assertion(obj, msg).to.have.property(&#x27;length&#x27;);
          var len = obj.length;
          this.assert(
              len &gt;= start &amp;&amp; len &lt;= finish
            , &#x27;expected #{this} to have a length within &#x27; + range
            , &#x27;expected #{this} to not have a length within &#x27; + range
          );
        } else {
          this.assert(
              obj &gt;= start &amp;&amp; obj &lt;= finish
            , &#x27;expected #{this} to be within &#x27; + range
            , &#x27;expected #{this} to not be within &#x27; + range
          );
        }
      });

      /**
       * ### .instanceof(constructor)
       *
       * Asserts that the target is an instance of &#x60;constructor&#x60;.
       *
       *     var Tea = function (name) { this.name = name; }
       *       , Chai = new Tea(&#x27;chai&#x27;);
       *
       *     expect(Chai).to.be.an.instanceof(Tea);
       *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
       *
       * @name instanceof
       * @param {Constructor} constructor
       * @param {String} message _optional_
       * @alias instanceOf
       * @api public
       */

      function assertInstanceOf (constructor, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        var name = _.getName(constructor);
        this.assert(
            flag(this, &#x27;object&#x27;) instanceof constructor
          , &#x27;expected #{this} to be an instance of &#x27; + name
          , &#x27;expected #{this} to not be an instance of &#x27; + name
        );
      };

      Assertion.addMethod(&#x27;instanceof&#x27;, assertInstanceOf);
      Assertion.addMethod(&#x27;instanceOf&#x27;, assertInstanceOf);

      /**
       * ### .property(name, [value])
       *
       * Asserts that the target has a property &#x60;name&#x60;, optionally asserting that
       * the value of that property is strictly equal to  &#x60;value&#x60;.
       * If the &#x60;deep&#x60; flag is set, you can use dot- and bracket-notation for deep
       * references into objects and arrays.
       *
       *     // simple referencing
       *     var obj = { foo: &#x27;bar&#x27; };
       *     expect(obj).to.have.property(&#x27;foo&#x27;);
       *     expect(obj).to.have.property(&#x27;foo&#x27;, &#x27;bar&#x27;);
       *
       *     // deep referencing
       *     var deepObj = {
       *         green: { tea: &#x27;matcha&#x27; }
       *       , teas: [ &#x27;chai&#x27;, &#x27;matcha&#x27;, { tea: &#x27;konacha&#x27; } ]
       *     };

       *     expect(deepObj).to.have.deep.property(&#x27;green.tea&#x27;, &#x27;matcha&#x27;);
       *     expect(deepObj).to.have.deep.property(&#x27;teas[1]&#x27;, &#x27;matcha&#x27;);
       *     expect(deepObj).to.have.deep.property(&#x27;teas[2].tea&#x27;, &#x27;konacha&#x27;);
       *
       * You can also use an array as the starting point of a &#x60;deep.property&#x60;
       * assertion, or traverse nested arrays.
       *
       *     var arr = [
       *         [ &#x27;chai&#x27;, &#x27;matcha&#x27;, &#x27;konacha&#x27; ]
       *       , [ { tea: &#x27;chai&#x27; }
       *         , { tea: &#x27;matcha&#x27; }
       *         , { tea: &#x27;konacha&#x27; } ]
       *     ];
       *
       *     expect(arr).to.have.deep.property(&#x27;[0][1]&#x27;, &#x27;matcha&#x27;);
       *     expect(arr).to.have.deep.property(&#x27;[1][2].tea&#x27;, &#x27;konacha&#x27;);
       *
       * Furthermore, &#x60;property&#x60; changes the subject of the assertion
       * to be the value of that property from the original object. This
       * permits for further chainable assertions on that property.
       *
       *     expect(obj).to.have.property(&#x27;foo&#x27;)
       *       .that.is.a(&#x27;string&#x27;);
       *     expect(deepObj).to.have.property(&#x27;green&#x27;)
       *       .that.is.an(&#x27;object&#x27;)
       *       .that.deep.equals({ tea: &#x27;matcha&#x27; });
       *     expect(deepObj).to.have.property(&#x27;teas&#x27;)
       *       .that.is.an(&#x27;array&#x27;)
       *       .with.deep.property(&#x27;[2]&#x27;)
       *         .that.deep.equals({ tea: &#x27;konacha&#x27; });
       *
       * @name property
       * @alias deep.property
       * @param {String} name
       * @param {Mixed} value (optional)
       * @param {String} message _optional_
       * @returns value of property for chaining
       * @api public
       */

      Assertion.addMethod(&#x27;property&#x27;, function (name, val, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);

        var descriptor = flag(this, &#x27;deep&#x27;) ? &#x27;deep property &#x27; : &#x27;property &#x27;
          , negate = flag(this, &#x27;negate&#x27;)
          , obj = flag(this, &#x27;object&#x27;)
          , value = flag(this, &#x27;deep&#x27;)
            ? _.getPathValue(name, obj)
            : obj[name];

        if (negate &amp;&amp; undefined !== val) {
          if (undefined === value) {
            msg = (msg != null) ? msg + &#x27;: &#x27; : &#x27;&#x27;;
            throw new Error(msg + _.inspect(obj) + &#x27; has no &#x27; + descriptor + _.inspect(name));
          }
        } else {
          this.assert(
              undefined !== value
            , &#x27;expected #{this} to have a &#x27; + descriptor + _.inspect(name)
            , &#x27;expected #{this} to not have &#x27; + descriptor + _.inspect(name));
        }

        if (undefined !== val) {
          this.assert(
              val === value
            , &#x27;expected #{this} to have a &#x27; + descriptor + _.inspect(name) + &#x27; of #{exp}, but got #{act}&#x27;
            , &#x27;expected #{this} to not have a &#x27; + descriptor + _.inspect(name) + &#x27; of #{act}&#x27;
            , val
            , value
          );
        }

        flag(this, &#x27;object&#x27;, value);
      });


      /**
       * ### .ownProperty(name)
       *
       * Asserts that the target has an own property &#x60;name&#x60;.
       *
       *     expect(&#x27;test&#x27;).to.have.ownProperty(&#x27;length&#x27;);
       *
       * @name ownProperty
       * @alias haveOwnProperty
       * @param {String} name
       * @param {String} message _optional_
       * @api public
       */

      function assertOwnProperty (name, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        var obj = flag(this, &#x27;object&#x27;);
        this.assert(
            obj.hasOwnProperty(name)
          , &#x27;expected #{this} to have own property &#x27; + _.inspect(name)
          , &#x27;expected #{this} to not have own property &#x27; + _.inspect(name)
        );
      }

      Assertion.addMethod(&#x27;ownProperty&#x27;, assertOwnProperty);
      Assertion.addMethod(&#x27;haveOwnProperty&#x27;, assertOwnProperty);

      /**
       * ### .length(value)
       *
       * Asserts that the target&#x27;s &#x60;length&#x60; property has
       * the expected value.
       *
       *     expect([ 1, 2, 3]).to.have.length(3);
       *     expect(&#x27;foobar&#x27;).to.have.length(6);
       *
       * Can also be used as a chain precursor to a value
       * comparison for the length property.
       *
       *     expect(&#x27;foo&#x27;).to.have.length.above(2);
       *     expect([ 1, 2, 3 ]).to.have.length.above(2);
       *     expect(&#x27;foo&#x27;).to.have.length.below(4);
       *     expect([ 1, 2, 3 ]).to.have.length.below(4);
       *     expect(&#x27;foo&#x27;).to.have.length.within(2,4);
       *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
       *
       * @name length
       * @alias lengthOf
       * @param {Number} length
       * @param {String} message _optional_
       * @api public
       */

      function assertLengthChain () {
        flag(this, &#x27;doLength&#x27;, true);
      }

      function assertLength (n, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        var obj = flag(this, &#x27;object&#x27;);
        new Assertion(obj, msg).to.have.property(&#x27;length&#x27;);
        var len = obj.length;

        this.assert(
            len == n
          , &#x27;expected #{this} to have a length of #{exp} but got #{act}&#x27;
          , &#x27;expected #{this} to not have a length of #{act}&#x27;
          , n
          , len
        );
      }

      Assertion.addChainableMethod(&#x27;length&#x27;, assertLength, assertLengthChain);
      Assertion.addMethod(&#x27;lengthOf&#x27;, assertLength, assertLengthChain);

      /**
       * ### .match(regexp)
       *
       * Asserts that the target matches a regular expression.
       *
       *     expect(&#x27;foobar&#x27;).to.match(/^foo/);
       *
       * @name match
       * @param {RegExp} RegularExpression
       * @param {String} message _optional_
       * @api public
       */

      Assertion.addMethod(&#x27;match&#x27;, function (re, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        var obj = flag(this, &#x27;object&#x27;);
        this.assert(
            re.exec(obj)
          , &#x27;expected #{this} to match &#x27; + re
          , &#x27;expected #{this} not to match &#x27; + re
        );
      });

      /**
       * ### .string(string)
       *
       * Asserts that the string target contains another string.
       *
       *     expect(&#x27;foobar&#x27;).to.have.string(&#x27;bar&#x27;);
       *
       * @name string
       * @param {String} string
       * @param {String} message _optional_
       * @api public
       */

      Assertion.addMethod(&#x27;string&#x27;, function (str, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        var obj = flag(this, &#x27;object&#x27;);
        new Assertion(obj, msg).is.a(&#x27;string&#x27;);

        this.assert(
            ~obj.indexOf(str)
          , &#x27;expected #{this} to contain &#x27; + _.inspect(str)
          , &#x27;expected #{this} to not contain &#x27; + _.inspect(str)
        );
      });


      /**
       * ### .keys(key1, [key2], [...])
       *
       * Asserts that the target has exactly the given keys, or
       * asserts the inclusion of some keys when using the
       * &#x60;include&#x60; or &#x60;contain&#x60; modifiers.
       *
       *     expect({ foo: 1, bar: 2 }).to.have.keys([&#x27;foo&#x27;, &#x27;bar&#x27;]);
       *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys(&#x27;foo&#x27;, &#x27;bar&#x27;);
       *
       * @name keys
       * @alias key
       * @param {String...|Array} keys
       * @api public
       */

      function assertKeys (keys) {
        var obj = flag(this, &#x27;object&#x27;)
          , str
          , ok = true;

        keys = keys instanceof Array
          ? keys
          : Array.prototype.slice.call(arguments);

        if (!keys.length) throw new Error(&#x27;keys required&#x27;);

        var actual = Object.keys(obj)
          , len = keys.length;

        // Inclusion
        ok = keys.every(function(key){
          return ~actual.indexOf(key);
        });

        // Strict
        if (!flag(this, &#x27;negate&#x27;) &amp;&amp; !flag(this, &#x27;contains&#x27;)) {
          ok = ok &amp;&amp; keys.length == actual.length;
        }

        // Key string
        if (len &gt; 1) {
          keys = keys.map(function(key){
            return _.inspect(key);
          });
          var last = keys.pop();
          str = keys.join(&#x27;, &#x27;) + &#x27;, and &#x27; + last;
        } else {
          str = _.inspect(keys[0]);
        }

        // Form
        str = (len &gt; 1 ? &#x27;keys &#x27; : &#x27;key &#x27;) + str;

        // Have / include
        str = (flag(this, &#x27;contains&#x27;) ? &#x27;contain &#x27; : &#x27;have &#x27;) + str;

        // Assertion
        this.assert(
            ok
          , &#x27;expected #{this} to &#x27; + str
          , &#x27;expected #{this} to not &#x27; + str
        );
      }

      Assertion.addMethod(&#x27;keys&#x27;, assertKeys);
      Assertion.addMethod(&#x27;key&#x27;, assertKeys);

      /**
       * ### .throw(constructor)
       *
       * Asserts that the function target will throw a specific error, or specific type of error
       * (as determined using &#x60;instanceof&#x60;), optionally with a RegExp or string inclusion test
       * for the error&#x27;s message.
       *
       *     var err = new ReferenceError(&#x27;This is a bad function.&#x27;);
       *     var fn = function () { throw err; }
       *     expect(fn).to.throw(ReferenceError);
       *     expect(fn).to.throw(Error);
       *     expect(fn).to.throw(/bad function/);
       *     expect(fn).to.not.throw(&#x27;good function&#x27;);
       *     expect(fn).to.throw(ReferenceError, /bad function/);
       *     expect(fn).to.throw(err);
       *     expect(fn).to.not.throw(new RangeError(&#x27;Out of range.&#x27;));
       *
       * Please note that when a throw expectation is negated, it will check each
       * parameter independently, starting with error constructor type. The appropriate way
       * to check for the existence of a type of error but for a message that does not match
       * is to use &#x60;and&#x60;.
       *
       *     expect(fn).to.throw(ReferenceError)
       *        .and.not.throw(/good function/);
       *
       * @name throw
       * @alias throws
       * @alias Throw
       * @param {ErrorConstructor} constructor
       * @param {String|RegExp} expected error message
       * @param {String} message _optional_
       * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
       * @api public
       */

      function assertThrows (constructor, errMsg, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        var obj = flag(this, &#x27;object&#x27;);
        new Assertion(obj, msg).is.a(&#x27;function&#x27;);

        var thrown = false
          , desiredError = null
          , name = null
          , thrownError = null;

        if (arguments.length === 0) {
          errMsg = null;
          constructor = null;
        } else if (constructor &amp;&amp; (constructor instanceof RegExp || &#x27;string&#x27; === typeof constructor)) {
          errMsg = constructor;
          constructor = null;
        } else if (constructor &amp;&amp; constructor instanceof Error) {
          desiredError = constructor;
          constructor = null;
          errMsg = null;
        } else if (typeof constructor === &#x27;function&#x27;) {
          name = (new constructor()).name;
        } else {
          constructor = null;
        }

        try {
          obj();
        } catch (err) {
          // first, check desired error
          if (desiredError) {
            this.assert(
                err === desiredError
              , &#x27;expected #{this} to throw &#x27; + _.inspect(desiredError) + &#x27; but &#x27; + _.inspect(err) + &#x27; was thrown&#x27;
              , &#x27;expected #{this} to not throw &#x27; + _.inspect(desiredError)
            );
            return this;
          }
          // next, check constructor
          if (constructor) {
            this.assert(
                err instanceof constructor
              , &#x27;expected #{this} to throw &#x27; + name + &#x27; but &#x27; + _.inspect(err) + &#x27; was thrown&#x27;
              , &#x27;expected #{this} to not throw &#x27; + name + &#x27; but &#x27; + _.inspect(err) + &#x27; was thrown&#x27;);
            if (!errMsg) return this;
          }
          // next, check message
          if (err.message &amp;&amp; errMsg &amp;&amp; errMsg instanceof RegExp) {
            this.assert(
                errMsg.exec(err.message)
              , &#x27;expected #{this} to throw error matching &#x27; + errMsg + &#x27; but got &#x27; + _.inspect(err.message)
              , &#x27;expected #{this} to throw error not matching &#x27; + errMsg
            );
            return this;
          } else if (err.message &amp;&amp; errMsg &amp;&amp; &#x27;string&#x27; === typeof errMsg) {
            this.assert(
                ~err.message.indexOf(errMsg)
              , &#x27;expected #{this} to throw error including #{exp} but got #{act}&#x27;
              , &#x27;expected #{this} to throw error not including #{act}&#x27;
              , errMsg
              , err.message
            );
            return this;
          } else {
            thrown = true;
            thrownError = err;
          }
        }

        var expectedThrown = name ? name : desiredError ? _.inspect(desiredError) : &#x27;an error&#x27;;
        var actuallyGot = &#x27;&#x27;
        if (thrown) {
          actuallyGot = &#x27; but &#x27; + _.inspect(thrownError) + &#x27; was thrown&#x27;
        }

        this.assert(
            thrown === true
          , &#x27;expected #{this} to throw &#x27; + expectedThrown + actuallyGot
          , &#x27;expected #{this} to not throw &#x27; + expectedThrown + actuallyGot
        );
      };

      Assertion.addMethod(&#x27;throw&#x27;, assertThrows);
      Assertion.addMethod(&#x27;throws&#x27;, assertThrows);
      Assertion.addMethod(&#x27;Throw&#x27;, assertThrows);

      /**
       * ### .respondTo(method)
       *
       * Asserts that the object or class target will respond to a method.
       *
       *     Klass.prototype.bar = function(){};
       *     expect(Klass).to.respondTo(&#x27;bar&#x27;);
       *     expect(obj).to.respondTo(&#x27;bar&#x27;);
       *
       * To check if a constructor will respond to a static function,
       * set the &#x60;itself&#x60; flag.
       *
       *    Klass.baz = function(){};
       *    expect(Klass).itself.to.respondTo(&#x27;baz&#x27;);
       *
       * @name respondTo
       * @param {String} method
       * @param {String} message _optional_
       * @api public
       */

      Assertion.addMethod(&#x27;respondTo&#x27;, function (method, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        var obj = flag(this, &#x27;object&#x27;)
          , itself = flag(this, &#x27;itself&#x27;)
          , context = (&#x27;function&#x27; === typeof obj &amp;&amp; !itself)
            ? obj.prototype[method]
            : obj[method];

        this.assert(
            &#x27;function&#x27; === typeof context
          , &#x27;expected #{this} to respond to &#x27; + _.inspect(method)
          , &#x27;expected #{this} to not respond to &#x27; + _.inspect(method)
        );
      });

      /**
       * ### .itself
       *
       * Sets the &#x60;itself&#x60; flag, later used by the &#x60;respondTo&#x60; assertion.
       *
       *    function Foo() {}
       *    Foo.bar = function() {}
       *    Foo.prototype.baz = function() {}
       *
       *    expect(Foo).itself.to.respondTo(&#x27;bar&#x27;);
       *    expect(Foo).itself.not.to.respondTo(&#x27;baz&#x27;);
       *
       * @name itself
       * @api public
       */

      Assertion.addProperty(&#x27;itself&#x27;, function () {
        flag(this, &#x27;itself&#x27;, true);
      });

      /**
       * ### .satisfy(method)
       *
       * Asserts that the target passes a given truth test.
       *
       *     expect(1).to.satisfy(function(num) { return num &gt; 0; });
       *
       * @name satisfy
       * @param {Function} matcher
       * @param {String} message _optional_
       * @api public
       */

      Assertion.addMethod(&#x27;satisfy&#x27;, function (matcher, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        var obj = flag(this, &#x27;object&#x27;);
        this.assert(
            matcher(obj)
          , &#x27;expected #{this} to satisfy &#x27; + _.inspect(matcher)
          , &#x27;expected #{this} to not satisfy&#x27; + _.inspect(matcher)
          , this.negate ? false : true
          , matcher(obj)
        );
      });

      /**
       * ### .closeTo(expected, delta)
       *
       * Asserts that the target is equal &#x60;expected&#x60;, to within a +/- &#x60;delta&#x60; range.
       *
       *     expect(1.5).to.be.closeTo(1, 0.5);
       *
       * @name closeTo
       * @param {Number} expected
       * @param {Number} delta
       * @param {String} message _optional_
       * @api public
       */

      Assertion.addMethod(&#x27;closeTo&#x27;, function (expected, delta, msg) {
        if (msg) flag(this, &#x27;message&#x27;, msg);
        var obj = flag(this, &#x27;object&#x27;);
        this.assert(
            Math.abs(obj - expected) &lt;= delta
          , &#x27;expected #{this} to be close to &#x27; + expected + &#x27; +/- &#x27; + delta
          , &#x27;expected #{this} not to be close to &#x27; + expected + &#x27; +/- &#x27; + delta
        );
      });

    };

  }); // module: chai/core/assertions.js

  require.register(&quot;chai/error.js&quot;, function(module, exports, require){
    /*!
     * chai
     * Copyright(c) 2011-2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    /*!
     * Main export
     */

    module.exports = AssertionError;

    /**
     * # AssertionError (constructor)
     *
     * Create a new assertion error based on the Javascript
     * &#x60;Error&#x60; prototype.
     *
     * **Options**
     * - message
     * - actual
     * - expected
     * - operator
     * - startStackFunction
     *
     * @param {Object} options
     * @api public
     */

    function AssertionError (options) {
      options = options || {};
      this.message = options.message;
      this.actual = options.actual;
      this.expected = options.expected;
      this.operator = options.operator;
      this.showDiff = options.showDiff;

      if (options.stackStartFunction &amp;&amp; Error.captureStackTrace) {
        var stackStartFunction = options.stackStartFunction;
        Error.captureStackTrace(this, stackStartFunction);
      }
    }

    /*!
     * Inherit from Error
     */

    AssertionError.prototype = Object.create(Error.prototype);
    AssertionError.prototype.name = &#x27;AssertionError&#x27;;
    AssertionError.prototype.constructor = AssertionError;

    /**
     * # toString()
     *
     * Override default to string method
     */

    AssertionError.prototype.toString = function() {
      return this.message;
    };

  }); // module: chai/error.js

  require.register(&quot;chai/interface/assert.js&quot;, function(module, exports, require){
    /*!
     * chai
     * Copyright(c) 2011-2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */


    module.exports = function (chai, util) {

      /*!
       * Chai dependencies.
       */

      var Assertion = chai.Assertion
        , flag = util.flag;

      /*!
       * Module export.
       */

      /**
       * ### assert(expression, message)
       *
       * Write your own test expressions.
       *
       *     assert(&#x27;foo&#x27; !== &#x27;bar&#x27;, &#x27;foo is not bar&#x27;);
       *     assert(Array.isArray([]), &#x27;empty arrays are arrays&#x27;);
       *
       * @param {Mixed} expression to test for truthiness
       * @param {String} message to display on error
       * @name assert
       * @api public
       */

      var assert = chai.assert = function (express, errmsg) {
        var test = new Assertion(null);
        test.assert(
            express
          , errmsg
          , &#x27;[ negation message unavailable ]&#x27;
        );
      };

      /**
       * ### .fail(actual, expected, [message], [operator])
       *
       * Throw a failure. Node.js &#x60;assert&#x60; module-compatible.
       *
       * @name fail
       * @param {Mixed} actual
       * @param {Mixed} expected
       * @param {String} message
       * @param {String} operator
       * @api public
       */

      assert.fail = function (actual, expected, message, operator) {
        throw new chai.AssertionError({
            actual: actual
          , expected: expected
          , message: message
          , operator: operator
          , stackStartFunction: assert.fail
        });
      };

      /**
       * ### .ok(object, [message])
       *
       * Asserts that &#x60;object&#x60; is truthy.
       *
       *     assert.ok(&#x27;everything&#x27;, &#x27;everything is ok&#x27;);
       *     assert.ok(false, &#x27;this will fail&#x27;);
       *
       * @name ok
       * @param {Mixed} object to test
       * @param {String} message
       * @api public
       */

      assert.ok = function (val, msg) {
        new Assertion(val, msg).is.ok;
      };

      /**
       * ### .equal(actual, expected, [message])
       *
       * Asserts non-strict equality (&#x60;==&#x60;) of &#x60;actual&#x60; and &#x60;expected&#x60;.
       *
       *     assert.equal(3, &#x27;3&#x27;, &#x27;== coerces values to strings&#x27;);
       *
       * @name equal
       * @param {Mixed} actual
       * @param {Mixed} expected
       * @param {String} message
       * @api public
       */

      assert.equal = function (act, exp, msg) {
        var test = new Assertion(act, msg);

        test.assert(
            exp == flag(test, &#x27;object&#x27;)
          , &#x27;expected #{this} to equal #{exp}&#x27;
          , &#x27;expected #{this} to not equal #{act}&#x27;
          , exp
          , act
        );
      };

      /**
       * ### .notEqual(actual, expected, [message])
       *
       * Asserts non-strict inequality (&#x60;!=&#x60;) of &#x60;actual&#x60; and &#x60;expected&#x60;.
       *
       *     assert.notEqual(3, 4, &#x27;these numbers are not equal&#x27;);
       *
       * @name notEqual
       * @param {Mixed} actual
       * @param {Mixed} expected
       * @param {String} message
       * @api public
       */

      assert.notEqual = function (act, exp, msg) {
        var test = new Assertion(act, msg);

        test.assert(
            exp != flag(test, &#x27;object&#x27;)
          , &#x27;expected #{this} to not equal #{exp}&#x27;
          , &#x27;expected #{this} to equal #{act}&#x27;
          , exp
          , act
        );
      };

      /**
       * ### .strictEqual(actual, expected, [message])
       *
       * Asserts strict equality (&#x60;===&#x60;) of &#x60;actual&#x60; and &#x60;expected&#x60;.
       *
       *     assert.strictEqual(true, true, &#x27;these booleans are strictly equal&#x27;);
       *
       * @name strictEqual
       * @param {Mixed} actual
       * @param {Mixed} expected
       * @param {String} message
       * @api public
       */

      assert.strictEqual = function (act, exp, msg) {
        new Assertion(act, msg).to.equal(exp);
      };

      /**
       * ### .notStrictEqual(actual, expected, [message])
       *
       * Asserts strict inequality (&#x60;!==&#x60;) of &#x60;actual&#x60; and &#x60;expected&#x60;.
       *
       *     assert.notStrictEqual(3, &#x27;3&#x27;, &#x27;no coercion for strict equality&#x27;);
       *
       * @name notStrictEqual
       * @param {Mixed} actual
       * @param {Mixed} expected
       * @param {String} message
       * @api public
       */

      assert.notStrictEqual = function (act, exp, msg) {
        new Assertion(act, msg).to.not.equal(exp);
      };

      /**
       * ### .deepEqual(actual, expected, [message])
       *
       * Asserts that &#x60;actual&#x60; is deeply equal to &#x60;expected&#x60;.
       *
       *     assert.deepEqual({ tea: &#x27;green&#x27; }, { tea: &#x27;green&#x27; });
       *
       * @name deepEqual
       * @param {Mixed} actual
       * @param {Mixed} expected
       * @param {String} message
       * @api public
       */

      assert.deepEqual = function (act, exp, msg) {
        new Assertion(act, msg).to.eql(exp);
      };

      /**
       * ### .notDeepEqual(actual, expected, [message])
       *
       * Assert that &#x60;actual&#x60; is not deeply equal to &#x60;expected&#x60;.
       *
       *     assert.notDeepEqual({ tea: &#x27;green&#x27; }, { tea: &#x27;jasmine&#x27; });
       *
       * @name notDeepEqual
       * @param {Mixed} actual
       * @param {Mixed} expected
       * @param {String} message
       * @api public
       */

      assert.notDeepEqual = function (act, exp, msg) {
        new Assertion(act, msg).to.not.eql(exp);
      };

      /**
       * ### .isTrue(value, [message])
       *
       * Asserts that &#x60;value&#x60; is true.
       *
       *     var teaServed = true;
       *     assert.isTrue(teaServed, &#x27;the tea has been served&#x27;);
       *
       * @name isTrue
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.isTrue = function (val, msg) {
        new Assertion(val, msg).is[&#x27;true&#x27;];
      };

      /**
       * ### .isFalse(value, [message])
       *
       * Asserts that &#x60;value&#x60; is false.
       *
       *     var teaServed = false;
       *     assert.isFalse(teaServed, &#x27;no tea yet? hmm...&#x27;);
       *
       * @name isFalse
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.isFalse = function (val, msg) {
        new Assertion(val, msg).is[&#x27;false&#x27;];
      };

      /**
       * ### .isNull(value, [message])
       *
       * Asserts that &#x60;value&#x60; is null.
       *
       *     assert.isNull(err, &#x27;there was no error&#x27;);
       *
       * @name isNull
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.isNull = function (val, msg) {
        new Assertion(val, msg).to.equal(null);
      };

      /**
       * ### .isNotNull(value, [message])
       *
       * Asserts that &#x60;value&#x60; is not null.
       *
       *     var tea = &#x27;tasty chai&#x27;;
       *     assert.isNotNull(tea, &#x27;great, time for tea!&#x27;);
       *
       * @name isNotNull
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.isNotNull = function (val, msg) {
        new Assertion(val, msg).to.not.equal(null);
      };

      /**
       * ### .isUndefined(value, [message])
       *
       * Asserts that &#x60;value&#x60; is &#x60;undefined&#x60;.
       *
       *     var tea;
       *     assert.isUndefined(tea, &#x27;no tea defined&#x27;);
       *
       * @name isUndefined
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.isUndefined = function (val, msg) {
        new Assertion(val, msg).to.equal(undefined);
      };

      /**
       * ### .isDefined(value, [message])
       *
       * Asserts that &#x60;value&#x60; is not &#x60;undefined&#x60;.
       *
       *     var tea = &#x27;cup of chai&#x27;;
       *     assert.isDefined(tea, &#x27;tea has been defined&#x27;);
       *
       * @name isUndefined
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.isDefined = function (val, msg) {
        new Assertion(val, msg).to.not.equal(undefined);
      };

      /**
       * ### .isFunction(value, [message])
       *
       * Asserts that &#x60;value&#x60; is a function.
       *
       *     function serveTea() { return &#x27;cup of tea&#x27;; };
       *     assert.isFunction(serveTea, &#x27;great, we can have tea now&#x27;);
       *
       * @name isFunction
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.isFunction = function (val, msg) {
        new Assertion(val, msg).to.be.a(&#x27;function&#x27;);
      };

      /**
       * ### .isNotFunction(value, [message])
       *
       * Asserts that &#x60;value&#x60; is _not_ a function.
       *
       *     var serveTea = [ &#x27;heat&#x27;, &#x27;pour&#x27;, &#x27;sip&#x27; ];
       *     assert.isNotFunction(serveTea, &#x27;great, we have listed the steps&#x27;);
       *
       * @name isNotFunction
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.isNotFunction = function (val, msg) {
        new Assertion(val, msg).to.not.be.a(&#x27;function&#x27;);
      };

      /**
       * ### .isObject(value, [message])
       *
       * Asserts that &#x60;value&#x60; is an object (as revealed by
       * &#x60;Object.prototype.toString&#x60;).
       *
       *     var selection = { name: &#x27;Chai&#x27;, serve: &#x27;with spices&#x27; };
       *     assert.isObject(selection, &#x27;tea selection is an object&#x27;);
       *
       * @name isObject
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.isObject = function (val, msg) {
        new Assertion(val, msg).to.be.a(&#x27;object&#x27;);
      };

      /**
       * ### .isNotObject(value, [message])
       *
       * Asserts that &#x60;value&#x60; is _not_ an object.
       *
       *     var selection = &#x27;chai&#x27;
       *     assert.isObject(selection, &#x27;tea selection is not an object&#x27;);
       *     assert.isObject(null, &#x27;null is not an object&#x27;);
       *
       * @name isNotObject
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.isNotObject = function (val, msg) {
        new Assertion(val, msg).to.not.be.a(&#x27;object&#x27;);
      };

      /**
       * ### .isArray(value, [message])
       *
       * Asserts that &#x60;value&#x60; is an array.
       *
       *     var menu = [ &#x27;green&#x27;, &#x27;chai&#x27;, &#x27;oolong&#x27; ];
       *     assert.isArray(menu, &#x27;what kind of tea do we want?&#x27;);
       *
       * @name isArray
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.isArray = function (val, msg) {
        new Assertion(val, msg).to.be.an(&#x27;array&#x27;);
      };

      /**
       * ### .isNotArray(value, [message])
       *
       * Asserts that &#x60;value&#x60; is _not_ an array.
       *
       *     var menu = &#x27;green|chai|oolong&#x27;;
       *     assert.isNotArray(menu, &#x27;what kind of tea do we want?&#x27;);
       *
       * @name isNotArray
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.isNotArray = function (val, msg) {
        new Assertion(val, msg).to.not.be.an(&#x27;array&#x27;);
      };

      /**
       * ### .isString(value, [message])
       *
       * Asserts that &#x60;value&#x60; is a string.
       *
       *     var teaOrder = &#x27;chai&#x27;;
       *     assert.isString(teaOrder, &#x27;order placed&#x27;);
       *
       * @name isString
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.isString = function (val, msg) {
        new Assertion(val, msg).to.be.a(&#x27;string&#x27;);
      };

      /**
       * ### .isNotString(value, [message])
       *
       * Asserts that &#x60;value&#x60; is _not_ a string.
       *
       *     var teaOrder = 4;
       *     assert.isNotString(teaOrder, &#x27;order placed&#x27;);
       *
       * @name isNotString
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.isNotString = function (val, msg) {
        new Assertion(val, msg).to.not.be.a(&#x27;string&#x27;);
      };

      /**
       * ### .isNumber(value, [message])
       *
       * Asserts that &#x60;value&#x60; is a number.
       *
       *     var cups = 2;
       *     assert.isNumber(cups, &#x27;how many cups&#x27;);
       *
       * @name isNumber
       * @param {Number} value
       * @param {String} message
       * @api public
       */

      assert.isNumber = function (val, msg) {
        new Assertion(val, msg).to.be.a(&#x27;number&#x27;);
      };

      /**
       * ### .isNotNumber(value, [message])
       *
       * Asserts that &#x60;value&#x60; is _not_ a number.
       *
       *     var cups = &#x27;2 cups please&#x27;;
       *     assert.isNotNumber(cups, &#x27;how many cups&#x27;);
       *
       * @name isNotNumber
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.isNotNumber = function (val, msg) {
        new Assertion(val, msg).to.not.be.a(&#x27;number&#x27;);
      };

      /**
       * ### .isBoolean(value, [message])
       *
       * Asserts that &#x60;value&#x60; is a boolean.
       *
       *     var teaReady = true
       *       , teaServed = false;
       *
       *     assert.isBoolean(teaReady, &#x27;is the tea ready&#x27;);
       *     assert.isBoolean(teaServed, &#x27;has tea been served&#x27;);
       *
       * @name isBoolean
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.isBoolean = function (val, msg) {
        new Assertion(val, msg).to.be.a(&#x27;boolean&#x27;);
      };

      /**
       * ### .isNotBoolean(value, [message])
       *
       * Asserts that &#x60;value&#x60; is _not_ a boolean.
       *
       *     var teaReady = &#x27;yep&#x27;
       *       , teaServed = &#x27;nope&#x27;;
       *
       *     assert.isNotBoolean(teaReady, &#x27;is the tea ready&#x27;);
       *     assert.isNotBoolean(teaServed, &#x27;has tea been served&#x27;);
       *
       * @name isNotBoolean
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.isNotBoolean = function (val, msg) {
        new Assertion(val, msg).to.not.be.a(&#x27;boolean&#x27;);
      };

      /**
       * ### .typeOf(value, name, [message])
       *
       * Asserts that &#x60;value&#x60;&#x27;s type is &#x60;name&#x60;, as determined by
       * &#x60;Object.prototype.toString&#x60;.
       *
       *     assert.typeOf({ tea: &#x27;chai&#x27; }, &#x27;object&#x27;, &#x27;we have an object&#x27;);
       *     assert.typeOf([&#x27;chai&#x27;, &#x27;jasmine&#x27;], &#x27;array&#x27;, &#x27;we have an array&#x27;);
       *     assert.typeOf(&#x27;tea&#x27;, &#x27;string&#x27;, &#x27;we have a string&#x27;);
       *     assert.typeOf(/tea/, &#x27;regexp&#x27;, &#x27;we have a regular expression&#x27;);
       *     assert.typeOf(null, &#x27;null&#x27;, &#x27;we have a null&#x27;);
       *     assert.typeOf(undefined, &#x27;undefined&#x27;, &#x27;we have an undefined&#x27;);
       *
       * @name typeOf
       * @param {Mixed} value
       * @param {String} name
       * @param {String} message
       * @api public
       */

      assert.typeOf = function (val, type, msg) {
        new Assertion(val, msg).to.be.a(type);
      };

      /**
       * ### .notTypeOf(value, name, [message])
       *
       * Asserts that &#x60;value&#x60;&#x27;s type is _not_ &#x60;name&#x60;, as determined by
       * &#x60;Object.prototype.toString&#x60;.
       *
       *     assert.notTypeOf(&#x27;tea&#x27;, &#x27;number&#x27;, &#x27;strings are not numbers&#x27;);
       *
       * @name notTypeOf
       * @param {Mixed} value
       * @param {String} typeof name
       * @param {String} message
       * @api public
       */

      assert.notTypeOf = function (val, type, msg) {
        new Assertion(val, msg).to.not.be.a(type);
      };

      /**
       * ### .instanceOf(object, constructor, [message])
       *
       * Asserts that &#x60;value&#x60; is an instance of &#x60;constructor&#x60;.
       *
       *     var Tea = function (name) { this.name = name; }
       *       , chai = new Tea(&#x27;chai&#x27;);
       *
       *     assert.instanceOf(chai, Tea, &#x27;chai is an instance of tea&#x27;);
       *
       * @name instanceOf
       * @param {Object} object
       * @param {Constructor} constructor
       * @param {String} message
       * @api public
       */

      assert.instanceOf = function (val, type, msg) {
        new Assertion(val, msg).to.be.instanceOf(type);
      };

      /**
       * ### .notInstanceOf(object, constructor, [message])
       *
       * Asserts &#x60;value&#x60; is not an instance of &#x60;constructor&#x60;.
       *
       *     var Tea = function (name) { this.name = name; }
       *       , chai = new String(&#x27;chai&#x27;);
       *
       *     assert.notInstanceOf(chai, Tea, &#x27;chai is not an instance of tea&#x27;);
       *
       * @name notInstanceOf
       * @param {Object} object
       * @param {Constructor} constructor
       * @param {String} message
       * @api public
       */

      assert.notInstanceOf = function (val, type, msg) {
        new Assertion(val, msg).to.not.be.instanceOf(type);
      };

      /**
       * ### .include(haystack, needle, [message])
       *
       * Asserts that &#x60;haystack&#x60; includes &#x60;needle&#x60;. Works
       * for strings and arrays.
       *
       *     assert.include(&#x27;foobar&#x27;, &#x27;bar&#x27;, &#x27;foobar contains string &quot;bar&quot;&#x27;);
       *     assert.include([ 1, 2, 3 ], 3, &#x27;array contains value&#x27;);
       *
       * @name include
       * @param {Array|String} haystack
       * @param {Mixed} needle
       * @param {String} message
       * @api public
       */

      assert.include = function (exp, inc, msg) {
        var obj = new Assertion(exp, msg);

        if (Array.isArray(exp)) {
          obj.to.include(inc);
        } else if (&#x27;string&#x27; === typeof exp) {
          obj.to.contain.string(inc);
        }
      };

      /**
       * ### .match(value, regexp, [message])
       *
       * Asserts that &#x60;value&#x60; matches the regular expression &#x60;regexp&#x60;.
       *
       *     assert.match(&#x27;foobar&#x27;, /^foo/, &#x27;regexp matches&#x27;);
       *
       * @name match
       * @param {Mixed} value
       * @param {RegExp} regexp
       * @param {String} message
       * @api public
       */

      assert.match = function (exp, re, msg) {
        new Assertion(exp, msg).to.match(re);
      };

      /**
       * ### .notMatch(value, regexp, [message])
       *
       * Asserts that &#x60;value&#x60; does not match the regular expression &#x60;regexp&#x60;.
       *
       *     assert.notMatch(&#x27;foobar&#x27;, /^foo/, &#x27;regexp does not match&#x27;);
       *
       * @name notMatch
       * @param {Mixed} value
       * @param {RegExp} regexp
       * @param {String} message
       * @api public
       */

      assert.notMatch = function (exp, re, msg) {
        new Assertion(exp, msg).to.not.match(re);
      };

      /**
       * ### .property(object, property, [message])
       *
       * Asserts that &#x60;object&#x60; has a property named by &#x60;property&#x60;.
       *
       *     assert.property({ tea: { green: &#x27;matcha&#x27; }}, &#x27;tea&#x27;);
       *
       * @name property
       * @param {Object} object
       * @param {String} property
       * @param {String} message
       * @api public
       */

      assert.property = function (obj, prop, msg) {
        new Assertion(obj, msg).to.have.property(prop);
      };

      /**
       * ### .notProperty(object, property, [message])
       *
       * Asserts that &#x60;object&#x60; does _not_ have a property named by &#x60;property&#x60;.
       *
       *     assert.notProperty({ tea: { green: &#x27;matcha&#x27; }}, &#x27;coffee&#x27;);
       *
       * @name notProperty
       * @param {Object} object
       * @param {String} property
       * @param {String} message
       * @api public
       */

      assert.notProperty = function (obj, prop, msg) {
        new Assertion(obj, msg).to.not.have.property(prop);
      };

      /**
       * ### .deepProperty(object, property, [message])
       *
       * Asserts that &#x60;object&#x60; has a property named by &#x60;property&#x60;, which can be a
       * string using dot- and bracket-notation for deep reference.
       *
       *     assert.deepProperty({ tea: { green: &#x27;matcha&#x27; }}, &#x27;tea.green&#x27;);
       *
       * @name deepProperty
       * @param {Object} object
       * @param {String} property
       * @param {String} message
       * @api public
       */

      assert.deepProperty = function (obj, prop, msg) {
        new Assertion(obj, msg).to.have.deep.property(prop);
      };

      /**
       * ### .notDeepProperty(object, property, [message])
       *
       * Asserts that &#x60;object&#x60; does _not_ have a property named by &#x60;property&#x60;, which
       * can be a string using dot- and bracket-notation for deep reference.
       *
       *     assert.notDeepProperty({ tea: { green: &#x27;matcha&#x27; }}, &#x27;tea.oolong&#x27;);
       *
       * @name notDeepProperty
       * @param {Object} object
       * @param {String} property
       * @param {String} message
       * @api public
       */

      assert.notDeepProperty = function (obj, prop, msg) {
        new Assertion(obj, msg).to.not.have.deep.property(prop);
      };

      /**
       * ### .propertyVal(object, property, value, [message])
       *
       * Asserts that &#x60;object&#x60; has a property named by &#x60;property&#x60; with value given
       * by &#x60;value&#x60;.
       *
       *     assert.propertyVal({ tea: &#x27;is good&#x27; }, &#x27;tea&#x27;, &#x27;is good&#x27;);
       *
       * @name propertyVal
       * @param {Object} object
       * @param {String} property
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.propertyVal = function (obj, prop, val, msg) {
        new Assertion(obj, msg).to.have.property(prop, val);
      };

      /**
       * ### .propertyNotVal(object, property, value, [message])
       *
       * Asserts that &#x60;object&#x60; has a property named by &#x60;property&#x60;, but with a value
       * different from that given by &#x60;value&#x60;.
       *
       *     assert.propertyNotVal({ tea: &#x27;is good&#x27; }, &#x27;tea&#x27;, &#x27;is bad&#x27;);
       *
       * @name propertyNotVal
       * @param {Object} object
       * @param {String} property
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.propertyNotVal = function (obj, prop, val, msg) {
        new Assertion(obj, msg).to.not.have.property(prop, val);
      };

      /**
       * ### .deepPropertyVal(object, property, value, [message])
       *
       * Asserts that &#x60;object&#x60; has a property named by &#x60;property&#x60; with value given
       * by &#x60;value&#x60;. &#x60;property&#x60; can use dot- and bracket-notation for deep
       * reference.
       *
       *     assert.deepPropertyVal({ tea: { green: &#x27;matcha&#x27; }}, &#x27;tea.green&#x27;, &#x27;matcha&#x27;);
       *
       * @name deepPropertyVal
       * @param {Object} object
       * @param {String} property
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.deepPropertyVal = function (obj, prop, val, msg) {
        new Assertion(obj, msg).to.have.deep.property(prop, val);
      };

      /**
       * ### .deepPropertyNotVal(object, property, value, [message])
       *
       * Asserts that &#x60;object&#x60; has a property named by &#x60;property&#x60;, but with a value
       * different from that given by &#x60;value&#x60;. &#x60;property&#x60; can use dot- and
       * bracket-notation for deep reference.
       *
       *     assert.deepPropertyNotVal({ tea: { green: &#x27;matcha&#x27; }}, &#x27;tea.green&#x27;, &#x27;konacha&#x27;);
       *
       * @name deepPropertyNotVal
       * @param {Object} object
       * @param {String} property
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert.deepPropertyNotVal = function (obj, prop, val, msg) {
        new Assertion(obj, msg).to.not.have.deep.property(prop, val);
      };

      /**
       * ### .lengthOf(object, length, [message])
       *
       * Asserts that &#x60;object&#x60; has a &#x60;length&#x60; property with the expected value.
       *
       *     assert.lengthOf([1,2,3], 3, &#x27;array has length of 3&#x27;);
       *     assert.lengthOf(&#x27;foobar&#x27;, 5, &#x27;string has length of 6&#x27;);
       *
       * @name lengthOf
       * @param {Mixed} object
       * @param {Number} length
       * @param {String} message
       * @api public
       */

      assert.lengthOf = function (exp, len, msg) {
        new Assertion(exp, msg).to.have.length(len);
      };

      /**
       * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
       *
       * Asserts that &#x60;function&#x60; will throw an error that is an instance of
       * &#x60;constructor&#x60;, or alternately that it will throw an error with message
       * matching &#x60;regexp&#x60;.
       *
       *     assert.throw(fn, &#x27;function throws a reference error&#x27;);
       *     assert.throw(fn, /function throws a reference error/);
       *     assert.throw(fn, ReferenceError);
       *     assert.throw(fn, ReferenceError, &#x27;function throws a reference error&#x27;);
       *     assert.throw(fn, ReferenceError, /function throws a reference error/);
       *
       * @name throws
       * @alias throw
       * @alias Throw
       * @param {Function} function
       * @param {ErrorConstructor} constructor
       * @param {RegExp} regexp
       * @param {String} message
       * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
       * @api public
       */

      assert.Throw = function (fn, errt, errs, msg) {
        if (&#x27;string&#x27; === typeof errt || errt instanceof RegExp) {
          errs = errt;
          errt = null;
        }

        new Assertion(fn, msg).to.Throw(errt, errs);
      };

      /**
       * ### .doesNotThrow(function, [constructor/regexp], [message])
       *
       * Asserts that &#x60;function&#x60; will _not_ throw an error that is an instance of
       * &#x60;constructor&#x60;, or alternately that it will not throw an error with message
       * matching &#x60;regexp&#x60;.
       *
       *     assert.doesNotThrow(fn, Error, &#x27;function does not throw&#x27;);
       *
       * @name doesNotThrow
       * @param {Function} function
       * @param {ErrorConstructor} constructor
       * @param {RegExp} regexp
       * @param {String} message
       * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
       * @api public
       */

      assert.doesNotThrow = function (fn, type, msg) {
        if (&#x27;string&#x27; === typeof type) {
          msg = type;
          type = null;
        }

        new Assertion(fn, msg).to.not.Throw(type);
      };

      /**
       * ### .operator(val1, operator, val2, [message])
       *
       * Compares two values using &#x60;operator&#x60;.
       *
       *     assert.operator(1, &#x27;&lt;&#x27;, 2, &#x27;everything is ok&#x27;);
       *     assert.operator(1, &#x27;&gt;&#x27;, 2, &#x27;this will fail&#x27;);
       *
       * @name operator
       * @param {Mixed} val1
       * @param {String} operator
       * @param {Mixed} val2
       * @param {String} message
       * @api public
       */

      assert.operator = function (val, operator, val2, msg) {
        if (!~[&#x27;==&#x27;, &#x27;===&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;=&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;=&#x27;, &#x27;!=&#x27;, &#x27;!==&#x27;].indexOf(operator)) {
          throw new Error(&#x27;Invalid operator &quot;&#x27; + operator + &#x27;&quot;&#x27;);
        }
        var test = new Assertion(eval(val + operator + val2), msg);
        test.assert(
            true === flag(test, &#x27;object&#x27;)
          , &#x27;expected &#x27; + util.inspect(val) + &#x27; to be &#x27; + operator + &#x27; &#x27; + util.inspect(val2)
          , &#x27;expected &#x27; + util.inspect(val) + &#x27; to not be &#x27; + operator + &#x27; &#x27; + util.inspect(val2) );
      };

      /**
       * ### .closeTo(actual, expected, delta, [message])
       *
       * Asserts that the target is equal &#x60;expected&#x60;, to within a +/- &#x60;delta&#x60; range.
       *
       *     assert.closeTo(1.5, 1, 0.5, &#x27;numbers are close&#x27;);
       *
       * @name closeTo
       * @param {Number} actual
       * @param {Number} expected
       * @param {Number} delta
       * @param {String} message
       * @api public
       */

      assert.closeTo = function (act, exp, delta, msg) {
        new Assertion(act, msg).to.be.closeTo(exp, delta);
      };

      /*!
       * Undocumented / untested
       */

      assert.ifError = function (val, msg) {
        new Assertion(val, msg).to.not.be.ok;
      };

      /*!
       * Aliases.
       */

      (function alias(name, as){
        assert[as] = assert[name];
        return alias;
      })
      (&#x27;Throw&#x27;, &#x27;throw&#x27;)
      (&#x27;Throw&#x27;, &#x27;throws&#x27;);
    };

  }); // module: chai/interface/assert.js

  require.register(&quot;chai/interface/expect.js&quot;, function(module, exports, require){
    /*!
     * chai
     * Copyright(c) 2011-2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    module.exports = function (chai, util) {
      chai.expect = function (val, message) {
        return new chai.Assertion(val, message);
      };
    };


  }); // module: chai/interface/expect.js

  require.register(&quot;chai/interface/should.js&quot;, function(module, exports, require){
    /*!
     * chai
     * Copyright(c) 2011-2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    module.exports = function (chai, util) {
      var Assertion = chai.Assertion;

      function loadShould () {
        // modify Object.prototype to have &#x60;should&#x60;
        Object.defineProperty(Object.prototype, &#x27;should&#x27;,
          {
            set: function (value) {
              // See https://github.com/chaijs/chai/issues/86: this makes
              // &#x60;whatever.should = someValue&#x60; actually set &#x60;someValue&#x60;, which is
              // especially useful for &#x60;global.should = require(&#x27;chai&#x27;).should()&#x60;.
              //
              // Note that we have to use [[DefineProperty]] instead of [[Put]]
              // since otherwise we would trigger this very setter!
              Object.defineProperty(this, &#x27;should&#x27;, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            }
          , get: function(){
              if (this instanceof String || this instanceof Number) {
                return new Assertion(this.constructor(this));
              } else if (this instanceof Boolean) {
                return new Assertion(this == true);
              }
              return new Assertion(this);
            }
          , configurable: true
        });

        var should = {};

        should.equal = function (val1, val2, msg) {
          new Assertion(val1, msg).to.equal(val2);
        };

        should.Throw = function (fn, errt, errs, msg) {
          new Assertion(fn, msg).to.Throw(errt, errs);
        };

        should.exist = function (val, msg) {
          new Assertion(val, msg).to.exist;
        }

        // negation
        should.not = {}

        should.not.equal = function (val1, val2, msg) {
          new Assertion(val1, msg).to.not.equal(val2);
        };

        should.not.Throw = function (fn, errt, errs, msg) {
          new Assertion(fn, msg).to.not.Throw(errt, errs);
        };

        should.not.exist = function (val, msg) {
          new Assertion(val, msg).to.not.exist;
        }

        should[&#x27;throw&#x27;] = should[&#x27;Throw&#x27;];
        should.not[&#x27;throw&#x27;] = should.not[&#x27;Throw&#x27;];

        return should;
      };

      chai.should = loadShould;
      chai.Should = loadShould;
    };

  }); // module: chai/interface/should.js

  require.register(&quot;chai/utils/addChainableMethod.js&quot;, function(module, exports, require){
    /*!
     * Chai - addChainingMethod utility
     * Copyright(c) 2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    /*!
     * Module dependencies
     */

    var transferFlags = require(&#x27;./transferFlags&#x27;);

    /**
     * ### addChainableMethod (ctx, name, method, chainingBehavior)
     *
     * Adds a method to an object, such that the method can also be chained.
     *
     *     utils.addChainableMethod(chai.Assertion.prototype, &#x27;foo&#x27;, function (str) {
     *       var obj = utils.flag(this, &#x27;object&#x27;);
     *       new chai.Assertion(obj).to.be.equal(str);
     *     });
     *
     * Can also be accessed directly from &#x60;chai.Assertion&#x60;.
     *
     *     chai.Assertion.addChainableMethod(&#x27;foo&#x27;, fn, chainingBehavior);
     *
     * The result can then be used as both a method assertion, executing both &#x60;method&#x60; and
     * &#x60;chainingBehavior&#x60;, or as a language chain, which only executes &#x60;chainingBehavior&#x60;.
     *
     *     expect(fooStr).to.be.foo(&#x27;bar&#x27;);
     *     expect(fooStr).to.be.foo.equal(&#x27;foo&#x27;);
     *
     * @param {Object} ctx object to which the method is added
     * @param {String} name of method to add
     * @param {Function} method function to be used for &#x60;name&#x60;, when called
     * @param {Function} chainingBehavior function to be called every time the property is accessed
     * @name addChainableMethod
     * @api public
     */

    module.exports = function (ctx, name, method, chainingBehavior) {
      if (typeof chainingBehavior !== &#x27;function&#x27;)
        chainingBehavior = function () { };

      Object.defineProperty(ctx, name,
        { get: function () {
            chainingBehavior.call(this);

            var assert = function () {
              var result = method.apply(this, arguments);
              return result === undefined ? this : result;
            };

            // Re-enumerate every time to better accomodate plugins.
            var asserterNames = Object.getOwnPropertyNames(ctx);
            asserterNames.forEach(function (asserterName) {
              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName)
                , functionProtoPD = Object.getOwnPropertyDescriptor(Function.prototype, asserterName);
              // Avoid trying to overwrite things that we can&#x27;t, like &#x60;length&#x60; and &#x60;arguments&#x60;.
              if (functionProtoPD &amp;&amp; !functionProtoPD.configurable) return;
              if (asserterName === &#x27;arguments&#x27;) return; // @see chaijs/chai/issues/69
              Object.defineProperty(assert, asserterName, pd);
            });

            transferFlags(this, assert);
            return assert;
          }
        , configurable: true
      });
    };

  }); // module: chai/utils/addChainableMethod.js

  require.register(&quot;chai/utils/addMethod.js&quot;, function(module, exports, require){
    /*!
     * Chai - addMethod utility
     * Copyright(c) 2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    /**
     * ### .addMethod (ctx, name, method)
     *
     * Adds a method to the prototype of an object.
     *
     *     utils.addMethod(chai.Assertion.prototype, &#x27;foo&#x27;, function (str) {
     *       var obj = utils.flag(this, &#x27;object&#x27;);
     *       new chai.Assertion(obj).to.be.equal(str);
     *     });
     *
     * Can also be accessed directly from &#x60;chai.Assertion&#x60;.
     *
     *     chai.Assertion.addMethod(&#x27;foo&#x27;, fn);
     *
     * Then can be used as any other assertion.
     *
     *     expect(fooStr).to.be.foo(&#x27;bar&#x27;);
     *
     * @param {Object} ctx object to which the method is added
     * @param {String} name of method to add
     * @param {Function} method function to be used for name
     * @name addMethod
     * @api public
     */

    module.exports = function (ctx, name, method) {
      ctx[name] = function () {
        var result = method.apply(this, arguments);
        return result === undefined ? this : result;
      };
    };

  }); // module: chai/utils/addMethod.js

  require.register(&quot;chai/utils/addProperty.js&quot;, function(module, exports, require){
    /*!
     * Chai - addProperty utility
     * Copyright(c) 2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    /**
     * ### addProperty (ctx, name, getter)
     *
     * Adds a property to the prototype of an object.
     *
     *     utils.addProperty(chai.Assertion.prototype, &#x27;foo&#x27;, function () {
     *       var obj = utils.flag(this, &#x27;object&#x27;);
     *       new chai.Assertion(obj).to.be.instanceof(Foo);
     *     });
     *
     * Can also be accessed directly from &#x60;chai.Assertion&#x60;.
     *
     *     chai.Assertion.addProperty(&#x27;foo&#x27;, fn);
     *
     * Then can be used as any other assertion.
     *
     *     expect(myFoo).to.be.foo;
     *
     * @param {Object} ctx object to which the property is added
     * @param {String} name of property to add
     * @param {Function} getter function to be used for name
     * @name addProperty
     * @api public
     */

    module.exports = function (ctx, name, getter) {
      Object.defineProperty(ctx, name,
        { get: function () {
            var result = getter.call(this);
            return result === undefined ? this : result;
          }
        , configurable: true
      });
    };

  }); // module: chai/utils/addProperty.js

  require.register(&quot;chai/utils/eql.js&quot;, function(module, exports, require){
    // This is (almost) directly from Node.js assert
    // https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/assert.js

    module.exports = _deepEqual;

    // for the browser
    var Buffer;
    try {
      Buffer = require(&#x27;buffer&#x27;).Buffer;
    } catch (ex) {
      Buffer = {
        isBuffer: function () { return false; }
      };
    }

    function _deepEqual(actual, expected, memos) {

      // 7.1. All identical values are equivalent, as determined by ===.
      if (actual === expected) {
        return true;

      } else if (Buffer.isBuffer(actual) &amp;&amp; Buffer.isBuffer(expected)) {
        if (actual.length != expected.length) return false;

        for (var i = 0; i &lt; actual.length; i++) {
          if (actual[i] !== expected[i]) return false;
        }

        return true;

      // 7.2. If the expected value is a Date object, the actual value is
      // equivalent if it is also a Date object that refers to the same time.
      } else if (actual instanceof Date &amp;&amp; expected instanceof Date) {
        return actual.getTime() === expected.getTime();

      // 7.3. Other pairs that do not both pass typeof value == &#x27;object&#x27;,
      // equivalence is determined by ==.
      } else if (typeof actual != &#x27;object&#x27; &amp;&amp; typeof expected != &#x27;object&#x27;) {
        return actual === expected;

      // 7.4. For all other Object pairs, including Array objects, equivalence is
      // determined by having the same number of owned properties (as verified
      // with Object.prototype.hasOwnProperty.call), the same set of keys
      // (although not necessarily the same order), equivalent values for every
      // corresponding key, and an identical &#x27;prototype&#x27; property. Note: this
      // accounts for both named and indexed properties on Arrays.
      } else {
        return objEquiv(actual, expected, memos);
      }
    }

    function isUndefinedOrNull(value) {
      return value === null || value === undefined;
    }

    function isArguments(object) {
      return Object.prototype.toString.call(object) == &#x27;[object Arguments]&#x27;;
    }

    function objEquiv(a, b, memos) {
      if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
        return false;

      // an identical &#x27;prototype&#x27; property.
      if (a.prototype !== b.prototype) return false;

      // check if we have already compared a and b
      var i;
      if (memos) {
        for(i = 0; i &lt; memos.length; i++) {
          if ((memos[i][0] === a &amp;&amp; memos[i][1] === b) ||
              (memos[i][0] === b &amp;&amp; memos[i][1] === a))
            return true;
        }
      } else {
        memos = [];
      }

      //~~~I&#x27;ve managed to break Object.keys through screwy arguments passing.
      //   Converting to array solves the problem.
      if (isArguments(a)) {
        if (!isArguments(b)) {
          return false;
        }
        a = pSlice.call(a);
        b = pSlice.call(b);
        return _deepEqual(a, b, memos);
      }
      try {
        var ka = Object.keys(a),
            kb = Object.keys(b),
            key;
      } catch (e) {//happens when one is a string literal and the other isn&#x27;t
        return false;
      }

      // having the same number of owned properties (keys incorporates
      // hasOwnProperty)
      if (ka.length != kb.length)
        return false;

      //the same set of keys (although not necessarily the same order),
      ka.sort();
      kb.sort();
      //~~~cheap key test
      for (i = ka.length - 1; i &gt;= 0; i--) {
        if (ka[i] != kb[i])
          return false;
      }

      // remember objects we have compared to guard against circular references
      memos.push([ a, b ]);

      //equivalent values for every corresponding key, and
      //~~~possibly expensive deep test
      for (i = ka.length - 1; i &gt;= 0; i--) {
        key = ka[i];
        if (!_deepEqual(a[key], b[key], memos)) return false;
      }

      return true;
    }

  }); // module: chai/utils/eql.js

  require.register(&quot;chai/utils/flag.js&quot;, function(module, exports, require){
    /*!
     * Chai - flag utility
     * Copyright(c) 2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    /**
     * ### flag(object ,key, [value])
     *
     * Get or set a flag value on an object. If a
     * value is provided it will be set, else it will
     * return the currently set value or &#x60;undefined&#x60; if
     * the value is not set.
     *
     *     utils.flag(this, &#x27;foo&#x27;, &#x27;bar&#x27;); // setter
     *     utils.flag(this, &#x27;foo&#x27;); // getter, returns &#x60;bar&#x60;
     *
     * @param {Object} object (constructed Assertion
     * @param {String} key
     * @param {Mixed} value (optional)
     * @name flag
     * @api private
     */

    module.exports = function (obj, key, value) {
      var flags = obj.__flags || (obj.__flags = Object.create(null));
      if (arguments.length === 3) {
        flags[key] = value;
      } else {
        return flags[key];
      }
    };

  }); // module: chai/utils/flag.js

  require.register(&quot;chai/utils/getActual.js&quot;, function(module, exports, require){
    /*!
     * Chai - getActual utility
     * Copyright(c) 2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    /**
     * # getActual(object, [actual])
     *
     * Returns the &#x60;actual&#x60; value for an Assertion
     *
     * @param {Object} object (constructed Assertion)
     * @param {Arguments} chai.Assertion.prototype.assert arguments
     */

    module.exports = function (obj, args) {
      var actual = args[4];
      return &#x27;undefined&#x27; !== typeof actual ? actual : obj._obj;
    };

  }); // module: chai/utils/getActual.js

  require.register(&quot;chai/utils/getMessage.js&quot;, function(module, exports, require){
    /*!
     * Chai - message composition utility
     * Copyright(c) 2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    /*!
     * Module dependancies
     */

    var flag = require(&#x27;./flag&#x27;)
      , getActual = require(&#x27;./getActual&#x27;)
      , inspect = require(&#x27;./inspect&#x27;)
      , objDisplay = require(&#x27;./objDisplay&#x27;);

    /**
     * ### .getMessage(object, message, negateMessage)
     *
     * Construct the error message based on flags
     * and template tags. Template tags will return
     * a stringified inspection of the object referenced.
     *
     * Messsage template tags:
     * - &#x60;#{this}&#x60; current asserted object
     * - &#x60;#{act}&#x60; actual value
     * - &#x60;#{exp}&#x60; expected value
     *
     * @param {Object} object (constructed Assertion)
     * @param {Arguments} chai.Assertion.prototype.assert arguments
     * @name getMessage
     * @api public
     */

    module.exports = function (obj, args) {
      var negate = flag(obj, &#x27;negate&#x27;)
        , val = flag(obj, &#x27;object&#x27;)
        , expected = args[3]
        , actual = getActual(obj, args)
        , msg = negate ? args[2] : args[1]
        , flagMsg = flag(obj, &#x27;message&#x27;);

      msg = msg || &#x27;&#x27;;
      msg = msg
        .replace(/#{this}/g, objDisplay(val))
        .replace(/#{act}/g, objDisplay(actual))
        .replace(/#{exp}/g, objDisplay(expected));

      return flagMsg ? flagMsg + &#x27;: &#x27; + msg : msg;
    };

  }); // module: chai/utils/getMessage.js

  require.register(&quot;chai/utils/getName.js&quot;, function(module, exports, require){
    /*!
     * Chai - getName utility
     * Copyright(c) 2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    /**
     * # getName(func)
     *
     * Gets the name of a function, in a cross-browser way.
     *
     * @param {Function} a function (usually a constructor)
     */

    module.exports = function (func) {
      if (func.name) return func.name;

      var match = /^\s?function ([^(]*)\(/.exec(func);
      return match &amp;&amp; match[1] ? match[1] : &quot;&quot;;
    };

  }); // module: chai/utils/getName.js

  require.register(&quot;chai/utils/getPathValue.js&quot;, function(module, exports, require){
    /*!
     * Chai - getPathValue utility
     * Copyright(c) 2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * @see https://github.com/logicalparadox/filtr
     * MIT Licensed
     */

    /**
     * ### .getPathValue(path, object)
     *
     * This allows the retrieval of values in an
     * object given a string path.
     *
     *     var obj = {
     *         prop1: {
     *             arr: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]
     *           , str: &#x27;Hello&#x27;
     *         }
     *       , prop2: {
     *             arr: [ { nested: &#x27;Universe&#x27; } ]
     *           , str: &#x27;Hello again!&#x27;
     *         }
     *     }
     *
     * The following would be the results.
     *
     *     getPathValue(&#x27;prop1.str&#x27;, obj); // Hello
     *     getPathValue(&#x27;prop1.att[2]&#x27;, obj); // b
     *     getPathValue(&#x27;prop2.arr[0].nested&#x27;, obj); // Universe
     *
     * @param {String} path
     * @param {Object} object
     * @returns {Object} value or &#x60;undefined&#x60;
     * @name getPathValue
     * @api public
     */

    var getPathValue = module.exports = function (path, obj) {
      var parsed = parsePath(path);
      return _getPathValue(parsed, obj);
    };

    /*!
     * ## parsePath(path)
     *
     * Helper function used to parse string object
     * paths. Use in conjunction with &#x60;_getPathValue&#x60;.
     *
     *      var parsed = parsePath(&#x27;myobject.property.subprop&#x27;);
     *
     * ### Paths:
     *
     * * Can be as near infinitely deep and nested
     * * Arrays are also valid using the formal &#x60;myobject.document[3].property&#x60;.
     *
     * @param {String} path
     * @returns {Object} parsed
     * @api private
     */

    function parsePath (path) {
      var str = path.replace(/\[/g, &#x27;.[&#x27;)
        , parts = str.match(/(\\\.|[^.]+?)+/g);
      return parts.map(function (value) {
        var re = /\[(\d+)\]$/
          , mArr = re.exec(value)
        if (mArr) return { i: parseFloat(mArr[1]) };
        else return { p: value };
      });
    };

    /*!
     * ## _getPathValue(parsed, obj)
     *
     * Helper companion function for &#x60;.parsePath&#x60; that returns
     * the value located at the parsed address.
     *
     *      var value = getPathValue(parsed, obj);
     *
     * @param {Object} parsed definition from &#x60;parsePath&#x60;.
     * @param {Object} object to search against
     * @returns {Object|Undefined} value
     * @api private
     */

    function _getPathValue (parsed, obj) {
      var tmp = obj
        , res;
      for (var i = 0, l = parsed.length; i &lt; l; i++) {
        var part = parsed[i];
        if (tmp) {
          if (&#x27;undefined&#x27; !== typeof part.p)
            tmp = tmp[part.p];
          else if (&#x27;undefined&#x27; !== typeof part.i)
            tmp = tmp[part.i];
          if (i == (l - 1)) res = tmp;
        } else {
          res = undefined;
        }
      }
      return res;
    };

  }); // module: chai/utils/getPathValue.js

  require.register(&quot;chai/utils/index.js&quot;, function(module, exports, require){
    /*!
     * chai
     * Copyright(c) 2011 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    /*!
     * Main exports
     */

    var exports = module.exports = {};

    /*!
     * test utility
     */

    exports.test = require(&#x27;./test&#x27;);

    /*!
     * message utility
     */

    exports.getMessage = require(&#x27;./getMessage&#x27;);

    /*!
     * actual utility
     */

    exports.getActual = require(&#x27;./getActual&#x27;);

    /*!
     * Inspect util
     */

    exports.inspect = require(&#x27;./inspect&#x27;);

    /*!
     * Object Display util
     */

    exports.objDisplay = require(&#x27;./objDisplay&#x27;);

    /*!
     * Flag utility
     */

    exports.flag = require(&#x27;./flag&#x27;);

    /*!
     * Flag transferring utility
     */

    exports.transferFlags = require(&#x27;./transferFlags&#x27;);

    /*!
     * Deep equal utility
     */

    exports.eql = require(&#x27;./eql&#x27;);

    /*!
     * Deep path value
     */

    exports.getPathValue = require(&#x27;./getPathValue&#x27;);

    /*!
     * Function name
     */

    exports.getName = require(&#x27;./getName&#x27;);

    /*!
     * add Property
     */

    exports.addProperty = require(&#x27;./addProperty&#x27;);

    /*!
     * add Method
     */

    exports.addMethod = require(&#x27;./addMethod&#x27;);

    /*!
     * overwrite Property
     */

    exports.overwriteProperty = require(&#x27;./overwriteProperty&#x27;);

    /*!
     * overwrite Method
     */

    exports.overwriteMethod = require(&#x27;./overwriteMethod&#x27;);

    /*!
     * Add a chainable method
     */

    exports.addChainableMethod = require(&#x27;./addChainableMethod&#x27;);


  }); // module: chai/utils/index.js

  require.register(&quot;chai/utils/inspect.js&quot;, function(module, exports, require){
    // This is (almost) directly from Node.js utils
    // https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

    var getName = require(&#x27;./getName&#x27;);

    module.exports = inspect;

    /**
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param {Object} obj The object to print out.
     * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
     *    properties of objects.
     * @param {Number} depth Depth in which to descend in object. Default is 2.
     * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
     *    output. Default is false (no coloring).
     */
    function inspect(obj, showHidden, depth, colors) {
      var ctx = {
        showHidden: showHidden,
        seen: [],
        stylize: function (str) { return str; }
      };
      return formatValue(ctx, obj, (typeof depth === &#x27;undefined&#x27; ? 2 : depth));
    }

    // https://gist.github.com/1044128/
    var getOuterHTML = function(element) {
      if (&#x27;outerHTML&#x27; in element) return element.outerHTML;
      var ns = &quot;http://www.w3.org/1999/xhtml&quot;;
      var container = document.createElementNS(ns, &#x27;_&#x27;);
      var elemProto = (window.HTMLElement || window.Element).prototype;
      var xmlSerializer = new XMLSerializer();
      var html;
      if (document.xmlVersion) {
        return xmlSerializer.serializeToString(element);
      } else {
        container.appendChild(element.cloneNode(false));
        html = container.innerHTML.replace(&#x27;&gt;&lt;&#x27;, &#x27;&gt;&#x27; + element.innerHTML + &#x27;&lt;&#x27;);
        container.innerHTML = &#x27;&#x27;;
        return html;
      }
    };
      
    // Returns true if object is a DOM element.
    var isDOMElement = function (object) {
      if (typeof HTMLElement === &#x27;object&#x27;) {
        return object instanceof HTMLElement;
      } else {
        return object &amp;&amp;
          typeof object === &#x27;object&#x27; &amp;&amp;
          object.nodeType === 1 &amp;&amp;
          typeof object.nodeName === &#x27;string&#x27;;
      }
    };

    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (value &amp;&amp; typeof value.inspect === &#x27;function&#x27; &amp;&amp;
          // Filter out the util module, it&#x27;s inspect function is special
          value.inspect !== exports.inspect &amp;&amp;
          // Also filter out any prototype objects using the circular check.
          !(value.constructor &amp;&amp; value.constructor.prototype === value)) {
        return value.inspect(recurseTimes);
      }

      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }

      // If it&#x27;s DOM elem, get outer HTML.
      if (isDOMElement(value)) {
        return getOuterHTML(value);
      }

      // Look up the keys of the object.
      var visibleKeys = Object.keys(value);
      var keys = ctx.showHidden ? Object.getOwnPropertyNames(value) : visibleKeys;

      // Some type of object without properties can be shortcutted.
      // In IE, errors have a single &#x60;stack&#x60; property, or if they are vanilla &#x60;Error&#x60;,
      // a &#x60;stack&#x60; plus &#x60;description&#x60; property; ignore those for consistency.
      if (keys.length === 0 || (isError(value) &amp;&amp; (
          (keys.length === 1 &amp;&amp; keys[0] === &#x27;stack&#x27;) ||
          (keys.length === 2 &amp;&amp; keys[0] === &#x27;description&#x27; &amp;&amp; keys[1] === &#x27;stack&#x27;)
         ))) {
        if (typeof value === &#x27;function&#x27;) {
          var name = getName(value);
          var nameSuffix = name ? &#x27;: &#x27; + name : &#x27;&#x27;;
          return ctx.stylize(&#x27;[Function&#x27; + nameSuffix + &#x27;]&#x27;, &#x27;special&#x27;);
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), &#x27;regexp&#x27;);
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toUTCString.call(value), &#x27;date&#x27;);
        }
        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = &#x27;&#x27;, array = false, braces = [&#x27;{&#x27;, &#x27;}&#x27;];

      // Make Array say that they are Array
      if (isArray(value)) {
        array = true;
        braces = [&#x27;[&#x27;, &#x27;]&#x27;];
      }

      // Make functions say that they are functions
      if (typeof value === &#x27;function&#x27;) {
        var name = getName(value);
        var nameSuffix = name ? &#x27;: &#x27; + name : &#x27;&#x27;;
        base = &#x27; [Function&#x27; + nameSuffix + &#x27;]&#x27;;
      }

      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = &#x27; &#x27; + RegExp.prototype.toString.call(value);
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = &#x27; &#x27; + Date.prototype.toUTCString.call(value);
      }

      // Make error with message first say the error
      if (isError(value)) {
        return formatError(value);
      }

      if (keys.length === 0 &amp;&amp; (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes &lt; 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), &#x27;regexp&#x27;);
        } else {
          return ctx.stylize(&#x27;[Object]&#x27;, &#x27;special&#x27;);
        }
      }

      ctx.seen.push(value);

      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();

      return reduceToSingleString(output, base, braces);
    }


    function formatPrimitive(ctx, value) {
      switch (typeof value) {
        case &#x27;undefined&#x27;:
          return ctx.stylize(&#x27;undefined&#x27;, &#x27;undefined&#x27;);

        case &#x27;string&#x27;:
          var simple = &#x27;\&#x27;&#x27; + JSON.stringify(value).replace(/^&quot;|&quot;$/g, &#x27;&#x27;)
                                                   .replace(/&#x27;/g, &quot;\\&#x27;&quot;)
                                                   .replace(/\\&quot;/g, &#x27;&quot;&#x27;) + &#x27;\&#x27;&#x27;;
          return ctx.stylize(simple, &#x27;string&#x27;);

        case &#x27;number&#x27;:
          return ctx.stylize(&#x27;&#x27; + value, &#x27;number&#x27;);

        case &#x27;boolean&#x27;:
          return ctx.stylize(&#x27;&#x27; + value, &#x27;boolean&#x27;);
      }
      // For some reason typeof null is &quot;object&quot;, so special case here.
      if (value === null) {
        return ctx.stylize(&#x27;null&#x27;, &#x27;null&#x27;);
      }
    }


    function formatError(value) {
      return &#x27;[&#x27; + Error.prototype.toString.call(value) + &#x27;]&#x27;;
    }


    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i &lt; l; ++i) {
        if (Object.prototype.hasOwnProperty.call(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              String(i), true));
        } else {
          output.push(&#x27;&#x27;);
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              key, true));
        }
      });
      return output;
    }


    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = ctx.stylize(&#x27;[Getter/Setter]&#x27;, &#x27;special&#x27;);
          } else {
            str = ctx.stylize(&#x27;[Getter]&#x27;, &#x27;special&#x27;);
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = ctx.stylize(&#x27;[Setter]&#x27;, &#x27;special&#x27;);
          }
        }
      }
      if (visibleKeys.indexOf(key) &lt; 0) {
        name = &#x27;[&#x27; + key + &#x27;]&#x27;;
      }
      if (!str) {
        if (ctx.seen.indexOf(value[key]) &lt; 0) {
          if (recurseTimes === null) {
            str = formatValue(ctx, value[key], null);
          } else {
            str = formatValue(ctx, value[key], recurseTimes - 1);
          }
          if (str.indexOf(&#x27;\n&#x27;) &gt; -1) {
            if (array) {
              str = str.split(&#x27;\n&#x27;).map(function(line) {
                return &#x27;  &#x27; + line;
              }).join(&#x27;\n&#x27;).substr(2);
            } else {
              str = &#x27;\n&#x27; + str.split(&#x27;\n&#x27;).map(function(line) {
                return &#x27;   &#x27; + line;
              }).join(&#x27;\n&#x27;);
            }
          }
        } else {
          str = ctx.stylize(&#x27;[Circular]&#x27;, &#x27;special&#x27;);
        }
      }
      if (typeof name === &#x27;undefined&#x27;) {
        if (array &amp;&amp; key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify(&#x27;&#x27; + key);
        if (name.match(/^&quot;([a-zA-Z_][a-zA-Z_0-9]*)&quot;$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, &#x27;name&#x27;);
        } else {
          name = name.replace(/&#x27;/g, &quot;\\&#x27;&quot;)
                     .replace(/\\&quot;/g, &#x27;&quot;&#x27;)
                     .replace(/(^&quot;|&quot;$)/g, &quot;&#x27;&quot;);
          name = ctx.stylize(name, &#x27;string&#x27;);
        }
      }

      return name + &#x27;: &#x27; + str;
    }


    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf(&#x27;\n&#x27;) &gt;= 0) numLinesEst++;
        return prev + cur.length + 1;
      }, 0);

      if (length &gt; 60) {
        return braces[0] +
               (base === &#x27;&#x27; ? &#x27;&#x27; : base + &#x27;\n &#x27;) +
               &#x27; &#x27; +
               output.join(&#x27;,\n  &#x27;) +
               &#x27; &#x27; +
               braces[1];
      }

      return braces[0] + base + &#x27; &#x27; + output.join(&#x27;, &#x27;) + &#x27; &#x27; + braces[1];
    }

    function isArray(ar) {
      return Array.isArray(ar) ||
             (typeof ar === &#x27;object&#x27; &amp;&amp; objectToString(ar) === &#x27;[object Array]&#x27;);
    }

    function isRegExp(re) {
      return typeof re === &#x27;object&#x27; &amp;&amp; objectToString(re) === &#x27;[object RegExp]&#x27;;
    }

    function isDate(d) {
      return typeof d === &#x27;object&#x27; &amp;&amp; objectToString(d) === &#x27;[object Date]&#x27;;
    }

    function isError(e) {
      return typeof e === &#x27;object&#x27; &amp;&amp; objectToString(e) === &#x27;[object Error]&#x27;;
    }

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }

  }); // module: chai/utils/inspect.js

  require.register(&quot;chai/utils/objDisplay.js&quot;, function(module, exports, require){
    /*!
     * Chai - flag utility
     * Copyright(c) 2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    /*!
     * Module dependancies
     */

    var inspect = require(&#x27;./inspect&#x27;);

    /**
     * ### .objDisplay (object)
     *
     * Determines if an object or an array matches
     * criteria to be inspected in-line for error
     * messages or should be truncated.
     *
     * @param {Mixed} javascript object to inspect
     * @name objDisplay
     * @api public
     */

    module.exports = function (obj) {
      var str = inspect(obj)
        , type = Object.prototype.toString.call(obj);

      if (str.length &gt;= 40) {
        if (type === &#x27;[object Array]&#x27;) {
          return &#x27;[ Array(&#x27; + obj.length + &#x27;) ]&#x27;;
        } else if (type === &#x27;[object Object]&#x27;) {
          var keys = Object.keys(obj)
            , kstr = keys.length &gt; 2
              ? keys.splice(0, 2).join(&#x27;, &#x27;) + &#x27;, ...&#x27;
              : keys.join(&#x27;, &#x27;);
          return &#x27;{ Object (&#x27; + kstr + &#x27;) }&#x27;;
        } else {
          return str;
        }
      } else {
        return str;
      }
    };

  }); // module: chai/utils/objDisplay.js

  require.register(&quot;chai/utils/overwriteMethod.js&quot;, function(module, exports, require){
    /*!
     * Chai - overwriteMethod utility
     * Copyright(c) 2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    /**
     * ### overwriteMethod (ctx, name, fn)
     *
     * Overwites an already existing method and provides
     * access to previous function. Must return function
     * to be used for name.
     *
     *     utils.overwriteMethod(chai.Assertion.prototype, &#x27;equal&#x27;, function (_super) {
     *       return function (str) {
     *         var obj = utils.flag(this, &#x27;object&#x27;);
     *         if (obj instanceof Foo) {
     *           new chai.Assertion(obj.value).to.equal(str);
     *         } else {
     *           _super.apply(this, arguments);
     *         }
     *       }
     *     });
     *
     * Can also be accessed directly from &#x60;chai.Assertion&#x60;.
     *
     *     chai.Assertion.overwriteMethod(&#x27;foo&#x27;, fn);
     *
     * Then can be used as any other assertion.
     *
     *     expect(myFoo).to.equal(&#x27;bar&#x27;);
     *
     * @param {Object} ctx object whose method is to be overwritten
     * @param {String} name of method to overwrite
     * @param {Function} method function that returns a function to be used for name
     * @name overwriteMethod
     * @api public
     */

    module.exports = function (ctx, name, method) {
      var _method = ctx[name]
        , _super = function () { return this; };

      if (_method &amp;&amp; &#x27;function&#x27; === typeof _method)
        _super = _method;

      ctx[name] = function () {
        var result = method(_super).apply(this, arguments);
        return result === undefined ? this : result;
      }
    };

  }); // module: chai/utils/overwriteMethod.js

  require.register(&quot;chai/utils/overwriteProperty.js&quot;, function(module, exports, require){
    /*!
     * Chai - overwriteProperty utility
     * Copyright(c) 2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    /**
     * ### overwriteProperty (ctx, name, fn)
     *
     * Overwites an already existing property getter and provides
     * access to previous value. Must return function to use as getter.
     *
     *     utils.overwriteProperty(chai.Assertion.prototype, &#x27;ok&#x27;, function (_super) {
     *       return function () {
     *         var obj = utils.flag(this, &#x27;object&#x27;);
     *         if (obj instanceof Foo) {
     *           new chai.Assertion(obj.name).to.equal(&#x27;bar&#x27;);
     *         } else {
     *           _super.call(this);
     *         }
     *       }
     *     });
     *
     *
     * Can also be accessed directly from &#x60;chai.Assertion&#x60;.
     *
     *     chai.Assertion.overwriteProperty(&#x27;foo&#x27;, fn);
     *
     * Then can be used as any other assertion.
     *
     *     expect(myFoo).to.be.ok;
     *
     * @param {Object} ctx object whose property is to be overwritten
     * @param {String} name of property to overwrite
     * @param {Function} getter function that returns a getter function to be used for name
     * @name overwriteProperty
     * @api public
     */

    module.exports = function (ctx, name, getter) {
      var _get = Object.getOwnPropertyDescriptor(ctx, name)
        , _super = function () {};

      if (_get &amp;&amp; &#x27;function&#x27; === typeof _get.get)
        _super = _get.get

      Object.defineProperty(ctx, name,
        { get: function () {
            var result = getter(_super).call(this);
            return result === undefined ? this : result;
          }
        , configurable: true
      });
    };

  }); // module: chai/utils/overwriteProperty.js

  require.register(&quot;chai/utils/test.js&quot;, function(module, exports, require){
    /*!
     * Chai - test utility
     * Copyright(c) 2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    /*!
     * Module dependancies
     */

    var flag = require(&#x27;./flag&#x27;);

    /**
     * # test(object, expression)
     *
     * Test and object for expression.
     *
     * @param {Object} object (constructed Assertion)
     * @param {Arguments} chai.Assertion.prototype.assert arguments
     */

    module.exports = function (obj, args) {
      var negate = flag(obj, &#x27;negate&#x27;)
        , expr = args[0];
      return negate ? !expr : expr;
    };

  }); // module: chai/utils/test.js

  require.register(&quot;chai/utils/transferFlags.js&quot;, function(module, exports, require){
    /*!
     * Chai - transferFlags utility
     * Copyright(c) 2012 Jake Luer &lt;jake@alogicalparadox.com&gt;
     * MIT Licensed
     */

    /**
     * ### transferFlags(assertion, object, includeAll = true)
     *
     * Transfer all the flags for &#x60;assertion&#x60; to &#x60;object&#x60;. If
     * &#x60;includeAll&#x60; is set to &#x60;false&#x60;, then the base Chai
     * assertion flags (namely &#x60;object&#x60;, &#x60;ssfi&#x60;, and &#x60;message&#x60;)
     * will not be transferred.
     *
     *
     *     var newAssertion = new Assertion();
     *     utils.transferFlags(assertion, newAssertion);
     *
     *     var anotherAsseriton = new Assertion(myObj);
     *     utils.transferFlags(assertion, anotherAssertion, false);
     *
     * @param {Assertion} assertion the assertion to transfer the flags from
     * @param {Object} object the object to transfer the flags too; usually a new assertion
     * @param {Boolean} includeAll
     * @name getAllFlags
     * @api private
     */

    module.exports = function (assertion, object, includeAll) {
      var flags = assertion.__flags || (assertion.__flags = Object.create(null));

      if (!object.__flags) {
        object.__flags = Object.create(null);
      }

      includeAll = arguments.length === 3 ? includeAll : true;

      for (var flag in flags) {
        if (includeAll ||
            (flag !== &#x27;object&#x27; &amp;&amp; flag !== &#x27;ssfi&#x27; &amp;&amp; flag != &#x27;message&#x27;)) {
          object.__flags[flag] = flags[flag];
        }
      }
    };

  }); // module: chai/utils/transferFlags.js

  require.alias(&quot;./chai.js&quot;, &quot;chai&quot;);

  return require(&#x27;chai&#x27;);
});
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
